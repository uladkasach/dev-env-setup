# git graft â€” blueprint

## overview

add `git graft` alias to replay commits onto a different base via cherry-pick.

follows the pattern of current git aliases:
- `git_alias_release` â€” check release status
- `git_alias_tree` â€” manage worktrees
- `git_alias_grab` â€” save/load patches

## filediffs

```
src/
  [~] bash_aliases.sh        # add git_alias_graft function
  [~] install_env.sh         # add git config alias.graft
```

## codepaths

```
src/bash_aliases.sh
  [â—‹] git_alias_release()
  [â—‹] git_alias_tree()
  [â—‹] git_alias_grab()
  [+] git_alias_graft()
      [+] handle --continue: resume cherry-pick, check worktree, move branch, clean up
      [+] handle --abort: abort cherry-pick, checkout branch, clean up
      [+] handle --help
      [+] parse args: --onto, --from, --till, --mode
      [+] validate required args
      [+] validate mode is plan|apply
      [+] get current branch (failfast if detached)
      [+] get commits via git rev-list --reverse with ancestry filter
      [+] show plan output
      [+] if mode=apply:
          [+] failfast if work tree is dirty
          [+] save branch name to .git/GRAFT_ORIG_HEAD
          [+] git checkout --detach <onto> (branch untouched)
          [+] git cherry-pick <commits> in detached HEAD
          [+] on success: failfast if branch in another worktree
          [+] on success: git branch -f + checkout + clean up
          [+] on conflict: show --continue/--abort instructions

src/install_env.sh
  [â—‹] git config --global alias.release ...
  [â—‹] git config --global alias.tree ...
  [â—‹] git config --global alias.grab ...
  [+] git config --global alias.graft '!bash -c "source ~/.bash_aliases && git_alias_graft \"$@\"" --'
```

## contract

```bash
git graft --onto <ref> --from <commit> [--till <commit>] [--mode plan|apply]
git graft --continue
git graft --abort
```

| arg | required | default | description |
|-----|----------|---------|-------------|
| --onto | yes | â€” | target base to replay onto |
| --from | yes | â€” | first commit (inclusive) |
| --till | no | HEAD | last commit (inclusive) |
| --mode | no | plan | plan or apply |
| --continue | â€” | â€” | resume after conflict resolution |
| --abort | â€” | â€” | cancel graft and restore original HEAD |

## implementation

### arg parse

```bash
local onto="" from="" till="HEAD" mode="plan"

local prev=""
for arg in "$@"; do
  if [[ "$prev" == "--onto" ]]; then onto="$arg"; prev=""; continue; fi
  if [[ "$prev" == "--from" ]]; then from="$arg"; prev=""; continue; fi
  if [[ "$prev" == "--till" ]]; then till="$arg"; prev=""; continue; fi
  if [[ "$prev" == "--mode" ]]; then mode="$arg"; prev=""; continue; fi
  case "$arg" in
    --onto) prev="--onto" ;;
    --from) prev="--from" ;;
    --till) prev="--till" ;;
    --mode) prev="--mode" ;;
    *) echo "error: unknown argument '$arg'"; return 1 ;;
  esac
done
```

### commit range

```bash
# ${from}^ makes --from inclusive
# ^${onto} excludes commits already reachable from onto (ancestry filter)
local commits=$(git rev-list --reverse "${from}^..${till}" "^${onto}" 2>/dev/null)
```

### plan output

```
ðŸŒ² graft (plan)
   â”œâ”€ branch: feat/b
   â”œâ”€ onto: main
   â”œâ”€ from: abc123
   â”œâ”€ till: HEAD
   â”œâ”€ commits: 2
   â”‚  â”œâ”€ abc123 first change
   â”‚  â””â”€ def456 second change
   â””â”€ use --mode apply to execute
```

### apply execution

```bash
# failfast if work tree is dirty
if [[ -n "$(git status --porcelain)" ]]; then
  echo "â›ˆï¸  work tree is dirty â€” commit or stash before apply"
  return 1
fi

# save branch name (branch itself stays safe until success)
echo "$current_branch" > ".git/GRAFT_ORIG_HEAD"

# detach to onto target (branch untouched)
git checkout --detach "$onto"

# cherry-pick in detached HEAD
if git cherry-pick $commits; then
  # failfast if branch is checked out in another worktree
  # move branch pointer to result and checkout
  git branch -f "$current_branch" HEAD
  git checkout "$current_branch"
  rm -f ".git/GRAFT_ORIG_HEAD"
else
  # conflict: branch untouched, state preserved for --continue/--abort
  return 1
fi
```

### --continue

```bash
local branch=$(head -1 ".git/GRAFT_ORIG_HEAD")
git cherry-pick --continue
# failfast if branch is checked out in another worktree
git branch -f "$branch" HEAD
git checkout "$branch"
rm -f ".git/GRAFT_ORIG_HEAD"
```

### --abort

```bash
local branch=$(head -1 ".git/GRAFT_ORIG_HEAD")
git cherry-pick --abort
git checkout "$branch"    # branch was never moved
rm -f ".git/GRAFT_ORIG_HEAD"
```

### conflict recovery

```
ðŸŸ¡ cherry-pick conflict!
â”œâ”€ resolve conflicts, then: git graft --continue
â””â”€ or abort: git graft --abort
```

## test coverage

this is a shell alias in a personal dotfiles repo. tests are manual:

1. create test branches with known commits
2. run `git graft --onto X --from Y` and verify plan output
3. run with `--mode apply` and verify branch state
4. test conflict scenario and verify recovery instructions
5. test edge cases: single commit, invalid args, detached HEAD

## notes

- uses cherry-pick (not rebase) so no dependency on old base
- detached HEAD strategy: branch is never touched until all commits land clean
- `--from` is inclusive via `${from}^` range syntax
- `^${onto}` excludes commits already reachable from onto (no duplicates)
- state persisted to `.git/GRAFT_ORIG_HEAD` (branch name) for conflict recovery
- failfast on dirty work tree before apply
- failfast if branch is checked out in another worktree before move
- plan mode is default for safety
- aligns with current alias patterns in bash_aliases.sh
