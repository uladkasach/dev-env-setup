wish =


add a git alias                                                                                                         
                                                                                                                          
  to fulfill the following behavior                                                                                       
                                                                                                                          
  git graft --onto x --from y  



 takes the branch from ref y (branch name, commit, etc)                                                                  
                                                                                                                          
  puts it on the branch from ref x                                                                                        
                                                                                                                          
  should do that in the current branch                                                                                    
                                                                                                                          
  the primary usecase is to replay changes --from y --onto a different base (e.g., cascade prs)  




and what if i tell it a specific commit? i..,e think of the usecase where feat/a continued and feat/b had some     
   stale commits from feat/a (e.g., after rebase)     


also, what about the scenario where A2 has been replaced with A2' on feat/a , but feat/b still has A2?             
                                                                                                                          
  or even, feat/a was already merged into main, squashed - none of those A comits exist  


---

think through the varios usecases that someone may want to graft a chain of commits onto a given commit



---


e.g., 

                                                                                                     
  Scenario 1: A2 → A2' (rebase)                                                                                               
  feat/a:   A1' - A2' - A3'  (rebased, new SHAs)
                                                                                                                              
  feat/b:   A1 - A2 - B1 - B2  (still has old A1, A2)                          

  Scenario 2: squash merge
  main:     M1 - M2 - S  (S = squash of A1+A2+A3)

  feat/b:   A1 - A2 - B1 - B2  (A1, A2 are orphaned)



and assume we wont have knowledge of the A2 commit; only can specify which ones to keep from


❯ yeah i specifically wont have access to A2; i want to be able to say --take B1..HEAD only, really. (or explicit B1..B2)     
   no randos                                            

---

❯ also, lets make --mode plan | apply, with plan as the default   


---

also, grab vs take?
                                                                                                                              
  ❯ yeah, lets use grab                                                                                                       
  ❯ do the semantics of git grab and git graft --grab align?                                                                  



also, lets go back to --from ; i.e., pick all --from x ; --till Y optionally 


and --from B1 --till B1 should work as 'just that one'    


---


and does this do the --ansestry flag to ensure that only our commits are included?       


and if there's a cherry-pick conflict, how does it help us continue the graft onto the branch? 

───────────────────────────────────────────────────────────
