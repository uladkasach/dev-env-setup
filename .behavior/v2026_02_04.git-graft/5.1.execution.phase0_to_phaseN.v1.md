# git graft — execution log

## phase 0: behavior spec

defined the behavior files from wish through blueprint.

- `0.wish.md` — raw requirements and use case discussion
- `1.vision.md` — before/after, mental model, contract, edgecases
- `2.1.criteria.blackbox.md` — 7 usecases as given/when/then
- `3.3.blueprint.v1.i1.md` — filediffs, codepaths, implementation

key decisions:
- `--from` / `--till` over `--pick` / `--take` (clearer intent)
- `--mode plan | apply` over a boolean flag
- cherry-pick over rebase (no dependency on old base)
- inclusive `--from` via `${from}^` range syntax

## phase 1: core implementation

added `git_alias_graft()` to `src/bash_aliases.sh` and alias to `src/install_env.sh`.

delivered:
- arg parse for `--onto`, `--from`, `--till`, `--mode`
- validation: required args, mode values, branch check
- plan mode: tree-style output with branch, target, commit list
- apply mode: `git reset --hard $onto` + `git cherry-pick $commits`
- `--help` with usage, options, examples
- git alias: `git config --global alias.graft ...`

initial apply used `git reset --hard` directly on the branch — destructive, recovery via state file only.

## phase 2: ancestry filter + conflict recovery

two additions based on review:

**ancestry filter**:
- added `^${onto}` to `git rev-list` to exclude commits already reachable from target
- prevents duplicate commits when source range overlaps with onto

**conflict recovery**:
- state persistence to `.git/GRAFT_ORIG_HEAD`
- `--continue`: resume cherry-pick, clean up state
- `--abort`: abort cherry-pick, reset to saved HEAD, clean up state
- conflict output: `git graft --continue` / `git graft --abort` (not raw cherry-pick commands)

updated all behavior files (vision, criteria, blueprint) to match.

## phase 3: detached HEAD strategy

replaced direct `git reset --hard` with detached HEAD approach.

**before** (phase 1-2):
```
git reset --hard $onto        # branch moved immediately
git cherry-pick $commits      # if crash mid-pick, branch is at wrong position
```

**after** (phase 3):
```
git checkout --detach $onto   # branch untouched
git cherry-pick $commits      # work in detached HEAD
git branch -f $branch HEAD    # only move branch on success
git checkout $branch
```

the win: original branch is never touched until every commit lands clean. `--abort` is just `git checkout $branch` — no reset needed.

state file changed from `original_head_sha` to `branch_name` (branch was never moved, so SHA not needed for recovery).

## phase 4: failfast guards

two guards added after review of edge cases:

**dirty work tree**:
- checked before apply starts
- `git status --porcelain` detects uncommitted changes
- rejects with: `⛈️  work tree is dirty — commit or stash before apply`
- why: `git checkout --detach` could fail or carry stale changes

**worktree conflict**:
- checked before `git branch -f` (both apply success and --continue)
- `git worktree list --porcelain` detects branch checked out elsewhere
- rejects with: `⛈️  branch '$branch' is checked out in worktree: $path`
- why: `git branch -f` fails if branch is checked out in another worktree

## phase 5: research docs

documented the access layer and claims:

- `3.1.research.access._.v1.md` — git commands used, state file lifecycle, range and ancestry semantics
- `3.1.research.claims._.v1.md` — 10 verified claims about git behavior relied upon

## files changed

```
src/
  [~] bash_aliases.sh        # git_alias_graft() function
  [~] install_env.sh         # git config alias.graft

.behavior/v2026_02_04.git-graft/
  [+] 0.wish.md
  [+] 1.vision.md
  [+] 2.1.criteria.blackbox.md
  [+] 3.1.research.access._.v1.md
  [+] 3.1.research.claims._.v1.md
  [+] 3.3.blueprint.v1.i1.md
  [+] 5.1.execution.phase0_to_phaseN.v1.md
```
