# git graft — vision

## the outcome world

### before

cascade PRs are painful. you have `feat/b` based on `feat/a`, and:

- `feat/a` gets rebased → commits have new SHAs, your branch has stale ones
- `feat/a` gets squash-merged → the original commits don't exist anymore
- you need to move `feat/b` onto `main` but `git rebase --onto` requires the old base

you end up:
- manual cherry-pick of commits one by one
- cryptic `git rebase --onto main feat/a` syntax to remember
- "which commit was the cut point again?"

### after

```bash
git graft --onto main --from B1
```

that's it. specify where you want commits to land (`--onto main`) and which commits to take (`--from B1`). no need to know the old base.

### the "aha" moment

> "wait, i just tell it which commits i want and where to put them? i don't need to figure out the old base that might not even exist anymore?"

## user experience

### usecase 1: cascade PR rebase

you're on `feat/b` which has commits B1, B2 on top of `feat/a`. `feat/a` just got merged to main (squashed). move your commits to main:

```bash
# preview what will happen
git graft --onto main --from B1

# looks good, do it
git graft --onto main --from B1 --mode apply
```

### usecase 2: cherry-pick a range

you want commits C3 through C7 from another branch onto your current branch:

```bash
git graft --onto HEAD --from C3 --till C7 --mode apply
```

### usecase 3: move just one commit

```bash
git graft --onto main --from abc123 --till abc123 --mode apply
```

### timeline

1. run with default `--mode plan` → see exactly which commits will be replayed
2. verify the list looks right
3. add `--mode apply` to execute
4. if conflicts: resolve and `git cherry-pick --continue`, or abort with instructions provided

## mental model

### how users would describe it

> "it's like cherry-pick but you just say 'from here to there, put it over there'"

### analogies

- **cut and paste**: select a range (from..till), paste onto new location (onto)
- **transplant**: take this branch of commits, graft it onto a different trunk

### terms

| user says | we call it |
|-----------|------------|
| "move these commits" | graft |
| "start from this one" | --from |
| "up to this one" | --till |
| "put them here" | --onto |
| "show me first" | --mode plan |
| "do it" | --mode apply |

## contract

```
git graft --onto <ref> --from <commit> [--till <commit>] [--mode plan|apply]
git graft --continue
git graft --abort
```

| arg | required | default | what it does |
|-----|----------|---------|--------------|
| --onto | yes | — | where to put the commits |
| --from | yes | — | first commit to include (inclusive) |
| --till | no | HEAD | last commit to include (inclusive) |
| --mode | no | plan | plan = preview, apply = execute |
| --continue | — | — | resume after conflict resolution |
| --abort | — | — | cancel graft and restore original HEAD |

**ancestry filter**: commits already reachable from `--onto` are excluded — no duplicates.

## evaluation

### pros

- **no old base needed**: works even when original base was rebased/squashed
- **explicit range**: you say exactly which commits, no surprises
- **safe by default**: plan mode shows what will happen before execution
- **clear mental model**: from X, till Y, onto Z

### cons

- **need to know first commit**: you must identify B1 (but you'd need to know this anyway)
- **destructive on apply**: rewrites branch history (but so does any rebase/cherry-pick)

### edgecases

| case | behavior |
|------|----------|
| `--from B1 --till B1` | just that one commit |
| `--from B1` (no --till) | B1 through HEAD |
| commits don't exist | error: "no commits found in range" |
| not on a branch | error: "not on a branch (detached HEAD?)" |
| cherry-pick conflict | save state to `.git/GRAFT_ORIG_HEAD`, show `--continue` / `--abort` instructions |
| commits already in onto | excluded via ancestry filter (no duplicates) |

### pit of success

- default to plan mode → can't accidentally apply without preview first
- show all commits before apply → no surprises about what will be replayed
- ancestry filter → commits already in onto are excluded, no duplicates
- state persistence → original HEAD saved, recovery via `--continue` or `--abort`
- inclusive --from → no need to remember `^` syntax
