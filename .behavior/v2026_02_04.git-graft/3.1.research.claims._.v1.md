# git graft — research: claims

## claim.1 = `${from}^` makes --from inclusive

**status**: verified

git range `A..B` excludes A. by use of `${from}^` (parent of from), the range becomes `parent-of-from..till`, which includes from itself.

**caveat**: fails if `--from` is the root commit (has no parent). acceptable — root commit grafts are not a target use case.

## claim.2 = `^${onto}` excludes commits already in target

**status**: verified

`git rev-list A..B ^C` excludes all commits reachable from C. this means commits shared between the source range and the onto target are dropped.

**example**:
```
main:    M1 - M2 - M3
feat/b:  M1 - M2 - A1 - B1 - B2

git rev-list --reverse B1^..HEAD ^main
→ B1, B2   (M1, M2 excluded via ^main)
```

## claim.3 = detached HEAD preserves the original branch

**status**: verified

`git checkout --detach $ref` moves HEAD to the ref without a move of any branch pointer. the branch that was checked out before detach remains at its original commit. `git branch -f $branch HEAD` can later move it.

## claim.4 = `.git/GRAFT_ORIG_HEAD` persists across checkout/detach

**status**: verified

files in `.git/` are plain filesystem files. they are not tied to branches, refs, or the index. they persist through any checkout, detach, reset, or branch switch.

git uses the same pattern for its own state: `MERGE_HEAD`, `CHERRY_PICK_HEAD`, `ORIG_HEAD`, `REBASE_HEAD`, etc.

## claim.5 = cherry-pick --continue works in detached HEAD

**status**: verified

`git cherry-pick` operates on HEAD, not on a branch. in detached HEAD, cherry-pick --continue resumes the sequence and advances HEAD. the result commits are reachable from HEAD, and `git branch -f` can then move a branch pointer to them.

## claim.6 = cherry-pick --abort restores to pre-pick state

**status**: verified

`git cherry-pick --abort` restores HEAD and the work tree to the state before the cherry-pick sequence started. in our case, that's the detached onto ref. the original branch is untouched (was never moved).

## claim.7 = `git branch -f` works from detached HEAD

**status**: verified

`git branch -f $branch $ref` force-moves a branch pointer regardless of what HEAD points to. it does not require that you are on (or not on) the branch. the only constraint: the branch must not be currently checked out elsewhere (e.g., in another worktree).

## claim.8 = cherry-pick creates new SHAs independent of original base

**status**: verified

cherry-pick replays the diff of each commit as a new commit. the new commit has a different parent (the current HEAD), so it gets a new SHA. there is no reference to the original base — works even when the original base was rebased, squashed, or deleted.

this is the core advantage over `git rebase --onto`, which requires the old base ref to exist.

## claim.9 = `--reverse` gives cherry-pick order

**status**: verified

`git rev-list` defaults to reverse chronological (newest first). `--reverse` flips to oldest first, which is the correct order for sequential cherry-pick — each commit's parent is the previous pick result.

## claim.10 = conflict leaves cherry-pick sequence in progress

**status**: verified

when cherry-pick hits a conflict, it pauses (non-zero exit) and leaves:
- `.git/CHERRY_PICK_HEAD` = the commit that conflicted
- conflict markers in the work tree
- both sides staged in the index

the sequence resumes with `--continue` after `git add` of resolved files, or cancels with `--abort`.
