# git graft — research: git access

## git commands used

### git rev-list

lists commit objects in reverse chronological order.

```bash
git rev-list --reverse "${from}^..${till}" "^${onto}"
```

| flag | purpose |
|------|---------|
| `--reverse` | oldest first (cherry-pick order) |
| `${from}^..${till}` | range from parent-of-from to till (makes --from inclusive) |
| `^${onto}` | exclude commits reachable from onto (ancestry filter) |

the ancestry filter (`^${onto}`) is key — it prevents duplicate commits when the range overlaps with the target base. without it, commits already in `main` would be cherry-picked again.

### git checkout --detach

```bash
git checkout --detach "$onto"
```

detaches HEAD to the onto ref without a move of any branch pointer. the original branch stays exactly where it was — safe to return to on abort.

state files in `.git/` (like `GRAFT_ORIG_HEAD`) persist across checkout/detach since they're plain files, not tied to refs.

### git cherry-pick

```bash
git cherry-pick $commits
```

replays each commit as a new commit on the current HEAD. creates new SHAs — no dependency on the original base.

exit codes:
- `0` = success, all commits applied
- non-zero = conflict encountered, paused mid-pick

on conflict, git leaves:
- `.git/CHERRY_PICK_HEAD` — the commit that conflicted
- conflict markers in work tree
- index with both sides staged

### git cherry-pick --continue

resumes after conflict resolution. expects:
- conflicts resolved in work tree
- resolved files staged via `git add`

### git cherry-pick --abort

cancels the cherry-pick sequence. restores the work tree to the state before cherry-pick started (the detached onto ref in our case).

### git branch -f

```bash
git branch -f "$branch" HEAD
```

force-moves a branch pointer to a given ref without checkout. used after cherry-pick completes in detached HEAD — moves the original branch to the new result.

safe because:
- we're in detached HEAD (not on the branch)
- the branch has not been touched since we detached

### git branch --show-current

```bash
git branch --show-current
```

returns the current branch name, or empty string if in detached HEAD. used to validate we're on a branch before graft, and to save the branch name for recovery.

## state file: .git/GRAFT_ORIG_HEAD

plain text file in `.git/`. stores the branch name (one line).

| event | action |
|-------|--------|
| apply starts | write branch name |
| apply succeeds | delete file |
| --continue succeeds | delete file |
| --abort | delete file |
| checkout to onto fails | delete file |

the file's presence means a graft is in progress. its absence means no graft active.

## range semantics

git range `A..B` means "commits reachable from B but not from A" — i.e., A is excluded.

to make `--from` inclusive, we use `${from}^` (parent of from):
- `${from}^..${till}` = from (inclusive) through till (inclusive)

edge case: if `--from` is the root commit (no parent), `${from}^` fails. this is acceptable — grafts from the very first commit in a repo are not a target use case.

## ancestry filter semantics

`^${onto}` in `git rev-list` excludes all commits reachable from onto.

```
main:    M1 - M2 - M3
feat/b:  M1 - M2 - A1 - B1 - B2
```

`git rev-list --reverse B1^..HEAD ^main` returns only `B1, B2` — excludes `M1, M2` even though they're in the range, because they're reachable from main.

this is exactly what we want for cascade PRs where feat/b shares history with main.
