# khlone: shell-native dispatcher

> ask or act, then return — interactive is optional

---

## the desire

khlone should be **shell-native** — a dispatcher first, interactive mode second.

today's ai repls demand your terminal. you launch claude-code, you're trapped in its world until you quit. your shell is gone.

khlone should work differently:

1. **ask or act, then return** — send a task, get your shell back
2. **know your zone** — always clear which zone you're in (local or remote)
3. **choose your clone** — `--who` targets a specific clone
4. **choose when** — `--when enqueue` (queue it) or `--when disrupt` (now)
5. **resume via envvar** — context preserved, just type more
6. **talk when needed** — drop into interactive mode on demand
7. **cross-zone dispatch** — `--zone org/repo@branch` to work with any zone
8. **await + pipe** — `--await` blocks and emits output to stdout

the shell is the dispatcher. interactive mode is just one way to observe.

---

## the model

```
┌─────────────────────────────────────────────────────────────────┐
│                     shell-native khlone                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ASK/ACT MODE (default)                                        │
│   ─────────────────────────────────────────────────────────────│
│   $ khlone act "implement auth"                                 │
│   ✓ enqueued to mechanic.1 (zone: ~/code/myproject)              │
│   $ _                          ◄── you're back in your shell   │
│                                                                 │
│   $ echo $KHLONE_SESSION                                        │
│   abc123                       ◄── session preserved in envvar │
│                                                                 │
│   $ khlone ask "what files did you change?"                     │
│   ✓ enqueued to mechanic.1 (zone: ~/code/myproject)              │
│   $ _                          ◄── resumes same session        │
│                                                                 │
│   TARGET SPECIFIC CLONE                                         │
│   ─────────────────────────────────────────────────────────────│
│   $ khlone act "review the auth" --who reviewer.1               │
│   ✓ enqueued to reviewer.1 (zone: ~/code/myproject)              │
│   $ _                                                           │
│                                                                 │
│   ENQUEUE VS DISRUPT                                            │
│   ─────────────────────────────────────────────────────────────│
│   $ khlone act "refactor db" --when enqueue                      │
│   ✓ enqueued to mechanic.1 (zone: ~/code/myproject)              │
│   $ _                          ◄── added to queue, shell free  │
│                                                                 │
│   $ khlone ask "status?" --when disrupt                          │
│   ✓ sent to mechanic.1 (zone: ~/code/myproject) [disrupt]      │
│   mechanic.1: refactor db (67%)                                 │
│   $ _                          ◄── interrupted, answered, done │
│                                                                 │
│   WATCH PROGRESS                                                │
│   ─────────────────────────────────────────────────────────────│
│   $ khlone status                                               │
│   zone: ~/code/myproject (local)                                │
│   mechanic.1: active (67%) — refactor db                        │
│                                                                 │
│   $ khlone watch                                                │
│   [~/code/myproject] mechanic.1: refactor db (67%)             │
│   ^C                           ◄── ctrl+c returns to shell     │
│   $ _                                                           │
│                                                                 │
│   ASK + WATCH (stream output)                                   │
│   ─────────────────────────────────────────────────────────────│
│   $ khlone ask "what files changed?" --watch                    │
│   ✓ enqueued to mechanic.1 (zone: ~/code/myproject)             │
│   [stream] mechanic.1: checking git diff...                    │
│   [stream] mechanic.1: 3 files changed: auth.ts, jwt.ts...     │
│   ^C                           ◄── ctrl+c returns to shell     │
│   $ _                                                           │
│                                                                 │
│   INTERACTIVE MODE (opt-in)                                     │
│   ─────────────────────────────────────────────────────────────│
│   $ khlone act "implement auth" --talk                          │
│   [talk — mechanic.1 @ ~/code/myproject]                       │
│   > implement the connection pool                               │
│   [clone works...]                                              │
│   > /exit                      ◄── back to shell               │
│   $ _                                                           │
│                                                                 │
│   CROSS-ZONE DISPATCH                                           │
│   ─────────────────────────────────────────────────────────────│
│   $ khlone act 'fix lint' --zone ehmpathy/rhachet@main          │
│   ✓ enqueued to mechanic.1 (zone: ehmpathy/rhachet@main)        │
│   $ _                          ◄── dispatched to different zone│
│                                                                 │
│   AWAIT + PIPE OUTPUT                                           │
│   ─────────────────────────────────────────────────────────────│
│   $ khlone ask 'summarize auth' --await >> summary.md           │
│   ✓ enqueued to mechanic.1 (zone: ~/code/myproject)             │
│   [await] mechanic.1: active...                                │
│   [await] mechanic.1: done                                     │
│   $ _                          ◄── output piped to file        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## key concepts

### 1. ask vs act

two verbs for two intents:

| verb | intent | examples |
|------|--------|----------|
| `ask` | query, question, request info | "what files changed?", "explain this code", "status?" |
| `act` | perform action, make changes | "implement auth", "fix the bug", "refactor db" |

```sh
# ask = request information
$ khlone ask "what files did you change?"
✓ enqueued to mechanic.1 (zone: ~/code/myproject)
$ _

# act = perform work
$ khlone act "implement jwt validation"
✓ enqueued to mechanic.1 (zone: ~/code/myproject)
$ _
```

both queue and return. both respect `--who` and `--when`.

### 2. zone awareness

zone is set at `khlone init` and persisted. every command shows which zone you're in:

```sh
# zone was set at init time (e.g., khlone init)
$ khlone act "implement auth"
✓ enqueued to mechanic.1 (zone: ~/code/myproject)
$ _

$ khlone status
zone: ~/code/myproject (local)                           # always visible
mechanic.1: active (67%) — implement auth
```

zone is created per worktree (worktree + machine + crew). auto-resolved from cwd.

### 3. clone target (--who)

specify which clone handles the task:

```sh
# default clone (clone.0, usually mechanic.1)
$ khlone act "implement auth"
✓ enqueued to mechanic.1 (zone: ~/code/myproject)

# specific clone
$ khlone act "review the auth" --who reviewer.1
✓ enqueued to reviewer.1 (zone: ~/code/myproject)

# ask a specific clone
$ khlone ask "what's your progress?" --who architect.1
✓ enqueued to architect.1 (zone: ~/code/myproject)

# spawn new clone inline (role++ syntax)
$ khlone ask "research this pattern" --who researcher++
✓ spawned researcher.1 (zone: ~/code/myproject)
✓ enqueued to researcher.1 (zone: ~/code/myproject)
```

`--who role++` spawns a new clone with the specified role alias. alias resolves to fully qualified name (e.g., `mechanic` → `ehmpathy/mechanic`). aliases must be defined in `khlone.worksite.yml` roles map.

### 4. enqueue vs disrupt (--when)

choose when the task is handled:

| when | behavior | use for |
|------|----------|----------|
| `enqueue` | add to queue, return to shell (default) | normal workflow |
| `disrupt` | interrupt current work, handle now | urgent questions, status checks |

```sh
# enqueue (default) — adds to queue
$ khlone act "big refactor" --when enqueue
✓ enqueued to mechanic.1 (zone: ~/code/myproject)
$ _                              # clone continues current work, then does this

# disrupt — interrupts current work
$ khlone ask "stop, what's the status?" --when disrupt
✓ sent to mechanic.1 (zone: ~/code/myproject) [disrupt]
mechanic.1: refactor db (67%), 3 files changed
$ _                              # clone paused, answered, resumed
```

`disrupt` is for when you need an answer now, not after the queue drains.

### 5. session envvar

when you ask or act, khlone sets `$KHLONE_SESSION`:

```sh
$ khlone act "implement auth"
✓ enqueued to mechanic.1 (zone: ~/code/myproject)
$ echo $KHLONE_SESSION
abc123

# later, same shell session
$ khlone ask "what files changed?"
✓ enqueued to mechanic.1 (zone: ~/code/myproject, session: abc123)

# or explicit resume
$ KHLONE_SESSION=abc123 khlone act "fix bugs"
```

the envvar enables:
- automatic session resume in same shell
- explicit session target from other shells
- session hand-off between terminals

### 6. interactive talk (opt-in)

```sh
# talk as a flag on ask/act
$ khlone act "implement auth" --talk
✓ enqueued to mechanic.1 (zone: ~/code/myproject)
[talk — mechanic.1 @ ~/code/myproject]

# now you're in the clone's session
> focus on jwt first
[clone works...]

> what files did you change?
[clone responds...]

> /exit
$ _                              # back to shell

# or standalone talk
$ khlone talk mechanic.1
[talk — mechanic.1 @ ~/code/myproject]
> show me the diff
[clone responds...]
> /exit
$ _
```

interactive mode is just one observation method. you opt into it, you opt out of it.

### 7. cross-zone dispatch (--zone)

work with any zone from any terminal — not just your cwd:

```sh
# full zone address
$ khlone act 'respond to pr feedback' --zone ehmpathy/myrepo@feature-auth
✓ enqueued to mechanic.1 (zone: ehmpathy/myrepo@feature-auth)
$ _

# same org — omit org
$ khlone ask 'what tests are flaky?' --zone rhachet@main
✓ enqueued to mechanic.1 (zone: ehmpathy/rhachet@main)

# same repo — just branch
$ khlone act 'fix the lint errors' --zone @hotfix-typo
✓ enqueued to mechanic.1 (zone: ehmpathy/myrepo@hotfix-typo)

# spin up a fresh zone on the fly (no prior init)
$ khlone ask 'how does genContextBrain work?' --zone ehmpathy/rhachet@main
✓ init: zone bound to ehmpathy/rhachet@main
✓ enqueued to mechanic.1 (zone: ehmpathy/rhachet@main)
```

zone address format: `org/repo@branch`
- full: `ehmpathy/rhachet@main`
- same org: `rhachet@main`
- same repo: `@feature-branch`

### 8. await + pipe output (--await)

block until completion, emit output to stdout — shell pipe just works:

```sh
# await completion, pipe output to file
$ khlone act 'describe how genContextBrain should be used' \
    --zone ehmpathy/rhachet@main \
    --await \
    >> .refs/howto.rhachet.genContextBrain.md
✓ init: zone bound to ehmpathy/rhachet@main
✓ enqueued to mechanic.1 (zone: ehmpathy/rhachet@main)
[await] mechanic.1: active...
[await] mechanic.1: done (tokens: 4,521)
# output artifact written to stdout, piped to file
$ _

# await with watch (see progress while you wait)
$ khlone ask 'summarize the auth implementation' --await --watch
✓ enqueued to mechanic.1 (zone: ~/code/myproject)
[stream] mechanic.1: read src/auth/index.ts
[stream] mechanic.1: read src/auth/jwt.ts
[await] mechanic.1: done
The auth implementation uses JWT tokens with...
$ _

# capture to variable
$ SUMMARY=$(khlone ask 'one-line summary of recent changes' --await)
$ echo $SUMMARY
Added jwt validation and fixed login redirect bug.
```

`--await`: blocks until task completes, emits output artifact to stdout. shell pipe just works.

---

## how it relates to the value chain

### ask vs act vs watch vs talk

| action | command | behavior |
|--------|---------|----------|
| **ask** | `khlone ask "question"` | queue question, return to shell |
| **act** | `khlone act "task"` | queue action, return to shell |
| **ask + disrupt** | `khlone ask "urgent?" --when disrupt` | interrupt, answer, return |
| **ask + watch** | `khlone ask "question" --watch` | queue, stream output (ctrl+c to stop) |
| **act + watch** | `khlone act "task" --watch` | queue, stream output (ctrl+c to stop) |
| **ask + talk** | `khlone ask "question" --talk` | queue, then interactive mode |
| **act + talk** | `khlone act "task" --talk` | queue, then interactive mode |
| **talk** | `khlone talk mechanic.1` | interactive mode with clone (standalone) |
| **ask + zone** | `khlone ask "..." --zone org/repo@branch` | dispatch to different zone |
| **ask + await** | `khlone ask "..." --await` | block, emit output to stdout |
| **ask + await + pipe** | `khlone ask "..." --await >> file.md` | block, pipe output to file |

all modes work together:

```sh
# act on default clone
$ khlone act "implement auth"
✓ enqueued to mechanic.1 (zone: ~/code/myproject)
$ _

# act on specific clone
$ khlone act "review auth" --who reviewer.1
✓ enqueued to reviewer.1 (zone: ~/code/myproject)
$ _

# check status
$ khlone crew
zone: ~/code/myproject (local)
role          status         queue
───────────────────────────────────
mechanic.1    active (45%)   2 tasks
reviewer.1    active (12%)   1 task

# ask with disrupt for immediate answer
$ khlone ask "mechanic, what file are you on?" --who mechanic.1 --when disrupt
✓ sent to mechanic.1 [disrupt]
currently on: src/auth/jwt.ts (line 47)
$ _

# talk to observe/interact
$ khlone talk mechanic.1
[talk — mechanic.1 @ ~/code/myproject]
> show me the auth implementation
[clone responds...]
> /exit
$ _

# watch all progress
$ khlone watch --all
[~/code/myproject] mechanic.1: implement auth (45%)
[~/code/myproject] reviewer.1: review auth (12%)
^C
$ _
```

### replbuffer integration

shell-native ask/act builds on replbuffer:

```
replbuffer layer:
├── instant input (0ms keystrokes — input goes to local buffer, not brain repl)
├── queue persistence (tasks survive shell exit)
├── headless execution (low resource — brain repl runs without ui overhead)
├── crash recovery (auto-restart)
└── transcript capture (review later)

shell-native layer:
├── ask and act (two verbs, one return)
├── zone awareness (always know where)
├── clone target (--who)
├── enqueue vs disrupt (--when)
├── cross-zone dispatch (--zone)
├── await + pipe (--await)
├── session envvar (resume context)
└── talk opt-in (interactive when needed)
```

replbuffer handles the "how" — shell-native handles the "ux".

**key benefit:** brain repls (claude-code, etc.) have crazy input lag — keystrokes buffer, ui freezes. replbuffer eliminates this: your input is instant (local buffer), brain repl is async (headless).

### zone integration

zone config lives in `khlone.worksite.yml` at repo root (per repo defaults). `khlone init` reads config and provisions a zone for the current worktree.

```yaml
# khlone.worksite.yml (per repo, at gitroot)
zone:
  mode: remote              # local | remote
  instance:                 # only if remote
    type: m6i.xlarge
  constraints:
    ttl: 4h                 # auto-halt after 4 hours
    cost_limit: 50          # alert at $50

crew:
  clone.0: mechanic         # default clone role
  defaults:
    brain: claude
  limits:
    max_clones: 4

roles:                      # role aliases available for --who role++
  mechanic: ehmpathy/mechanic   # alias -> fully qualified (repo/role)
  researcher: ehmpathy/researcher
  reviewer: ehmpathy/reviewer
```

```sh
# first ask/act triggers implicit init
$ khlone act "implement auth"
✓ init: zone bound to ~/code/myproject (worktree: feature-auth)
✓ enqueued to mechanic.1 (zone: ~/code/myproject)
$ _

# subsequent commands auto-resolve zone from cwd
$ khlone act "add tests"
✓ enqueued to mechanic.1 (zone: ~/code/myproject)
$ _
```

**implicit init**: first `ask/act` in a worktree triggers `khlone init` under the hood. binds the worktree via `.khlone/.bind.worksite/` (zone.yml, crew.yml, task.yml). subsequent terminals in the same worktree see the same state — no orphan clones, no lost tasks.

`khlone.worksite.yml` = per repo (shared defaults). zone = created per worktree (instance of config). multi-zone is definitional (multiple worktrees → multiple zones).

---

## refined value chain

```
v0.0: replbuffer + shell-native
  │   ├── task queue (persist, resume)
  │   ├── headless repls (low resource)
  │   ├── crash recovery (auto-restart)
  │   ├── ask and act (queue, return)
  │   ├── zone awareness (always visible)
  │   ├── clone target (--who)
  │   ├── enqueue vs disrupt (--when)
  │   ├── cross-zone dispatch (--zone)
  │   ├── await + pipe (--await)
  │   ├── session envvar (context preserve)
  │   └── talk opt-in (interactive mode)
  │
v0.1: zone bootstrap
  │   ├── khlone.worksite.yml (zone + crew config at gitroot)
  │   └── remote provision via declastruct-aws
  │
...
```

shell-native is part of v0.0 — it's the ux layer on top of replbuffer.

zone = worktree. multi-zone is definitional (multiple worktrees = multiple zones).

---

## command patterns

### init (provision zone per config)

```sh
khlone init                                   # read khlone.worksite.yml, provision zone
```

### ask (query and return)

```sh
khlone ask "QUESTION"                         # queue question, return to shell
khlone ask "QUESTION" --who CLONE             # ask specific clone (e.g., --who mechanic.1)
khlone ask "QUESTION" --who role++            # spawn new clone, ask it (e.g., --who researcher++)
khlone ask "QUESTION" --when disrupt          # interrupt for immediate answer
khlone ask "QUESTION" --watch                 # queue, then stream output (ctrl+c to stop)
khlone ask "QUESTION" --zone ADDR             # dispatch to zone by address (e.g., org/repo@branch)
khlone ask "QUESTION" --await                 # wait for completion, emit output to stdout
khlone ask "QUESTION" --await >> file.md      # await + pipe output to file
```

### act (work and return)

```sh
khlone act "TASK"                             # queue task, return to shell (implicit init on first)
khlone act "TASK" --who CLONE                 # assign to specific clone
khlone act "TASK" --who role++                # spawn new clone, assign to it
khlone act "TASK" --when enqueue              # explicit enqueue (default)
khlone act "TASK" --when disrupt              # interrupt current work
khlone act "TASK" --priority                  # queue at front
khlone act "TASK" --watch                     # queue, then stream output (ctrl+c to stop)
khlone act "TASK" --zone ADDR                 # dispatch to zone by address
khlone act "TASK" --await                     # wait for completion, emit output to stdout
```

`--watch` = enqueue + stream output. `--talk` = enqueue + interactive mode. `--await` = enqueue + block + emit output. all are "queue + observation" with different modes.

### observe (non-interactive)

```sh
khlone status                                 # snapshot of zone + clones
khlone status --who CLONE                     # snapshot of specific clone
khlone watch                                  # live progress, ctrl+c to exit
khlone watch --who CLONE                      # live progress for specific clone
khlone worksite                               # list all zones in the worksite (org/repo)
khlone log                                    # transcript review
```

### interact (opt-in)

```sh
khlone talk CLONE                             # standalone interactive mode
khlone act "task" --talk                      # queue + interactive mode
khlone ask "question" --talk                  # queue + interactive mode
> do this task                                # direct input to clone
> /status                                     # check status in-session
> /exit                                       # return to shell
```

### session management

```sh
echo $KHLONE_SESSION                          # current session id
khlone session                                # session info
khlone session list                           # all sessions
khlone session switch SESSION_ID              # switch session
khlone session end                            # end current session
```

---

## envvar design

| envvar | purpose |
|--------|---------|
| `KHLONE_SESSION` | current session id (auto-set on ask/act) |
| `KHLONE_WHO` | default clone for ask/act (optional) |
| `KHLONE_WHEN` | default: enqueue or disrupt (default: enqueue) |
| `KHLONE_ZONE` | default zone for ask/act (optional, overrides cwd resolution) |

note: zone is persisted at `khlone init` and auto-resolved from cwd. `--zone` flag overrides for cross-zone dispatch.

```sh
# session auto-resume
$ khlone act "task 1"
$ echo $KHLONE_SESSION
abc123
$ khlone act "task 2"                    # same session

# explicit session
$ KHLONE_SESSION=def456 khlone act "task 3"

# default clone
$ export KHLONE_WHO=architect.1
$ khlone act "design the api"            # goes to architect.1
```

---

## mental model

### the shell as dispatcher

your shell is the control plane. khlone commands are dispatches.

```
traditional repl:
  you ──► [trapped in repl tui] ──► work happens
                    │
                    └── shell gone until you quit

shell-native khlone:
  you ──► shell ──► ask/act ──► work happens (background)
              │
              └── shell stays yours
```

### analogy: job control

like `&` and `fg` and `bg` in unix:

```sh
# unix job control
$ long_task &                    # run in background
$ jobs                           # list jobs
$ fg %1                          # pull to foreground

# khlone
$ khlone act "long task"         # run in background
$ khlone status                  # list clones
$ khlone talk mechanic.1         # pull to foreground
```

but with:
- task queue (not just one job)
- crash recovery (jobs don't die)
- session context (resume later)
- clone routes (multiple workers)
- ask vs act (query vs work)
- enqueue vs disrupt (later vs now)
- cross-zone dispatch (work anywhere)
- await + pipe (shell-native output)

### worksite / zone hierarchy

```
worksite (org/repo)                    # the repo — shared config, role aliases
├── zone (@main)                       # worktree 1 — independent crew + tasks
│   └── crew (mechanic.1, reviewer.1)
├── zone (@feature-auth)               # worktree 2 — independent crew + tasks
│   └── crew (mechanic.1, researcher.1)
└── zone (@hotfix-typo)                # worktree 3 — independent crew + tasks
    └── crew (mechanic.1)
```

**worksite** = org/repo level
- `khlone.worksite.yml` lives at gitroot
- defines defaults: zone mode, crew config, role aliases
- shared across all zones (worktrees) of that repo

**zone** = worktree level
- each worktree is an independent zone
- has its own crew, tasks, state (`.khlone/.bind.worksite/`)
- isolated execution — mechanic.1 in `@feature-auth` ≠ mechanic.1 in `@main`

**crew** = clones in a zone
- each zone has its own crew of clones
- clones are role instances (mechanic.1, researcher.1, reviewer.1)
- `--who role++` spawns a new clone in the current zone

```sh
# see all zones in the worksite
$ khlone worksite
worksite: ehmpathy/myrepo
zones:
  @main           local    mechanic.1 (idle)
  @feature-auth   local    mechanic.1 (active 67%), researcher.1 (idle)
  @hotfix-typo    local    mechanic.1 (active 12%)
```

---

## open questions

1. **session scope**: per-shell? per-worktree?
   - per-worktree makes most sense (zone = worktree)

2. **envvar vs config**: which live in envvar vs ~/.khlone/config?
   - envvar: transient (session, clone target)
   - config: persistent (defaults)
   - zone: persisted at init, auto-resolved from cwd

3. **shell integration**: auto-set envvar on ask/act?
   - need shell hook or wrapper function
   - alternative: `eval $(khlone act ...)`

4. **detach behavior**: what happens to queue on /exit?
   - queue continues (enqueue is default)
   - explicit `khlone queue pause` to stop

5. **multi-terminal**: same session from multiple terminals?
   - yes, via `.khlone/.bind.worksite/` shared state
   - all terminals in same worktree see same zone, crew, tasks
   - watch/talk from one, ask/act from another

6. **disrupt semantics**: what exactly happens when you disrupt?
   - clone pauses current task at safe point
   - handles the disrupt request
   - resumes previous task
   - or: disrupt queue drains before resume?

---

## summary

shell-native khlone = ask/act first, interactive second.

- **ask or act** — queue task, get shell back
- **implicit init** — first ask/act triggers init, binds worktree
- **zone awareness** — always know where you're in
- **--who** — target specific clone (e.g., `--who mechanic.1`)
- **--who role++** — spawn new clone inline (e.g., `--who researcher++`)
- **--when** — enqueue (later) or disrupt (now)
- **--zone** — cross-zone dispatch (e.g., `--zone org/repo@branch`)
- **--await** — block until complete, emit output to stdout (shell pipe)
- **session envvar** — context preserved, resume automatic
- **talk opt-in** — interactive mode when you want it (`--talk` flag or standalone)
- **multi-terminal** — `.khlone/.bind.worksite/` shared state
- **worksite awareness** — `khlone worksite` lists all zones in the repo

this integrates with:
- **ask**: `ask "question"` → queue and return
- **act**: `act "task"` → queue and return
- **talk**: `--talk` or `talk clone.N` → interactive mode
- **target**: `--who clone.N` → specific clone
- **spawn**: `--who role++` → spawn new clone
- **when**: `--when enqueue|disrupt` → later or now
- **watch**: `--watch` → queue then stream output
- **zone**: `--zone org/repo@branch` → cross-zone dispatch
- **await**: `--await` → block + emit output (pipe to file, capture to var)

same ux for local (replbuffer) and remote (zones).
