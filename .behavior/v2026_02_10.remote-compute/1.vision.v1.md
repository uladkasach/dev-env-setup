# vision: remote-compute

## the outcome world

### before

- laptop fans spin constantly
- terminal input lags words behind
- claude code sessions compete with codium, browser, slack for cpu/ram
- context switch between projects = machine grinds
- "let me close some stuff" becomes a daily ritual
- travel means either haul beefy hardware or accept degraded performance

### after

- laptop becomes a thin client — cool, quiet, responsive
- terminal feels instant; keystrokes land immediately
- spin up as many claude code sessions as needed — they run elsewhere
- switch between projects = switch ssh sessions, no local resource contention
- coffee shop dev work feels identical to home office dev work
- beefy headless box at home handles the heavy lift over lan
- cloud instances available for overflow or travel scenarios

### the "aha" moment

you run 4 parallel claude code agents, a typescript build watcher, and postgres — and your laptop battery shows 6 hours left with fans silent. the work happens; your machine just displays it.

---

## user experience

### usecase 1: home office (local network)

**goal**: offload dev work to a dedicated home server

**timeline**:
1. power on headless machine (or it's always on)
2. from laptop: `ssh dev.local` or `ssh homelab`
3. you're in your full dev environment — same dotfiles, same tools, same muscle memory
4. run claude code, builds, tests — all on the remote machine
5. laptop displays output; remote machine does compute

**contract**:
```sh
# one-time setup
remote.init homelab --host 192.168.1.50 --sync-env

# daily use
remote.connect homelab
# now you're in. zsh, nvim, claude code, all of it.

# or run a one-off command remotely
remote.exec homelab "npm run test:integration"
```

### usecase 2: travel / cloud

**goal**: spin up ephemeral cloud compute when away from home network

**timeline**:
1. at airport, realize you need to work on a heavy task
2. `remote.cloud.up --instance-type t3.xlarge --ttl 4h`
3. wait ~60s for instance + environment sync
4. `remote.connect cloud`
5. work as normal
6. done → instance auto-terminates (or `remote.cloud.down`)

**contract**:
```sh
# spin up cloud instance with your dev env
remote.cloud.up --instance-type t3.xlarge --region us-east-1

# connect
remote.connect cloud

# check status
remote.cloud.status

# teardown (or let ttl expire)
remote.cloud.down
```

### usecase 3: hybrid / failover

**goal**: seamlessly switch between local and cloud based on availability

```sh
# connect to homelab if reachable, else spin up cloud
remote.connect --prefer homelab --fallback cloud
```

---

## mental model

### how you'd describe it to a friend

> "i have a beefy computer at home that does all the heavy lift. my laptop just shows what happens. feels like the laptop is powerful, but it's actually just a window into the real machine."

### analogies

- **x11 forward, but for the whole dev experience** — not just gui apps, your entire workflow
- **vs code remote ssh, but for terminal-first devs** — nvim, zsh, claude code all just work
- **your laptop is the head; remote machine is the body**

### terms

| user might say | we'd say |
|----------------|----------|
| "my home server" | `homelab` / `local remote` |
| "cloud box" | `cloud instance` / `ephemeral compute` |
| "connect" | `remote.connect` |
| "sync my setup" | `remote.init --sync-env` |

---

## evaluation

### how well does it solve the goals?

| goal | solved? |
|------|---------|
| laptop stops sluggish behavior | yes — compute offloaded |
| input latency eliminated | yes — local terminal, remote compute |
| run many claude code sessions | yes — remote has resources |
| works on local network | yes — primary usecase |
| works in cloud for travel | yes — secondary usecase |

### pros

- laptop becomes portable thin client
- home server can be beefy + cheap (no battery, no portability tax)
- cloud provides overflow capacity
- same dotfiles/tools everywhere — muscle memory preserved
- ssh is battle-tested; latency over lan is imperceptible (~1ms)

### cons / edgecases

| edgecase | mitigation |
|----------|------------|
| home network unreachable (travel) | fallback to cloud |
| cloud costs money | ttl auto-shutdown, spot instances |
| initial setup complexity | `remote.init` automates sync |
| latency to cloud (~50-100ms) | acceptable for terminal; wouldn't game on it |
| file sync between local/remote | git is source of truth; no live sync needed |
| security of ssh exposure | key-only auth, fail2ban, vpn option |

### pit of success

- `remote.init` handles all dotfile/tool sync — no manual rsync
- `--ttl` on cloud instances prevents forgotten run costs
- `--fallback` flag means you don't think about which machine
- environment parity guaranteed via sync from this repo (`dev-env-setup`)

---

## open questions

1. **persistence**: should cloud instances be ephemeral or persistent?
   - ephemeral = no state between sessions, cheaper
   - persistent = faster reconnect, state preserved
   - probably: ephemeral by default, persistent opt-in

2. **file access**: how do you edit files locally that you want to run remotely?
   - option a: edit remotely (nvim over ssh) — current assumption
   - option b: local edit + sync — adds complexity
   - option c: mount remote fs locally (sshfs) — latency concerns

3. **homelab setup**: dedicated machine or nas/server you already have?
   - vision assumes you have or will get a dedicated box
   - could also be a proxmox vm, raspberry pi cluster, etc
