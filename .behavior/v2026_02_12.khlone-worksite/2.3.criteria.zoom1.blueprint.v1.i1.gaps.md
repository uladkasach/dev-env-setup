# khlone v0.0: zoom1 blueprint gaps

> devil's advocate analysis of v1 blueprint

---

## severity legend

| severity | sense |
|----------|---------|
| ğŸ”´ **blocker** | cannot ship without resolution |
| ğŸŸ  **major** | significant risk or absent spec |
| ğŸŸ¡ **minor** | polish or edge case |

---

## gap.1: `--headless` flag does not exist ğŸ”´

**the assumption:**
```ts
const pty = spawn('claude', [
  '--headless',                    // no interactive prompts
  '--session', input.sessionId,    // resume session
  '--workdir', input.workdir,      // set cwd
], { ... });
```

**the reality:**
```sh
$ claude --help
# no --headless flag
# no --session flag
# no --workdir flag
```

**impact:** the entire spawn mechanism is based on flags that don't exist

**questions to resolve:**
1. how do we suppress interactive prompts without a headless flag?
2. how do we specify which session to resume?
3. can we set cwd via flag or must we spawn in that directory?

---

## gap.2: task completion detection ğŸ”´

**the assumption:**
```ts
interface BrainCliEmission {
  type: 'stdout' | 'stderr' | 'tool_use' | 'thought' | 'done';
  // ...
}
```

**the problem:** claude code does not emit structured "done" events

claude code output looks like:
```
â— Read file src/auth.ts
â— Write to src/jwt.ts
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ I've implemented the JWT validation. The changes include... â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
> _
```

**questions to resolve:**
1. how do we detect when claude has finished a task?
2. is the `> _` prompt the signal? what about multi-turn?
3. what if claude asks a clarification question mid-task?

---

## gap.3: session resume semantics ğŸŸ 

**the assumption:**
```sh
claude --session abc123  # resume specific session
```

**the reality:**
```sh
claude --resume          # resumes most recent conversation
claude --continue        # alias for --resume
```

**impact:** no way to specify which session to resume by ID

**questions to resolve:**
1. can we resume a specific session or only "most recent"?
2. where are sessions stored? `~/.claude/conversations/`?
3. can we manipulate the session state to force resume of specific one?

---

## gap.4: PTY output parse ğŸ”´

**the assumption:**
```ts
pty.onData((data) => emit(data));
```

**the problem:** raw PTY output contains:
- ANSI escape codes (colors, cursor movement)
- spinner animations (â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â )
- box-draw characters (â•­â•®â•°â•¯â”‚â”€)
- tool use blocks with special format
- markdown in responses

**example raw output:**
```
\x1b[36mâ— \x1b[0m\x1b[90mRead file \x1b[0msrc/auth.ts\x1b[0m\r\n
```

**questions to resolve:**
1. do we strip ANSI codes or preserve them for watch mode?
2. how do we parse tool_use vs thought vs final response?
3. do we need to detect spinner frames to know "still at work"?

---

## gap.5: `/exit` collision in talk mode ğŸŸ 

**the assumption:**
```
> /exit
# user detaches from talk mode, clone continues
```

**the problem:** `/exit` is claude code's quit command

```sh
> /exit
# claude code process terminates
```

**impact:** use of `/exit` to detach would kill the clone

**questions to resolve:**
1. what escape sequence should detach without kill?
2. use a khlone-specific sequence like `///detach`?
3. or intercept `/exit` in talk mode and rewrite it?

---

## gap.6: IPC protocol not specified ğŸŸ 

**the assumption:** unix socket for commands

**what lacks spec:**
- message format (JSON? newline-delimited? length-prefixed?)
- request/response correlation (request IDs?)
- stream protocol for watch mode
- error representation

**example unspecified scenario:**
```
client â†’ daemon: enqueue task
daemon â†’ client: ack with task ID
daemon â†’ client: (later) task started
daemon â†’ client: (later) task complete

# what's the wire format?
```

**questions to resolve:**
1. JSON-RPC? custom protocol?
2. how are streams multiplexed?
3. how does the client know which response matches which request?

---

## gap.7: progress percentage source ğŸŸ¡

**the assumption:**
```
zone @feature-auth
â”œâ”€ â— mechanic.1  67%  implement auth
```

**the problem:** claude code does not emit progress percentages

**questions to resolve:**
1. is progress estimated from output volume?
2. is it based on tool calls completed vs expected?
3. or is it just a spinner with no real percentage?

---

## gap.8: daemon lifecycle ğŸŸ 

**the assumption:** daemon starts on first dispatch

**what lacks spec:**
- when does daemon stop?
- what about orphan daemons after system restart?
- does daemon exit when all clones are idle?
- max idle timeout?

**questions to resolve:**
1. daemon runs forever until explicit stop?
2. or daemon exits after N minutes of inactivity?
3. how do we clean up daemons from crashed shells?

---

## gap.9: cross-zone daemon orchestration ğŸŸ 

**the scenario:**
```sh
# user in @main, dispatches to @feat/auth
$ khlone act "fix bug" --zone @feat/auth
```

**the question:** who spawns the @feat/auth daemon?

**option A:** current shell spawns daemon in @feat/auth worktree
**option B:** there's an orchestrator daemon that manages zone daemons
**option C:** daemon-per-zone but spawned remotely somehow

**impact:** cross-zone dispatch flow is unclear

---

## gap.10: onStop hooks not addressed ğŸŸ 

**the vision says:**
```yaml
hooks:
  onStop:
    - prompt: "1-line summary"
      artifact: summary
    - prompt: "fully done? yes/no/partial"
      artifact: complete
```

**the blueprint:** does not mention hooks at all

**questions to resolve:**
1. who runs onStop hooks? daemon? brain?
2. are hooks run via additional claude invocations?
3. where are artifacts stored?

---

## gap.11: token track not addressed ğŸŸ¡

**the vision says:**
```
â”œâ”€ âœ“ task-abc-123  "setup project"    mechanic.1   4,521 tok
```

**the problem:** how do we know token count?

**options:**
1. parse from claude code output (if it shows this)
2. estimate from prompt + response length
3. claude code exposes this somewhere?

---

## gap.12: skill invocation not detailed ğŸŸ 

**the interface:**
```ts
invoke(input: { skill: Record<string, unknown> }): Promise<void>;
```

**what lacks spec:**
- how does a skill map to claude input?
- is it a slash command? `/skill review.architecture`?
- does rhachet expand skill to full prompt?

---

## gap.13: signal and cleanup ğŸŸ¡

**scenarios not addressed:**
1. daemon receives SIGTERM â€” do clones get killed?
2. daemon receives SIGINT â€” graceful shutdown?
3. clone process dies â€” does daemon get notified?
4. system reboot â€” how is state recovered?

---

## gap.14: PTY window size in talk mode ğŸŸ¡

**the scenario:**
```sh
$ khlone talk
# user's terminal is 200x50
# clone's PTY was spawned at 120x40
```

**question:** does talk mode resize the PTY to match user's terminal?

**relevant:** TIOCSWINSZ ioctl, SIGWINCH signal

---

## gap.15: concurrent talk attempts ğŸŸ¡

**the scenario:**
```sh
# terminal 1
$ khlone talk mechanic.1  # attaches

# terminal 2
$ khlone talk mechanic.1  # what happens?
```

**options:**
1. second attach fails with "clone busy"
2. second attach succeeds, both see same output (tmux-like)
3. second attach queues until first detaches

---

## gap.16: stale daemon detection ğŸŸ 

**the scenario:**
```sh
# daemon crashes, PID file remains
~/.khlone/zones/abc123/daemon.pid  # contains 12345
# but process 12345 no longer exists
```

**question:** how do we detect and clean up stale daemons?

**options:**
1. check if PID is alive before connect
2. use pidfile lock (flock)
3. heartbeat file with timestamp

---

## gap.17: checkpoint not specified ğŸŸ 

**the vision says:** crash recovery via checkpoints

**what lacks spec:**
- what's in a checkpoint? (prompt? context? tool state?)
- when is checkpoint taken? (before each tool? after each response?)
- where stored?
- how is resume triggered?

---

## gap.18: multiple clones, rate limits ğŸŸ¡

**the scenario:**
```
zone @feat/auth
â”œâ”€ â— foreman.1     claude
â”œâ”€ â— mechanic.1    claude
â”œâ”€ â— researcher.1  claude
# 3 concurrent claude processes
```

**questions:**
1. do they share API key? hit rate limits together?
2. can khlone coordinate to avoid rate limit errors?
3. should there be a global concurrency limit?

---

## gap.19: watch vs talk data flow unclear ğŸŸ¡

**watch:** read-only stream of output
**talk:** bidirectional PTY attach

**the question:** are these different IPC channels or same channel, different mode?

```
watch: daemon â†’ client (one-way, filtered)
talk:  daemon â†” client (two-way, raw PTY)
```

**impact:** IPC protocol needs to handle both modes

---

## gap.20: no graceful task cancellation ğŸŸ¡

**the scenario:** user wants to cancel current task

**what the vision has:**
```sh
khlone act "urgent fix" --when disrupt
# pauses current task, runs this one
```

**what lacks spec:**
- can a task be cancelled entirely?
- what happens to in-progress work?
- does clone rollback or continue from interrupt point?

---

## summary: blockers

| gap | blocker? | resolution needed |
|-----|----------|-------------------|
| gap.1 | ğŸ”´ yes | research actual claude code CLI flags |
| gap.2 | ğŸ”´ yes | define task completion detection heuristics |
| gap.3 | ğŸŸ  major | research session resume mechanism |
| gap.4 | ğŸ”´ yes | design output parser |
| gap.5 | ğŸŸ  major | choose detach escape sequence |
| gap.6 | ğŸŸ  major | specify IPC protocol |
| gap.7 | ğŸŸ¡ minor | decide if progress is real or cosmetic |
| gap.8 | ğŸŸ  major | define daemon lifecycle |
| gap.9 | ğŸŸ  major | clarify cross-zone spawn |
| gap.10 | ğŸŸ  major | design hook execution |
| gap.11 | ğŸŸ¡ minor | research token exposure |
| gap.12 | ğŸŸ  major | specify skill â†’ input map |
| gap.13 | ğŸŸ¡ minor | define signal handlers |
| gap.14 | ğŸŸ¡ minor | implement PTY resize |
| gap.15 | ğŸŸ¡ minor | define concurrent talk behavior |
| gap.16 | ğŸŸ  major | implement stale daemon detection |
| gap.17 | ğŸŸ  major | specify checkpoint format |
| gap.18 | ğŸŸ¡ minor | consider rate limit coordination |
| gap.19 | ğŸŸ¡ minor | clarify watch vs talk data flow |
| gap.20 | ğŸŸ¡ minor | design task cancellation |

**3 blockers** must be resolved before v0.0 can ship.

