# khlone v0.0: implementation blueprint

> declastruct filediffs and codepaths for site orchestration

---

## package structure

khlone will be implemented as a standalone npm package with cli entrypoint.

```
packages/khlone/
├── package.json
├── tsconfig.json
├── src/
│   ├── contract/
│   ├── domain.objects/
│   ├── domain.operations/
│   └── access/
└── bin/
    └── khlone.ts
```

**dependencies:**
- `domain-objects` — entity/literal/event model
- `rhachet` — role and skill resolution
- `rhachet-artifact` — Artifact<GitFile> for task outputs
- `commander` — cli framework
- `yaml` — config parse
- `uuid-fns` — slug generation
- `helpful-errors` — error handle

---

## filediffs treestruct

**legend:**
- `[+]` create — file to create
- `[~]` update — file to update
- `[-]` delete — file to delete

```
packages/khlone/
├── [+] package.json
├── [+] tsconfig.json
├── [+] .declapract.use.yml
│
├── bin/
│   └── [+] khlone.ts                          # cli entrypoint
│
├── src/
│   ├── contract/
│   │   ├── cli/
│   │   │   ├── [+] index.ts                   # commander setup
│   │   │   ├── [+] act.ts                     # khlone act
│   │   │   ├── [+] ask.ts                     # khlone ask
│   │   │   ├── [+] watch.ts                   # khlone watch
│   │   │   ├── [+] talk.ts                    # khlone talk
│   │   │   ├── [+] status.ts                  # khlone status
│   │   │   ├── [+] list.ts                    # khlone list
│   │   │   ├── [+] init.ts                    # khlone init
│   │   │   └── [+] log.ts                     # khlone log
│   │   │
│   │   └── sdk/
│   │       └── [+] index.ts                   # programmatic api
│   │
│   ├── domain.objects/
│   │   ├── [+] Orchestrator.ts
│   │   ├── [+] Site.ts
│   │   ├── [+] SiteConfig.ts
│   │   ├── [+] Zone.ts
│   │   ├── [+] ZoneAddress.ts
│   │   ├── [+] Clone.ts
│   │   ├── [+] Task.ts
│   │   ├── [+] SkillInvocation.ts
│   │   ├── [+] CloneStreamEmission.ts
│   │   ├── [+] TaskQueuedEvent.ts
│   │   ├── [+] TaskStartedEvent.ts
│   │   ├── [+] TaskCompletedEvent.ts
│   │   ├── [+] TaskFailedEvent.ts
│   │   ├── [+] CloneEnrolledEvent.ts
│   │   ├── [+] paths.ts                       # ~/.khlone, .khlone paths
│   │   └── [+] defaults.ts                    # default values
│   │
│   ├── domain.operations/
│   │   ├── orchestrator/
│   │   │   ├── [+] getOrchestrator.ts
│   │   │   ├── [+] registerSite.ts
│   │   │   └── [+] unregisterSite.ts
│   │   │
│   │   ├── site/
│   │   │   ├── [+] getOneSite.ts
│   │   │   ├── [+] getAllSites.ts
│   │   │   ├── [+] upsertSite.ts
│   │   │   └── [+] parseSiteConfig.ts
│   │   │
│   │   ├── zone/
│   │   │   ├── [+] getOneZone.ts
│   │   │   ├── [+] getAllZones.ts
│   │   │   ├── [+] initZone.ts
│   │   │   ├── [+] ensureZone.ts
│   │   │   ├── [+] inferZone.ts
│   │   │   └── [+] parseZoneAddress.ts
│   │   │
│   │   ├── clone/
│   │   │   ├── [+] getOneClone.ts
│   │   │   ├── [+] getAllClones.ts
│   │   │   ├── [+] enrollClone.ts
│   │   │   ├── [+] deleteClone.ts
│   │   │   ├── [+] setCloneStatus.ts
│   │   │   ├── [+] inferClone.ts
│   │   │   └── [+] resolveRoleBrain.ts
│   │   │
│   │   ├── task/
│   │   │   ├── [+] getOneTask.ts
│   │   │   ├── [+] getAllTasks.ts
│   │   │   ├── [+] enqueueTask.ts
│   │   │   ├── [+] setTaskAsStarted.ts
│   │   │   ├── [+] setTaskAsCompleted.ts
│   │   │   ├── [+] setTaskAsFailed.ts
│   │   │   └── [+] generateTaskSlug.ts
│   │   │
│   │   ├── dispatch/
│   │   │   ├── [+] dispatch.ts                # high-level dispatch
│   │   │   └── [+] dispatchWithSkill.ts
│   │   │
│   │   ├── observe/
│   │   │   ├── [+] watchClone.ts
│   │   │   ├── [+] talkToClone.ts
│   │   │   ├── [+] awaitTask.ts
│   │   │   └── [+] getTranscript.ts
│   │   │
│   │   ├── status/
│   │   │   ├── [+] getStatus.ts
│   │   │   ├── [+] listResources.ts
│   │   │   └── [+] inferScope.ts
│   │   │
│   │   └── repl/
│   │       ├── [+] spawnHeadlessRepl.ts       # start headless brain
│   │       ├── [+] connectToRepl.ts           # attach to active repl
│   │       └── [+] streamReplOutput.ts
│   │
│   └── access/
│       └── daos/
│           ├── [+] daoOrchestrator.ts
│           ├── [+] daoSite.ts
│           ├── [+] daoZone.ts
│           ├── [+] daoClone.ts
│           ├── [+] daoTask.ts
│           ├── [+] daoTranscript.ts
│           └── [+] index.ts                   # exports
│
└── .test/
    ├── fixtures/
    │   ├── [+] khlone.yml                     # example config
    │   └── [+] exampleSite/                   # mock site structure
    │
    └── utils/
        └── [+] createTestContext.ts
```

---

## codepaths treestruct

**legend:**
- `[+]` create — codepath to create
- `[~]` update — codepath to update
- `[○]` retain — codepath to retain
- `[-]` delete — codepath to delete
- `[←]` reuse — codepath to reuse from elsewhere
- `[→]` eject — codepath to decompose for reuse

```
contract/
├── cli/
│   ├── [+] index.ts
│   │     ├── createProgram()                  # commander setup
│   │     └── registerCommands()               # attach all commands
│   │
│   ├── [+] act.ts
│   │     └── handleAct(args)
│   │           ├── parseFlags()               # --who, --zone, --skill, etc
│   │           ├── dispatch({ type: 'act', ... })
│   │           ├── formatOutput()             # "✓ task-xxx → clone"
│   │           └── optionally watchClone()    # if --watch
│   │
│   ├── [+] ask.ts
│   │     └── handleAsk(args)                  # mirrors act.ts
│   │
│   ├── [+] watch.ts
│   │     └── handleWatch(args)
│   │           ├── inferClone()
│   │           ├── watchClone()
│   │           └── streamToStdout()
│   │
│   ├── [+] talk.ts
│   │     └── handleTalk(args)
│   │           ├── inferClone()
│   │           ├── talkToClone()
│   │           └── interactiveLoop()
│   │
│   ├── [+] status.ts
│   │     └── handleStatus(args)
│   │           ├── inferScope()
│   │           ├── getStatus()
│   │           └── formatStatusTree()
│   │
│   ├── [+] list.ts
│   │     └── handleList(args)
│   │           ├── listResources()
│   │           └── formatResourceTable()
│   │
│   ├── [+] init.ts
│   │     └── handleInit(args)
│   │           ├── initZone()
│   │           └── formatInitConfirmation()
│   │
│   └── [+] log.ts
│         └── handleLog(args)
│               ├── inferClone()
│               ├── getTranscript()
│               └── formatTranscript()
│
└── sdk/
    └── [+] index.ts
          └── createKhlone(config)
                ├── .act(input)
                ├── .ask(input)
                ├── .watch(input)
                ├── .talk(input)
                ├── .status(input)
                └── .list(input)

domain.objects/
├── [+] Orchestrator.ts
│     └── class Orchestrator extends DomainEntity<Orchestrator>
│           ├── static primary = [] as const
│           ├── static unique = [] as const
│           └── interface { sites: Ref<typeof Site>[] }
│
├── [+] Site.ts
│     └── class Site extends DomainEntity<Site>
│           ├── static primary = ['uuid'] as const
│           ├── static unique = ['slug'] as const
│           └── interface { uuid?, slug, path, config, zones }
│
├── [+] SiteConfig.ts
│     └── class SiteConfig extends DomainLiteral<SiteConfig>
│           └── interface { zone: {...}, crew: {...} }
│
├── [+] Zone.ts
│     └── class Zone extends DomainEntity<Zone>
│           ├── static primary = ['uuid'] as const
│           ├── static unique = ['site', 'slug'] as const
│           └── interface { uuid?, slug, site, path, host, hero, clones, tasks }
│
├── [+] ZoneAddress.ts
│     └── class ZoneAddress extends DomainLiteral<ZoneAddress>
│           └── interface { org, repo, branch }
│
├── [+] Clone.ts
│     └── class Clone extends DomainEntity<Clone>
│           ├── static primary = ['uuid'] as const
│           ├── static unique = ['zone', 'slug'] as const
│           └── interface { uuid?, slug, zone, role, roleRef, brain, brainRef, status, task, pid }
│
├── [+] Task.ts
│     └── class Task extends DomainEntity<Task>
│           ├── static primary = ['uuid'] as const
│           ├── static unique = ['slug'] as const
│           └── interface { uuid?, slug, zone, clone, type, say, skill, status, artifact, timestamps }
│
├── [+] SkillInvocation.ts
│     └── class SkillInvocation extends DomainLiteral<SkillInvocation>
│           └── interface { choice, input }
│
├── [+] CloneStreamEmission.ts
│     └── class CloneStreamEmission extends DomainLiteral<CloneStreamEmission>
│           └── interface { clone, type, content, timestamp }
│
├── [+] TaskQueuedEvent.ts
│     └── class TaskQueuedEvent extends DomainEvent<TaskQueuedEvent>
│           ├── static unique = ['task', 'occurredAt'] as const
│           └── interface { task, clone, zone, occurredAt }
│
├── [+] TaskStartedEvent.ts
│     └── class TaskStartedEvent extends DomainEvent<TaskStartedEvent>
│
├── [+] TaskCompletedEvent.ts
│     └── class TaskCompletedEvent extends DomainEvent<TaskCompletedEvent>
│           └── interface { task, clone, artifact, occurredAt }
│
├── [+] TaskFailedEvent.ts
│     └── class TaskFailedEvent extends DomainEvent<TaskFailedEvent>
│           └── interface { task, clone, error, occurredAt }
│
└── [+] CloneEnrolledEvent.ts
      └── class CloneEnrolledEvent extends DomainEvent<CloneEnrolledEvent>
            └── interface { clone, zone, role, brain, occurredAt }

domain.operations/
├── dispatch/
│   ├── [+] dispatch.ts
│   │     └── dispatch(input, context)
│   │           ├── inferZone(address, cwd)
│   │           ├── inferClone(zone, who, skill)
│   │           ├── enqueueTask(zone, clone, type, say, skill)
│   │           └── return { task, clone, enrolled }
│   │
│   └── [+] dispatchWithSkill.ts
│         └── dispatchWithSkill(input, context)
│               ├── [←] rhachet.findRoleBySkill()
│               ├── inferClone() with skill route
│               └── enqueueTask() with skill invocation
│
├── zone/
│   ├── [+] inferZone.ts
│   │     └── inferZone(input, context)
│   │           ├── if address provided → parseZoneAddress() + ensureZone()
│   │           └── else → detect from cwd via git worktree
│   │
│   ├── [+] parseZoneAddress.ts
│   │     └── parseZoneAddress(input)
│   │           ├── "@branch" → { org: null, repo: null, branch }
│   │           ├── "repo@branch" → { org: null, repo, branch }
│   │           └── "org/repo@branch" → { org, repo, branch }
│   │
│   └── [+] ensureZone.ts
│         └── ensureZone(input, context)
│               ├── getOneZone()
│               ├── if found → return
│               └── else → initZone()
│
├── clone/
│   ├── [+] inferClone.ts
│   │     └── inferClone(input, context)
│   │           ├── if who is null → return zone.hero
│   │           ├── if who ends with "++" → enrollClone()
│   │           ├── if skill → findRoleBySkill() → enroll or get
│   │           └── else → getOneClone(who)
│   │
│   ├── [+] resolveRoleBrain.ts
│   │     └── resolveRoleBrain(input, context)
│   │           ├── lookup role alias in site.config.crew.roles
│   │           ├── lookup brain alias in site.config.crew.brains
│   │           ├── BadRequestError if not found
│   │           └── return { roleRef, brainRef }
│   │
│   └── [+] enrollClone.ts
│         └── enrollClone(input, context)
│               ├── resolveRoleBrain()
│               ├── generateSlug() → "{role}.{n}"
│               ├── spawnHeadlessRepl()
│               ├── daoClone.set.upsert()
│               └── emit CloneEnrolledEvent
│
├── task/
│   ├── [+] enqueueTask.ts
│   │     └── enqueueTask(input, context)
│   │           ├── generateTaskSlug()
│   │           ├── create Task with status='queued'
│   │           ├── add to clone.task.queue
│   │           ├── daoTask.set.upsert()
│   │           ├── daoClone.set.upsert()
│   │           └── emit TaskQueuedEvent
│   │
│   ├── [+] setTaskAsStarted.ts
│   │     └── setTaskAsStarted(input, context)
│   │           ├── move from queue to focus
│   │           ├── update task.status='active', task.startedAt
│   │           ├── update clone.status='active'
│   │           └── emit TaskStartedEvent
│   │
│   ├── [+] setTaskAsCompleted.ts
│   │     └── setTaskAsCompleted(input, context)
│   │           ├── update task.status='done', task.completedAt, task.artifact
│   │           ├── clear clone.task.focus
│   │           ├── if queue not empty → pick next
│   │           └── emit TaskCompletedEvent
│   │
│   └── [+] setTaskAsFailed.ts
│         └── setTaskAsFailed(input, context)
│               ├── update task.status='failed', task.completedAt
│               ├── clear clone.task.focus
│               └── emit TaskFailedEvent
│
├── observe/
│   ├── [+] watchClone.ts
│   │     └── watchClone(input, context)
│   │           ├── connectToRepl()
│   │           ├── streamReplOutput()
│   │           └── yield CloneStreamEmission
│   │
│   ├── [+] talkToClone.ts
│   │     └── talkToClone(input, context)
│   │           ├── pause clone queue
│   │           ├── connectToRepl()
│   │           └── return TalkSession { send(), receive(), exit() }
│   │
│   └── [+] awaitTask.ts
│         └── awaitTask(input, context)
│               ├── poll task status
│               ├── wait for status='done' | 'failed'
│               └── return artifact content or throw
│
├── status/
│   ├── [+] getStatus.ts
│   │     └── getStatus(input, context)
│   │           ├── inferScope()
│   │           ├── gather relevant entities
│   │           └── return StatusSnapshot
│   │
│   ├── [+] listResources.ts
│   │     └── listResources(input, context)
│   │           ├── switch on scope
│   │           ├── call getAllX() for scope
│   │           └── return ResourceList
│   │
│   └── [+] inferScope.ts
│         └── inferScope(input, context)
│               ├── if explicit scope → use it
│               ├── if cwd on feature branch → 'zone'
│               ├── if cwd on main → 'site'
│               └── else → 'orchestrator'
│
└── repl/
    ├── [+] spawnHeadlessRepl.ts
    │     └── spawnHeadlessRepl(input, context)
    │           ├── [←] rhachet.spawnBrain()
    │           ├── detach process
    │           └── return { pid }
    │
    ├── [+] connectToRepl.ts
    │     └── connectToRepl(input, context)
    │           ├── find process by pid
    │           └── attach stdin/stdout
    │
    └── [+] streamReplOutput.ts
          └── streamReplOutput(input, context)
                ├── parse repl output format
                └── yield CloneStreamEmission

access/daos/
├── [+] daoOrchestrator.ts
│     └── daoOrchestrator
│           ├── get.one() → read ~/.khlone/orchestrator.yml
│           └── set.upsert() → write yml
│
├── [+] daoSite.ts
│     └── daoSite
│           ├── get.one.bySlug() → read ~/.khlone/sites/{slug}/site.yml
│           ├── get.one.byPath() → resolve via gitroot
│           ├── get.all() → enumerate ~/.khlone/sites/*/
│           ├── set.upsert() → write yml
│           └── del.bySlug() → rm -rf dir
│
├── [+] daoZone.ts
│     └── daoZone
│           ├── get.one.byRef() → read {worktree}/.khlone/.bind/zone.yml
│           ├── get.one.byPath() → detect from path
│           ├── get.all.bySite() → enumerate worktrees
│           ├── set.upsert() → write yml
│           └── del.byRef() → rm zone state
│
├── [+] daoClone.ts
│     └── daoClone
│           ├── get.one.byRef() → read {worktree}/.khlone/clones/{slug}/state.yml
│           ├── get.all.byZone() → enumerate clones/*/
│           ├── set.upsert() → write yml
│           └── del.byRef() → rm clone dir
│
├── [+] daoTask.ts
│     └── daoTask
│           ├── get.one.bySlug() → read {worktree}/.khlone/.bind/tasks/{slug}.yml
│           ├── get.all.byZone() → enumerate tasks/*.yml
│           ├── get.all.byClone() → filter by clone ref
│           ├── set.upsert() → write yml
│           └── del.bySlug() → rm file
│
└── [+] daoTranscript.ts
      └── daoTranscript
            ├── get.all.byClone() → read {worktree}/.khlone/clones/{slug}/transcript.jsonl
            └── set.append() → append to jsonl
```

---

## test coverage plan

### unit tests

domain logic for all operations:

```
src/domain.operations/**/*.test.ts
├── dispatch/
│   ├── dispatch.test.ts
│   └── dispatchWithSkill.test.ts
│
├── zone/
│   ├── inferZone.test.ts
│   ├── parseZoneAddress.test.ts
│   └── ensureZone.test.ts
│
├── clone/
│   ├── inferClone.test.ts
│   ├── resolveRoleBrain.test.ts
│   └── enrollClone.test.ts
│
├── task/
│   ├── enqueueTask.test.ts
│   ├── setTaskAsStarted.test.ts
│   ├── setTaskAsCompleted.test.ts
│   └── setTaskAsFailed.test.ts
│
└── status/
    ├── getStatus.test.ts
    ├── listResources.test.ts
    └── inferScope.test.ts
```

**coverage focus:**
- zone address parse (all formats)
- clone inference (hero, explicit, enroll, skill-based)
- task lifecycle transitions
- scope resolution logic

### integration tests

dao + filesystem interactions:

```
src/access/daos/**/*.integration.test.ts
├── daoOrchestrator.integration.test.ts
├── daoSite.integration.test.ts
├── daoZone.integration.test.ts
├── daoClone.integration.test.ts
├── daoTask.integration.test.ts
└── daoTranscript.integration.test.ts
```

**coverage focus:**
- yaml read/write roundtrips
- file creation and cleanup
- path resolution across worktrees

### acceptance tests

blackbox behaviors via cli:

```
src/contract/cli/**/*.acceptance.test.ts
├── act.acceptance.test.ts
├── ask.acceptance.test.ts
├── status.acceptance.test.ts
├── list.acceptance.test.ts
├── watch.acceptance.test.ts
└── talk.acceptance.test.ts
```

**coverage matrix alignment:**

| matrix | acceptance test file |
|--------|---------------------|
| matrix.1 (dispatch) | act.acceptance.test.ts, ask.acceptance.test.ts |
| matrix.2 (observation) | watch.acceptance.test.ts, talk.acceptance.test.ts |
| matrix.3 (status scope) | status.acceptance.test.ts |
| matrix.4 (enumeration) | list.acceptance.test.ts |
| matrix.5 (clone target) | act.acceptance.test.ts |
| matrix.6 (skill dispatch) | ask.acceptance.test.ts |
| matrix.7 (brain selection) | act.acceptance.test.ts |
| matrix.8 (cross-scope) | act.acceptance.test.ts, status.acceptance.test.ts |
| matrix.11 (errors) | all acceptance tests |

---

## implementation phases

### phase 0: foundation

- [ ] package scaffold (package.json, tsconfig)
- [ ] domain objects (all entities, literals, events)
- [ ] dao implementations (filesystem based)
- [ ] unit tests for domain objects

### phase 1: core dispatch

- [ ] inferZone + parseZoneAddress
- [ ] inferClone + resolveRoleBrain + enrollClone
- [ ] enqueueTask + task lifecycle operations
- [ ] dispatch high-level operation
- [ ] cli: khlone act, khlone ask
- [ ] unit + integration tests

### phase 2: observation

- [ ] spawnHeadlessRepl + connectToRepl
- [ ] watchClone + streamReplOutput
- [ ] talkToClone
- [ ] awaitTask
- [ ] cli: khlone watch, khlone talk
- [ ] integration tests

### phase 3: status + list

- [ ] getStatus + inferScope
- [ ] listResources
- [ ] cli: khlone status, khlone list, khlone log
- [ ] acceptance tests

### phase 4: cross-scope dispatch

- [ ] ensureZone (auto-create)
- [ ] cross-zone dispatch via ZoneAddress
- [ ] cross-site dispatch via orchestrator
- [ ] acceptance tests for cross-scope

### phase 5: skill dispatch

- [ ] dispatchWithSkill
- [ ] skill route to capable role
- [ ] skill invocation passthrough
- [ ] acceptance tests

---

## contracts summary

### cli contract

```
khlone init
khlone act "<prompt>" [--who <clone>] [--zone <addr>] [--skill <name>] [--brain <alias>] [--watch] [--talk] [--await] [--prioritize]
khlone ask "<prompt>" [--who <clone>] [--zone <addr>] [--skill <name>] [--brain <alias>] [--watch] [--talk] [--await]
khlone watch [--who <clone>] [--zone <addr>]
khlone talk [--who <clone>] [--zone <addr>]
khlone status [<scope>] [--site <slug>] [--zone <addr>] [--who <clone>] [--task <slug>]
khlone list <scope> [--site <slug>] [--zone <addr>]
khlone log [--who <clone>]
```

### sdk contract

```ts
interface Khlone {
  act(input: DispatchInput): Promise<DispatchResult>;
  ask(input: DispatchInput): Promise<DispatchResult>;
  watch(input: WatchInput): AsyncIterable<CloneStreamEmission>;
  talk(input: TalkInput): Promise<TalkSession>;
  status(input: StatusInput): Promise<StatusSnapshot>;
  list(input: ListInput): Promise<ResourceList>;
}
```

### context contract

```ts
interface KhloneContext {
  daoOrchestrator: DaoOrchestrator;
  daoSite: DaoSite;
  daoZone: DaoZone;
  daoClone: DaoClone;
  daoTask: DaoTask;
  daoTranscript: DaoTranscript;
  log: LogMethods;
  rhachet: RhachetContext;  // for role/skill resolution
}
```

---

## state file formats

### orchestrator.yml

```yaml
sites:
  - slug: ehmpathy/myrepo
  - slug: ahbode/svc-jobs
```

### site.yml

```yaml
uuid: abc-123
slug: ehmpathy/myrepo
path: /home/user/repos/myrepo
config:
  zone:
    host: local
  crew:
    hero:
      role: foreman
      brain: claude
    roles:
      mechanic: ehmpathy/mechanic
      researcher: ehmpathy/researcher
    brains:
      claude: anthropic/claude/code/opus/v4.5
      grok: xai/grok/code-fast-1
zones:
  - slug: "@main"
  - slug: "@feat/auth"
```

### zone.yml

```yaml
uuid: def-456
slug: "@feat/auth"
site:
  slug: ehmpathy/myrepo
path: /home/user/repos/myrepo-feat-auth
host: local
hero:
  slug: foreman.1
clones:
  - slug: foreman.1
  - slug: mechanic.1
tasks:
  - slug: task-abc-123
```

### clone state.yml

```yaml
uuid: ghi-789
slug: mechanic.1
zone:
  slug: "@feat/auth"
role: mechanic
roleRef: ehmpathy/mechanic
brain: claude
brainRef: anthropic/claude/code/opus/v4.5
status: active
task:
  focus:
    choice:
      slug: task-abc-123
    progress: 45
  queue:
    - slug: task-def-456
pid: 12345
```

### task.yml

```yaml
uuid: jkl-012
slug: task-abc-123
zone:
  slug: "@feat/auth"
clone:
  slug: mechanic.1
type: act
say: "implement auth"
skill: null
status: active
artifact: null
createdAt: "2025-02-14T10:00:00Z"
startedAt: "2025-02-14T10:00:05Z"
completedAt: null
```

---

## dependencies on rhachet

khlone leverages rhachet for:

1. **role resolution** — `rhachet.getRole(roleSlug)` to fetch role definitions
2. **skill discovery** — `rhachet.getSkillsForRole(role)` to find capabilities
3. **brain spawn** — `rhachet.spawnBrain(brainRef, options)` to start headless repls
4. **artifact storage** — `Artifact<GitFile>` from rhachet-artifact for task outputs

these are accessed via `context.rhachet` in operations.

---

## summary

**khlone v0.0** implementation requires:

- **~50 source files** across contract, domain.objects, domain.operations, access
- **~30 test files** for unit, integration, acceptance coverage
- **5 phases** from foundation to skill dispatch
- **6 cli commands** (init, act, ask, watch, talk, status, list, log)
- **5 domain entities** (Orchestrator, Site, Zone, Clone, Task)
- **5 events** (TaskQueued/Started/Completed/Failed, CloneEnrolled)
- **6 daos** (orchestrator, site, zone, clone, task, transcript)

the architecture follows declastruct patterns with yaml-based persistence and headless repl execution via rhachet.
