# khlone v0.0: zoom1 blueprint v2 gaps

> devil's advocate analysis of v2 blueprint

---

## severity legend

| severity | sense |
|----------|---------|
| ðŸ”´ **blocker** | cannot ship without resolution |
| ðŸŸ  **major** | significant risk or absent spec |
| ðŸŸ¡ **minor** | polish or edge case |

---

## gap.1: BrainCli interface assumes subprocess model ðŸŸ 

**the assumption:**
```ts
interface BrainCli {
  run(input: {...}): Promise<BrainCliResult>;
  stream(input: {...}): AsyncIterable<BrainCliEvent>;
  spawn(input: {...}): Promise<BrainCliPty>;
}
```

**the problem:** this assumes all brains follow a subprocess model with JSON output.

**what about:**
- brains that are API-only (no CLI)? e.g., direct OpenAI API, Anthropic API
- brains that require SDK integration rather than CLI?
- brains with different output formats that don't map cleanly to BrainCliEvent?

**impact:** the interface may need expansion for non-CLI brains.

**questions to resolve:**
1. should BrainCli support both CLI and SDK modes?
2. how do we adapt brains with different event schemas?
3. is subprocess spawn always available?

---

## gap.2: session ID generation and collision ðŸŸ 

**the assumption:**
```ts
const first = await brainCli.run({
  prompt: 'implement auth',
  sessionId: generateUuid(), // explicit session ID
  workdir: zone.path,
});
```

**the problem:** we generate UUIDs for session IDs, but:
- claude code may have its own session ID format requirements
- opencode may have different session ID semantics
- what if the brain rejects our UUID format?

**the blueprint says:** "khlone tracks session IDs per clone" but doesn't specify:
- how to validate session ID format per brain
- what happens on session ID collision
- whether brains namespace sessions by project

**questions to resolve:**
1. do we let the brain generate session IDs and track what it returns?
2. or do we impose our own format?
3. how do we handle per-project session namespace?

---

## gap.3: stream event schema translation ðŸŸ 

**the assumption:**
```ts
interface BrainCliEvent {
  type: 'assistant' | 'tool_use' | 'tool_result' | 'result';
  content?: string;
  name?: string;
  input?: Record<string, unknown>;
}
```

**the reality:**

claude code stream-json emits:
```json
{"type":"assistant","content":"I'll start by..."}
{"type":"tool_use","name":"Read","input":{...}}
```

opencode stream emits:
```json
{"event":"message","content":"I'll start by..."}
{"event":"tool","name":"read_file","path":"..."}
```

**the problem:** event schemas differ. who translates?

**questions to resolve:**
1. does each rhachet-brains-* package translate to BrainCliEvent?
2. what happens when a brain emits an event type we don't recognize?
3. how do we handle brain-specific event types (e.g., claude's `permission_request`)?

---

## gap.4: PTY spawn failure modes ðŸŸ 

**the assumption:**
```ts
export const spawn = async (input: {...}): Promise<BrainCliPty> => {
  const pty = ptySpawn('claude', [...], {...});
  return { pid: pty.pid, ... };
};
```

**what's unspecified:**
- what if the CLI binary is not found? (`ENOENT`)
- what if the CLI requires authentication and it's not configured?
- what if the CLI version is incompatible?
- what if PTY allocation fails?

**impact:** talk mode fails with cryptic errors.

**questions to resolve:**
1. pre-flight check for CLI availability before spawn?
2. how do we surface authentication errors clearly?
3. version compatibility detection?

---

## gap.5: checkpoint restoration accuracy ðŸŸ 

**the assumption:**
```json
{
  "taskId": "task-abc-123",
  "sessionId": "uuid-here",
  "prompt": "implement auth",
  "toolCallIndex": 3,
  "partialResult": "I've created src/auth.ts with...",
  "timestamp": "2025-02-14T10:30:00Z"
}
```

**the problem:** checkpoints are taken before each tool call, but:
- what if the tool call partially completed? (file half-written)
- what if external state changed during crash? (branch moved, file edited)
- how do we handle non-idempotent tool calls?

**the resume prompt says:**
```
[RESUME] Previous session crashed. You were at tool call 3.
Continue from where you left off: implement auth
```

**but:** the brain may not have context of what tool calls 0-2 did. the session may have been lost.

**questions to resolve:**
1. do we replay the session transcript on resume?
2. how do we detect and warn about external state changes?
3. should checkpoints include tool call results, not just index?

---

## gap.6: JSON-RPC error handle ðŸŸ¡

**the assumption:** JSON-RPC 2.0 over unix socket.

**what's unspecified:**
- error codes beyond the example `-32001` for "clone busy"
- how to handle malformed JSON from client
- request timeout semantics
- connection drop mid-request

**impact:** inconsistent error experience.

**questions to resolve:**
1. define full error code table?
2. request timeout (30s? 60s? configurable?)
3. partial response on connection drop?

---

## gap.7: onStop hook failure ðŸŸ¡

**the assumption:**
```ts
const runOnStopHooks = async (task, result, brainCli) => {
  for (const hook of hooks) {
    const hookResult = await brainCli.run({
      prompt: hook.prompt,
      sessionId: result.sessionId,
      workdir: task.workdir,
    });
    await storeArtifact({...});
  }
};
```

**what's unspecified:**
- what if a hook fails? continue to next? abort?
- what if the brain session is no longer valid?
- timeout for hook execution?
- do hook failures affect task status?

**questions to resolve:**
1. hook failure mode: warn + continue?
2. hook timeout: 30s? 60s?
3. should hooks run in separate sessions to isolate failure?

---

## gap.8: rate limiter state persistence ðŸŸ¡

**the assumption:**
```ts
class RateLimiter {
  private semaphore: Map<string, number> = new Map();
  private queue: Map<string, Array<() => void>> = new Map();
  // ...
}
```

**the problem:** rate limiter state is in-memory. but:
- if daemon restarts, rate limits reset
- if multiple daemons run (cross-zone), they don't share limits
- API rate limits are per-key, not per-daemon

**impact:** rate limit violations when multiple daemons hit same API key.

**questions to resolve:**
1. shared rate limit state across daemons?
2. rate limit state persistence across daemon restart?
3. query actual rate limit status from API?

---

## gap.9: brain adapter discovery ðŸŸ¡

**the assumption:**
```ts
const BRAIN_ADAPTERS: Record<string, () => Promise<BrainCli>> = {
  'anthropic/claude/code/opus/v4.5': () => import('rhachet-brains-anthropic'),
  'anthropic/claude/code/sonnet/v4': () => import('rhachet-brains-anthropic'),
  'opencode/opencode/v1': () => import('rhachet-brains-opencode'),
};
```

**the problem:** brain adapters are hardcoded. but:
- how do we add new brains without modifying khlone core?
- how do we handle version updates?
- what if a brain package is not installed?

**impact:** tight coupling between khlone and brain packages.

**questions to resolve:**
1. plugin system for brain adapters?
2. dynamic discovery via rhachet?
3. graceful degradation when adapter not installed?

---

## gap.10: daemon spawn race condition ðŸŸ¡

**the assumption:**
```ts
const daemon = await ensureDaemon({ zone });
// ensureDaemon:
//   1. check pidfile + flock
//   2. if locked and alive â†’ connect
//   3. else â†’ fork daemon process
```

**the problem:** two concurrent `khlone act` calls may both see "no daemon" and both try to fork.

**the flock helps, but:**
- flock happens in the daemon after fork
- the check-then-fork is not atomic
- second daemon may start, fail to acquire lock, exit with confusing error

**questions to resolve:**
1. use flock before fork? (parent holds lock, passes to child)
2. retry loop with backoff on connect failure?
3. atomic daemon spawn via file lock?

---

## gap.11: watch mode cleanup ðŸŸ¡

**the assumption:** watch subscribes via IPC, unsubscribes on connection close.

**what's unspecified:**
- what if watch client crashes without clean disconnect?
- does the daemon accumulate stale subscriptions?
- memory leak from uncleaned event listeners?

**questions to resolve:**
1. heartbeat from watch clients?
2. automatic cleanup of stale subscriptions?
3. max watchers per clone?

---

## gap.12: skill prompt expansion ðŸŸ¡

**the assumption:**
```ts
const expandSkill = (skillSlug: string): string => {
  const skill = rhachet.getSkill(skillSlug);
  return skill.prompt;
};
```

**the problem:** skills can be more than prompts:
- executable skills (bash commands)
- parameterized skills (templates with placeholders)
- multi-step skills (sequences)

**questions to resolve:**
1. how do executable skills integrate with brainCli.run()?
2. how do we pass parameters to parameterized skills?
3. do multi-step skills create multiple tasks?

---

## gap.13: PTY buffer overflow ðŸŸ¡

**the assumption:** PTY data flows via `pty.onData()` callback.

**what's unspecified:**
- what if the brain outputs faster than the client can consume?
- PTY buffer limits?
- backpressure mechanism?

**impact:** data loss or memory exhaustion in extreme cases.

**questions to resolve:**
1. ring buffer for PTY output?
2. pause/resume flow control?
3. max buffer size before drop?

---

## gap.14: session cleanup ðŸŸ¡

**the assumption:** sessions stored in `~/.claude/sessions/` or similar.

**what's unspecified:**
- when are old sessions cleaned up?
- storage limits?
- how do we garbage collect sessions for deleted zones?

**impact:** disk space growth over time.

**questions to resolve:**
1. session retention policy? (30 days? 100 sessions?)
2. cleanup on zone deletion?
3. expose session management commands?

---

## gap.15: concurrent task limit ðŸŸ¡

**the assumption:** tasks queue to a clone, execute sequentially.

**what's unspecified:**
- max queue depth per clone?
- max concurrent clones per zone?
- what happens when limits are exceeded?

**impact:** unbounded resource usage.

**questions to resolve:**
1. default limits?
2. configurable via khlone.yml?
3. clear error when limit hit?

---

## gap.16: brain output sanitization ðŸŸ¡

**the assumption:** brain output is captured and stored as artifacts.

**what's unspecified:**
- what if output contains ANSI escape codes?
- what if output contains sensitive data?
- size limits on artifacts?

**questions to resolve:**
1. strip ANSI from artifacts?
2. redact sensitive patterns?
3. max artifact size?

---

## gap.17: cross-site daemon coordination ðŸŸ 

**the assumption:** orchestrator at `~/.khlone/` knows about all sites.

**what's unspecified:**
- how does the orchestrator discover sites?
- does each site have its own daemon?
- how do cross-site commands route to correct daemon?

**the blueprint shows:**
```
~/.khlone/
â”œâ”€â”€ orchestrator.yml
â”œâ”€â”€ sites/
â”‚   â”œâ”€â”€ ahbode--svc-jobs/
â”‚   â””â”€â”€ ehmpathy--myrepo/
```

**but doesn't specify:**
- are these symlinks to actual repos?
- does `khlone --site X` spawn that site's daemon?
- how do we handle sites on remote machines? (future)

**questions to resolve:**
1. site discovery mechanism
2. cross-site daemon spawn
3. remote site support (ssh tunneling?)

---

## gap.18: brain authentication state ðŸŸ 

**the assumption:** brain CLIs are pre-authenticated.

**what's unspecified:**
- how do we detect "not authenticated" state?
- how do we surface auth instructions to user?
- what if auth expires mid-session?

**examples:**
- `claude` requires `claude login` or API key
- `opencode` requires provider API keys

**impact:** cryptic errors on first use.

**questions to resolve:**
1. pre-flight auth check?
2. clear error message with auth instructions?
3. auth refresh mechanism?

---

## gap.19: task cancellation state ðŸŸ¡

**the assumption:**
```ts
// checkpoint + requeue with --cancelled flag
```

**what's unspecified:**
- what does `--cancelled` flag do?
- can a cancelled task be resumed?
- what artifacts are captured for cancelled tasks?
- is partial work preserved or rolled back?

**questions to resolve:**
1. cancelled task state machine
2. partial artifact capture
3. resume vs restart semantics

---

## gap.20: daemon socket permissions ðŸŸ¡

**the assumption:** unix socket at zone path.

**what's unspecified:**
- socket file permissions (0600? 0660?)
- what if socket path is too long? (108 char limit)
- cleanup of stale sockets?

**impact:** security or accessibility issues.

**questions to resolve:**
1. socket permissions default
2. hash-based short socket paths for long zone paths
3. socket cleanup on daemon exit

---

## summary: v2 gaps

| gap | severity | area |
|-----|----------|------|
| gap.1 | ðŸŸ  major | BrainCli assumes subprocess model |
| gap.2 | ðŸŸ  major | session ID generation and collision |
| gap.3 | ðŸŸ  major | stream event schema translation |
| gap.4 | ðŸŸ  major | PTY spawn failure modes |
| gap.5 | ðŸŸ  major | checkpoint restoration accuracy |
| gap.6 | ðŸŸ¡ minor | JSON-RPC error handle |
| gap.7 | ðŸŸ¡ minor | onStop hook failure |
| gap.8 | ðŸŸ¡ minor | rate limiter state persistence |
| gap.9 | ðŸŸ¡ minor | brain adapter discovery |
| gap.10 | ðŸŸ¡ minor | daemon spawn race condition |
| gap.11 | ðŸŸ¡ minor | watch mode cleanup |
| gap.12 | ðŸŸ¡ minor | skill prompt expansion |
| gap.13 | ðŸŸ¡ minor | PTY buffer overflow |
| gap.14 | ðŸŸ¡ minor | session cleanup |
| gap.15 | ðŸŸ¡ minor | concurrent task limit |
| gap.16 | ðŸŸ¡ minor | brain output sanitization |
| gap.17 | ðŸŸ  major | cross-site daemon coordination |
| gap.18 | ðŸŸ  major | brain authentication state |
| gap.19 | ðŸŸ¡ minor | task cancellation state |
| gap.20 | ðŸŸ¡ minor | daemon socket permissions |

**0 blockers**, **7 major gaps**, **13 minor gaps**.

v2 is significantly more complete than v1. the major gaps are refinements rather than fundamental architectural issues.

