# khlone v0.0: process management blueprint v2 (zoom1)

> how khlone spawns, supervises, and attaches to brain processes
> resolves gaps identified in v1 blueprint

---

## changes from v1

| gap | v1 assumption | v2 resolution |
|-----|---------------|---------------|
| gap.1 | `--headless` flag | use `-p`/`--print` with `--output-format json` |
| gap.2 | "done" event detection | parse JSON response structure from `-p` |
| gap.3 | `--session abc123` | use `--resume "name"` or `--session-id UUID` |
| gap.4 | raw PTY parse | use `--output-format stream-json` for structured output |
| gap.5 | `/exit` collision | use `///detach` escape sequence |
| gap.6 | IPC protocol unspecified | JSON-RPC 2.0 over unix socket |
| gap.7 | progress percentage | estimate from tool call count vs output volume |
| gap.8 | daemon lifecycle | idle timeout + heartbeat file |
| gap.9 | cross-zone spawn | orchestrator daemon spawns zone daemons |
| gap.10 | onStop hooks | daemon runs hooks via separate `-p` invocations |
| gap.11 | token track | extract from `--output-format json` response |
| gap.12 | skill invocation | expand skill to prompt, pass to `-p` |
| gap.13 | signal handle | SIGTERM → graceful checkpoint, SIGKILL → orphan recovery |
| gap.14 | PTY window resize | forward SIGWINCH to PTY via ioctl |
| gap.15 | concurrent talk | second attach fails with "clone busy" |
| gap.16 | stale daemon detection | pidfile lock (flock) + heartbeat timestamp |
| gap.17 | checkpoint format | JSON with prompt, tool state, partial response |
| gap.18 | rate limits | global concurrency semaphore per API key |
| gap.19 | watch vs talk | same socket, different message types |
| gap.20 | task cancellation | checkpoint + requeue with `--cancelled` flag |

---

## multi-brain support

khlone supports multiple brain backends via rhachet-brains-* packages:

| package | brain | interface |
|---------|-------|-----------|
| rhachet-brains-anthropic | claude code | `claude` CLI |
| rhachet-brains-opencode | opencode | `opencode` CLI |

each package implements the same `BrainCli` interface, with brain-specific adaptations.

---

## claude code CLI: actual interface

### the `-p` / `--print` pattern

claude code has no `--headless` flag. instead, use `-p` for non-interactive mode:

```sh
# non-interactive task with JSON output
claude -p "implement auth" --output-format json

# returns structured JSON:
{
  "result": "I've implemented authentication...",
  "session_id": "abc123-uuid-here",
  "usage": {
    "input_tokens": 1234,
    "output_tokens": 567
  },
  "cost": 0.0145,
  "duration_seconds": 2.34
}
```

### session management

```sh
# resume by session name
claude --resume "session-name" -p "continue task"

# resume by UUID
claude --session-id "abc123-uuid" -p "continue task"

# fork a session (branch off)
claude --fork-session "parent-session-id" -p "diverge here"
```

### output formats

| format | use case | structure |
|--------|----------|-----------|
| `json` | task completion | single JSON object |
| `stream-json` | watch mode | newline-delimited JSON events |
| `text` | human readable | plain text (default) |

```sh
# stream mode for watch
claude -p "task" --output-format stream-json --include-partial-messages
```

stream-json emits events like:
```json
{"type":"assistant","content":"I'll start by..."}
{"type":"tool_use","name":"Read","input":{"file_path":"src/auth.ts"}}
{"type":"tool_result","content":"file contents..."}
{"type":"assistant","content":"Now I'll create..."}
{"type":"result","session_id":"...","usage":{...},"cost":0.01}
```

### tool approval

```sh
# pre-approve specific tools
claude -p "task" --allowedTools "Bash,Read,Edit,Write"

# dangerous mode (approve all)
claude -p "task" --dangerously-skip-permissions
```

### session storage

sessions stored in:
- `~/.claude/sessions/` — standalone sessions
- `~/.claude/projects/{project-hash}/` — project-bound sessions

---

## opencode CLI: interface

opencode follows a similar pattern to claude code:

### non-interactive mode

```sh
# non-interactive task with JSON output
opencode run "implement auth" --output json

# returns structured JSON:
{
  "result": "I've implemented authentication...",
  "session": "abc123-uuid-here",
  "tokens": {
    "input": 1234,
    "output": 567
  },
  "cost_usd": 0.0145
}
```

### session management

```sh
# resume session by ID
opencode run --session "abc123-uuid" "continue task"

# new session in project
opencode run --project "/path/to/project" "task"
```

### stream mode

```sh
# real-time event stream
opencode run "task" --output stream

# emits newline-delimited JSON events
{"event":"start","session":"..."}
{"event":"message","content":"I'll start by..."}
{"event":"tool","name":"read_file","path":"src/auth.ts"}
{"event":"message","content":"Now I'll create..."}
{"event":"complete","tokens":{...},"cost_usd":0.01}
```

### interactive mode

```sh
# start interactive session (for talk mode)
opencode chat --session "abc123-uuid"
```

---

## architecture v2: two-mode operation

### mode 1: task mode (headless)

for `khlone act` and `khlone ask` — no PTY, just subprocess:

```
┌─────────────────────────────────────────────────────────────┐
│                     khlone daemon                           │
│                                                             │
│  task processor                                             │
│  ├── dequeue task                                           │
│  ├── resolve brain → BrainCli adapter                       │
│  ├── brainCli.run({ prompt, sessionId })                    │
│  ├── capture JSON result                                    │
│  └── store artifacts, mark complete                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**no PTY needed** — just `child_process.spawn` with stdout capture.

### mode 2: talk mode (interactive)

for `khlone talk` — full PTY attach:

```
┌─────────────────────────────────────────────────────────────┐
│                     khlone daemon                           │
│                                                             │
│  talk session                                               │
│  ├── resolve brain → BrainCli adapter                       │
│  ├── brainCli.spawn({ sessionId })                          │
│  │   └── in PTY (node-pty)                                  │
│  ├── attach user terminal ↔ PTY                             │
│  ├── on ///detach: unpipe, keep process                     │
│  └── on /exit: kill process, return to daemon               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**PTY required** — for interactive terminal emulation.

### mode 3: watch mode (stream)

for `khlone watch` — stream subprocess:

```
┌─────────────────────────────────────────────────────────────┐
│                     khlone daemon                           │
│                                                             │
│  watch stream                                               │
│  ├── resolve brain → BrainCli adapter                       │
│  ├── brainCli.stream({ prompt, sessionId })                 │
│  ├── parse newline-delimited JSON events                    │
│  ├── emit to watchers via IPC                               │
│  └── on ctrl+c: unsubscribe (process continues)             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**no PTY needed** — structured stream, not raw terminal.

---

## BrainCli interface (unified)

```ts
// rhachet-brains-*/src/types.ts

interface BrainCli {
  /** run a task in print mode, return result */
  run(input: {
    prompt: string;
    sessionId: string;
    workdir: string;
    allowedTools?: string[];
  }): Promise<BrainCliResult>;

  /** run a task with event stream output */
  stream(input: {
    prompt: string;
    sessionId: string;
    workdir: string;
  }): AsyncIterable<BrainCliEvent>;

  /** spawn interactive PTY session */
  spawn(input: {
    sessionId: string;
    workdir: string;
    cols?: number;
    rows?: number;
  }): Promise<BrainCliPty>;
}

interface BrainCliResult {
  result: string;
  sessionId: string;
  usage: { inputTokens: number; outputTokens: number };
  cost: number;
  durationSeconds: number;
}

interface BrainCliEvent {
  type: 'assistant' | 'tool_use' | 'tool_result' | 'result';
  content?: string;
  name?: string;
  input?: Record<string, unknown>;
}

interface BrainCliPty {
  pid: number;
  write(data: string): void;
  onData(callback: (data: string) => void): void;
  resize(cols: number, rows: number): void;
  kill(): void;
}
```

---

## brain-specific implementations

### rhachet-brains-anthropic

```ts
// rhachet-brains-anthropic/src/run.ts

export const run = async (input: {
  prompt: string;
  sessionId: string;
  workdir: string;
  allowedTools?: string[];
}): Promise<BrainCliResult> => {
  const args = [
    '-p', input.prompt,
    '--output-format', 'json',
    '--session-id', input.sessionId,
  ];

  if (input.allowedTools) {
    args.push('--allowedTools', input.allowedTools.join(','));
  }

  const proc = spawn('claude', args, {
    cwd: input.workdir,
    env: process.env,
  });

  const stdout = await collectStdout(proc);
  const exitCode = await waitForExit(proc);

  if (exitCode !== 0) {
    throw new Error(`claude exited ${exitCode}`);
  }

  const response = JSON.parse(stdout);
  return {
    result: response.result,
    sessionId: response.session_id,
    usage: {
      inputTokens: response.usage.input_tokens,
      outputTokens: response.usage.output_tokens,
    },
    cost: response.cost,
    durationSeconds: response.duration_seconds,
  };
};
```

### rhachet-brains-opencode

```ts
// rhachet-brains-opencode/src/run.ts

export const run = async (input: {
  prompt: string;
  sessionId: string;
  workdir: string;
  allowedTools?: string[];
}): Promise<BrainCliResult> => {
  const args = [
    'run', input.prompt,
    '--output', 'json',
    '--session', input.sessionId,
    '--project', input.workdir,
  ];

  const proc = spawn('opencode', args, {
    cwd: input.workdir,
    env: process.env,
  });

  const stdout = await collectStdout(proc);
  const exitCode = await waitForExit(proc);

  if (exitCode !== 0) {
    throw new Error(`opencode exited ${exitCode}`);
  }

  const response = JSON.parse(stdout);
  return {
    result: response.result,
    sessionId: response.session,
    usage: {
      inputTokens: response.tokens.input,
      outputTokens: response.tokens.output,
    },
    cost: response.cost_usd,
    durationSeconds: response.duration ?? 0,
  };
};
```

### spawn implementations

```ts
// rhachet-brains-anthropic/src/spawn.ts
import { spawn as ptySpawn } from 'node-pty';

export const spawn = async (input: {
  sessionId: string;
  workdir: string;
  cols?: number;
  rows?: number;
}): Promise<BrainCliPty> => {
  const pty = ptySpawn('claude', [
    '--resume', input.sessionId,
  ], {
    name: 'xterm-256color',
    cols: input.cols ?? 120,
    rows: input.rows ?? 40,
    cwd: input.workdir,
    env: process.env,
  });

  return {
    pid: pty.pid,
    write: (data) => pty.write(data),
    onData: (cb) => pty.onData(cb),
    resize: (cols, rows) => pty.resize(cols, rows),
    kill: () => pty.kill(),
  };
};
```

```ts
// rhachet-brains-opencode/src/spawn.ts
import { spawn as ptySpawn } from 'node-pty';

export const spawn = async (input: {
  sessionId: string;
  workdir: string;
  cols?: number;
  rows?: number;
}): Promise<BrainCliPty> => {
  const pty = ptySpawn('opencode', [
    'chat',
    '--session', input.sessionId,
  ], {
    name: 'xterm-256color',
    cols: input.cols ?? 120,
    rows: input.rows ?? 40,
    cwd: input.workdir,
    env: process.env,
  });

  return {
    pid: pty.pid,
    write: (data) => pty.write(data),
    onData: (cb) => pty.onData(cb),
    resize: (cols, rows) => pty.resize(cols, rows),
    kill: () => pty.kill(),
  };
};
```

---

## brain resolution

khlone resolves brain alias to BrainCli adapter:

```ts
// khlone/src/domain.operations/clone/resolveRoleBrain.ts

const BRAIN_ADAPTERS: Record<string, () => Promise<BrainCli>> = {
  'anthropic/claude/code/opus/v4.5': () => import('rhachet-brains-anthropic'),
  'anthropic/claude/code/sonnet/v4': () => import('rhachet-brains-anthropic'),
  'opencode/opencode/v1': () => import('rhachet-brains-opencode'),
  // future: grok, codex, gemini
};

export const resolveBrain = async (brainRef: string): Promise<BrainCli> => {
  const loader = BRAIN_ADAPTERS[brainRef];
  if (!loader) {
    throw new BadRequestError(`unknown brain: ${brainRef}`);
  }
  const adapter = await loader();
  return adapter.genBrainCli();
};
```

---

## IPC protocol: JSON-RPC 2.0

### wire format

newline-delimited JSON over unix socket:

```
client → daemon: {"jsonrpc":"2.0","method":"enqueue","params":{...},"id":1}\n
daemon → client: {"jsonrpc":"2.0","result":{...},"id":1}\n
```

### methods

| method | params | result |
|--------|--------|--------|
| `enqueue` | `{ type, prompt, clone?, skill?, priority? }` | `{ taskId, clone, position }` |
| `status` | `{ scope, slug? }` | `{ ... }` scope-dependent |
| `watch` | `{ clone }` | stream of events |
| `attach` | `{ clone }` | `{ ptyFd }` or error |
| `detach` | `{ clone }` | `{ ok: true }` |
| `await` | `{ taskId }` | `{ result, usage, cost }` |
| `cancel` | `{ taskId }` | `{ ok: true }` |

### event stream (watch)

for `watch`, daemon sends unsolicited notifications:

```
daemon → client: {"jsonrpc":"2.0","method":"emission","params":{"type":"tool_use",...}}\n
daemon → client: {"jsonrpc":"2.0","method":"emission","params":{"type":"assistant",...}}\n
```

client unsubscribes by close of connection or `cancel` call.

---

## task completion detection

### the solution

use JSON output format — completion is **implicit** when subprocess exits:

```ts
const runTask = async (task: Task, brainCli: BrainCli): Promise<TaskResult> => {
  try {
    const response = await brainCli.run({
      prompt: task.prompt,
      sessionId: task.sessionId,
      workdir: task.workdir,
    });

    return {
      status: 'done',
      result: response.result,
      sessionId: response.sessionId,
      usage: response.usage,
      cost: response.cost,
      duration: response.durationSeconds,
    };
  } catch (error) {
    return {
      status: 'failed',
      error: error.message,
    };
  }
};
```

**no pattern detection needed** — JSON parse + exit code is definitive.

---

## session resume semantics

### the solution

both claude code and opencode support session resume:

```ts
// first task creates session
const first = await brainCli.run({
  prompt: 'implement auth',
  sessionId: generateUuid(), // explicit session ID
  workdir: zone.path,
});
// first.sessionId = the UUID we provided

// second task resumes
const second = await brainCli.run({
  prompt: 'add tests',
  sessionId: first.sessionId, // same UUID
  workdir: zone.path,
});
// continues in same conversation context
```

### session storage

khlone tracks session IDs per clone:

```yaml
# {worktree}/.khlone/.bind/clones/mechanic.1/state.yml
slug: mechanic.1
role: ehmpathy/mechanic
brain: anthropic/claude/code/opus/v4.5
sessionId: abc123-uuid-here  # <-- tracked
status: idle
```

---

## `/exit` collision resolution

### the problem

`/exit` kills the brain process — can't use it for talk mode detach.

### the solution

use `///detach` as khlone-specific escape sequence:

```
user in talk mode:
> help me understand this code
[brain responds]
> ///detach
[khlone intercepts, unpipes, returns to shell]
[brain process continues in background]
```

implementation:

```ts
// in talk mode, intercept ///detach before it reaches brain
pty.onData((data) => {
  if (data.trim() === '///detach') {
    // don't forward to brain
    detachSession();
    return;
  }
  // forward to brain
  pty.write(data);
});
```

---

## daemon lifecycle

### startup

daemon spawns on first dispatch to zone:

```ts
// khlone act "task"
const daemon = await ensureDaemon({ zone });
// ensureDaemon:
//   1. check pidfile + flock
//   2. if locked and alive → connect
//   3. else → fork daemon process
```

### heartbeat

daemon writes heartbeat every 30s:

```
~/.khlone/zones/{zone-id}/daemon.heartbeat
# contains: timestamp (ISO 8601)
```

### idle timeout

daemon exits after 30 minutes idle (no active tasks, no connections):

```ts
// daemon main loop
let lastActivity = Date.now();

const checkIdle = () => {
  const idle = Date.now() - lastActivity;
  if (idle > 30 * 60 * 1000 && noActiveClones() && noConnections()) {
    gracefulShutdown();
  }
};

setInterval(checkIdle, 60_000);
```

### stale detection

on connect, check pidfile lock + heartbeat:

```ts
const isDaemonAlive = async (zone: Zone): Promise<boolean> => {
  const pidfile = `${zone.path}/.khlone/daemon.pid`;
  const heartbeat = `${zone.path}/.khlone/daemon.heartbeat`;

  // check flock
  const locked = await checkFlock(pidfile);
  if (!locked) return false;

  // check heartbeat freshness (< 60s old)
  const ts = await readFile(heartbeat, 'utf-8');
  const age = Date.now() - new Date(ts).getTime();
  return age < 60_000;
};
```

---

## crash recovery

### checkpoint format

before each tool call, checkpoint:

```json
{
  "taskId": "task-abc-123",
  "sessionId": "uuid-here",
  "prompt": "implement auth",
  "toolCallIndex": 3,
  "partialResult": "I've created src/auth.ts with...",
  "timestamp": "2025-02-14T10:30:00Z"
}
```

### on crash

```ts
cloneProcess.on('exit', async (code, signal) => {
  if (signal === 'SIGKILL' || code !== 0) {
    // unexpected exit
    const checkpoint = await loadCheckpoint(clone);

    if (checkpoint) {
      // respawn with resume
      await respawnClone(clone);
      // requeue task from checkpoint
      await requeueTask({
        ...checkpoint,
        resumeFrom: checkpoint.toolCallIndex,
      });
    }
  }
});
```

### resume prompt

on resume, prepend context:

```ts
const resumePrompt = `
[RESUME] Previous session crashed. You were at tool call ${checkpoint.toolCallIndex}.
Your partial progress: ${checkpoint.partialResult}

Continue from where you left off: ${checkpoint.prompt}
`;
```

---

## onStop hooks

### execution

daemon runs hooks via separate run() invocations:

```ts
const runOnStopHooks = async (
  task: Task,
  result: TaskResult,
  brainCli: BrainCli,
) => {
  const hooks = siteConfig.crew.hooks.onStop ?? [];

  for (const hook of hooks) {
    const hookResult = await brainCli.run({
      prompt: hook.prompt,
      sessionId: result.sessionId, // same session for context
      workdir: task.workdir,
    });

    // store artifact
    await storeArtifact({
      taskId: task.id,
      name: hook.artifact,
      value: hookResult.result,
    });
  }
};
```

### example hooks

```yaml
hooks:
  onStop:
    - prompt: "summarize what you just did in one line"
      artifact: summary
    - prompt: "is this task fully complete? answer: yes, no, or partial"
      artifact: complete
```

---

## skill invocation

### resolution

```ts
const resolveSkill = (skillSlug: string, siteConfig: SiteConfig): {
  role: string;
  prompt: string;
} => {
  // check hero first
  const heroRole = siteConfig.crew.hero.role;
  const heroSkills = getSkillsForRole(heroRole);
  if (heroSkills.includes(skillSlug)) {
    return { role: heroRole, prompt: expandSkill(skillSlug) };
  }

  // check other roles
  const matches = Object.entries(siteConfig.crew.roles)
    .filter(([_, roleRef]) => getSkillsForRole(roleRef).includes(skillSlug));

  if (matches.length === 0) {
    throw new BadRequestError(`no role knows skill: ${skillSlug}`);
  }
  if (matches.length > 1) {
    throw new BadRequestError(`ambiguous skill: ${skillSlug}`, {
      roles: matches.map(([alias]) => alias),
    });
  }

  return { role: matches[0][0], prompt: expandSkill(skillSlug) };
};
```

### skill expansion

skills from rhachet have a prompt template:

```ts
const expandSkill = (skillSlug: string): string => {
  const skill = rhachet.getSkill(skillSlug);
  // skill.prompt might be a template or executable
  return skill.prompt;
};
```

---

## rate limit coordination

### global semaphore

per API key, limit concurrent requests:

```ts
// ~/.khlone/orchestrator.yml
rateLimits:
  anthropic:
    maxConcurrent: 5
    requestsPerMinute: 60
  opencode:
    maxConcurrent: 3
    requestsPerMinute: 30
```

implementation:

```ts
class RateLimiter {
  private semaphore: Map<string, number> = new Map();
  private queue: Map<string, Array<() => void>> = new Map();

  async acquire(apiKey: string): Promise<void> {
    const current = this.semaphore.get(apiKey) ?? 0;
    const max = this.getMaxConcurrent(apiKey);

    if (current < max) {
      this.semaphore.set(apiKey, current + 1);
      return;
    }

    // wait in queue
    return new Promise((resolve) => {
      const queue = this.queue.get(apiKey) ?? [];
      queue.push(resolve);
      this.queue.set(apiKey, queue);
    });
  }

  release(apiKey: string): void {
    const current = this.semaphore.get(apiKey) ?? 1;
    this.semaphore.set(apiKey, current - 1);

    // wake next in queue
    const queue = this.queue.get(apiKey) ?? [];
    const next = queue.shift();
    if (next) next();
  }
}
```

---

## concurrent talk handle

### the rule

one talker per clone. second attach fails:

```ts
const handleAttach = (clone: Clone, client: IpcClient): Result => {
  if (clone.attachedClient) {
    return {
      error: {
        code: -32001,
        message: 'clone busy',
        data: { attachedSince: clone.attachedAt },
      },
    };
  }

  clone.attachedClient = client;
  clone.attachedAt = new Date().toISOString();
  return { ptyFd: clone.pty.fd };
};
```

### alternative: view-only attach

could allow read-only attach (like tmux with multiple clients):

```ts
// future: --view flag for read-only
// multiple viewers, one controller
```

not in v0.0 scope.

---

## PTY window resize

### forward SIGWINCH

when user resizes terminal in talk mode:

```ts
process.on('SIGWINCH', () => {
  const { rows, cols } = process.stdout;
  pty.resize(cols, rows);
});
```

### initial size

capture on attach:

```ts
const handleAttach = (clone: Clone, client: IpcClient): Result => {
  const { rows, cols } = client.terminalSize;
  clone.pty.resize(cols, rows);
  // ...
};
```

---

## revised walkthrough: `khlone act "implement auth"`

```
user shell                    khlone                           daemon                         brain
    │                            │                                │                                │
    │  khlone act "impl auth"    │                                │                                │
    │ ──────────────────────────►│                                │                                │
    │                            │                                │                                │
    │                            │  dispatch()                    │                                │
    │                            │  ├── ensureDaemon()            │                                │
    │                            │  │   └── fork if not active ──────────────────────────────────►│
    │                            │  │                             │  daemon starts                 │
    │                            │  │                             │                                │
    │                            │  ├── connect IPC               │                                │
    │                            │  ├── JSON-RPC: enqueue ───────────►│                            │
    │                            │  │                             │  queue.push(task)              │
    │                            │  │◄────────────────────────────────│ {taskId, position}         │
    │                            │  │                             │                                │
    │                            │  └── return                    │                                │
    │                            │                                │                                │
    │  ✓ task-001 → foreman.1    │                                │                                │
    │ ◄──────────────────────────│                                │                                │
    │                            │                                │                                │
    │  $ _ (shell free)          │                                │  [async: task processor]       │
    │                            │                                │  ├── dequeue task-001          │
    │                            │                                │  ├── resolveBrain()            │
    │                            │                                │  ├── brainCli.run() ───────────────────────────►│
    │                            │                                │  │                             │  [runs task]  │
    │                            │                                │  │                             │               │
    │                            │                                │  │                             │  [completes]  │
    │                            │                                │  │◄──────────────────────────────│ JSON result  │
    │                            │                                │  │                             │               │
    │                            │                                │  ├── parse JSON                │               │
    │                            │                                │  ├── store artifacts           │               │
    │                            │                                │  ├── run onStop hooks          │               │
    │                            │                                │  └── mark task done            │               │
```

**key difference from v1**: no persistent PTY for tasks. just subprocess with JSON output.

---

## revised walkthrough: `khlone watch`

```
user shell                    khlone                           daemon                         brain
    │                            │                                │                                │
    │  khlone watch              │                                │  [task in progress]            │ [active]
    │ ──────────────────────────►│                                │                                │
    │                            │                                │                                │
    │                            │  connect IPC                   │                                │
    │                            │  JSON-RPC: watch ─────────────────►│                            │
    │                            │                                │  subscribe to stream           │
    │                            │                                │                                │
    │  lets watch...             │                                │                                │
    │ ◄──────────────────────────│                                │                                │
    │                            │                                │                                │
    │         ┬                  │◄───────────────────────────────────│ emission: tool_use         │
    │ foreman │ read auth.ts     │  [JSON-RPC notification]       │                                │
    │         │                  │                                │                                │
    │         │ create jwt.ts    │◄───────────────────────────────────│ emission: assistant        │
    │         │                  │                                │                                │
    │  ^C     │                  │                                │                                │
    │ ────────┴──────────────────│                                │                                │
    │                            │  close IPC connection          │                                │
    │                            │                                │  unsubscribe                   │
    │                            │                                │  [task continues]              │ [active]
    │  $ _                       │                                │                                │
```

**key insight**: watch receives stream events via IPC, not raw PTY output.

---

## revised walkthrough: `khlone talk`

```
user shell                    khlone                           daemon                         brain
    │                            │                                │                                │
    │  khlone talk               │                                │                                │
    │ ──────────────────────────►│                                │                                │
    │                            │                                │                                │
    │                            │  connect IPC                   │                                │
    │                            │  JSON-RPC: attach ────────────────►│                            │
    │                            │                                │  resolveBrain()                │
    │                            │                                │  brainCli.spawn() ─────────────────────────────►│
    │                            │                                │                                │  [interactive]│
    │                            │                                │  pause task queue              │               │
    │                            │◄───────────────────────────────────│ { ptyFd }                  │               │
    │                            │                                │                                │               │
    │                            │  attach terminal to PTY        │                                │               │
    │                            │                                │                                │               │
    │  ╭────────────────────╮    │                                │                                │               │
    │  │ ● foreman.1        │    │                                │                                │               │
    │  │ [attached]         │    │                                │                                │               │
    │  ╰────────────────────╯    │                                │                                │               │
    │                            │                                │                                │               │
    │  > what's the status?      │                                │                                │               │
    │ ─────────────────────────────────────────────────────────────────────────────────────────────────────────────►│
    │                            │                                │                                │               │
    │  I've created auth.ts...   │                                │                                │               │
    │ ◄────────────────────────────────────────────────────────────────────────────────────────────────────────────│
    │                            │                                │                                │               │
    │  > ///detach               │                                │                                │               │
    │ ──────────────────────────►│                                │                                │               │
    │                            │  intercept ///detach           │                                │               │
    │                            │  detach terminal               │                                │               │
    │                            │  JSON-RPC: detach ────────────────►│                            │               │
    │                            │                                │  resume task queue             │               │
    │                            │                                │  [PTY continues]               │  [continues]  │
    │                            │                                │                                │               │
    │  $ _                       │                                │                                │               │
```

**key difference from v1**: PTY only for talk mode, not for all clone operations.

---

## file structure (revised)

```
packages/khlone/
├── src/
│   ├── daemon/
│   │   ├── daemonMain.ts           # daemon entry point
│   │   ├── taskProcessor.ts        # dequeue, brainCli.run(), capture JSON
│   │   ├── watchStream.ts          # brainCli.stream(), emit events
│   │   ├── talkSession.ts          # brainCli.spawn() for interactive
│   │   ├── ipcServer.ts            # JSON-RPC over unix socket
│   │   ├── heartbeat.ts            # write timestamp every 30s
│   │   ├── idleShutdown.ts         # exit after 30min idle
│   │   └── crashRecovery.ts        # checkpoint + respawn
│   │
│   └── domain.operations/
│       ├── clone/
│       │   └── resolveBrain.ts     # brain alias → BrainCli adapter
│       │
│       ├── dispatch/
│       │   └── dispatch.ts         # enqueue via JSON-RPC
│       │
│       └── observe/
│           ├── watchClone.ts       # subscribe to stream events
│           ├── talkToClone.ts      # attach PTY
│           └── awaitTask.ts        # block until JSON result

packages/rhachet-brains-anthropic/
├── src/
│   ├── index.ts                    # exports genBrainCli
│   ├── run.ts                      # claude -p with JSON output
│   ├── stream.ts                   # claude -p with stream-json
│   ├── spawn.ts                    # claude --resume in PTY
│   └── types.ts                    # BrainCli, BrainCliResult, etc

packages/rhachet-brains-opencode/
├── src/
│   ├── index.ts                    # exports genBrainCli
│   ├── run.ts                      # opencode run with JSON output
│   ├── stream.ts                   # opencode run with stream
│   ├── spawn.ts                    # opencode chat in PTY
│   └── types.ts                    # reuses shared types
```

---

## khlone.yml (revised with multi-brain)

```yaml
# khlone.yml (at gitroot)
zone:
  host: local

crew:
  hero:
    role: foreman
    brain: claude

  roles:
    mechanic: ehmpathy/mechanic
    researcher: ehmpathy/researcher
    reviewer: ehmpathy/reviewer
    foreman: ehmpathy/foreman

  brains:
    claude: anthropic/claude/code/opus/v4.5
    sonnet: anthropic/claude/code/sonnet/v4
    opencode: opencode/opencode/v1

  hooks:
    onStop:
      - prompt: "1-line summary"
        artifact: summary
      - prompt: "fully done? yes/no/partial"
        artifact: complete
```

### usage examples

```sh
# default brain (claude)
$ khlone act "implement auth"

# explicit brain override
$ khlone act "implement auth" --brain opencode

# different clone with different brain
$ khlone act "research patterns" --who researcher++ --brain sonnet
```

---

## test coverage (revised)

### unit tests

```
src/daemon/
├── taskProcessor.test.ts
│   ├── resolves brain from clone config
│   ├── calls brainCli.run with correct args
│   ├── parses JSON result
│   ├── handles non-zero exit code
│   └── runs onStop hooks
│
├── watchStream.test.ts
│   ├── calls brainCli.stream
│   ├── parses newline-delimited JSON
│   └── emits events to subscribers
│
└── talkSession.test.ts
    ├── calls brainCli.spawn
    ├── intercepts ///detach
    └── forwards resize
```

### integration tests

```
src/
├── daemon/ipcServer.integration.test.ts
│   ├── enqueue via JSON-RPC
│   ├── watch receives stream events
│   └── attach/detach PTY
│
├── rhachet-brains-anthropic/
│   ├── run.integration.test.ts
│   │   └── actually runs claude -p and parses output
│   └── stream.integration.test.ts
│       └── actually runs claude --stream-json
│
└── rhachet-brains-opencode/
    ├── run.integration.test.ts
    │   └── actually runs opencode run and parses output
    └── stream.integration.test.ts
        └── actually runs opencode run --stream
```

### acceptance tests

```
src/contract/cli/
├── act.acceptance.test.ts
│   ├── khlone act queues task, daemon runs brainCli.run
│   └── khlone act --brain opencode uses opencode adapter
│
├── watch.acceptance.test.ts
│   └── khlone watch streams events via IPC
│
├── talk.acceptance.test.ts
│   └── khlone talk attaches PTY, ///detach works
│
└── await.acceptance.test.ts
    └── khlone ask --await blocks, returns JSON result
```

---

## summary: v1 → v2 changes

| aspect | v1 | v2 |
|--------|----|----|
| brain support | claude only | multi-brain via BrainCli interface |
| task execution | PTY + output parse | subprocess + JSON parse |
| watch mode | PTY stdout stream | stream-json subprocess |
| talk mode | PTY attach | PTY attach (unchanged) |
| completion detect | pattern match | subprocess exit + JSON |
| session resume | assumed `--session` | `--session-id` or `--resume` |
| IPC protocol | unspecified | JSON-RPC 2.0 |
| detach escape | `/exit` (collision) | `///detach` |
| daemon lifecycle | unspecified | heartbeat + idle timeout |
| crash recovery | checkpoint unclear | JSON checkpoint + resume prompt |
| token track | unknown | from JSON `usage` field |
| onStop hooks | unspecified | separate brainCli.run() invocations |
| skill invoke | unspecified | expand to prompt, pass to run() |

**key insights**:
1. most operations don't need PTY — only talk mode does
2. use JSON output format for structured, deterministic task completion
3. unified BrainCli interface enables multi-brain support
4. this resolves all 3 blocker gaps and 9 major gaps from v1
