# khlone v0.0: process management blueprint (zoom1)

> how khlone spawns, supervises, and attaches to brain processes

---

## the gap

the dispatch blueprint shows:

```ts
await actor.ask({ say: 'implement auth' });
```

but **claude code is a CLI binary**, not an SDK:

```sh
$ claude
╭─────────────────────────────────────────╮
│ ● Claude Code                           │
│ /help for commands, /exit to quit       │
╰─────────────────────────────────────────╯
> _
```

**the questions:**
1. how do we start this headless?
2. how do we keep it alive?
3. how do we send commands?
4. how do we receive output?
5. how do we attach/detach (talk/watch)?

---

## the reality: brains are CLIs

| brain | interface | process model |
|-------|-----------|---------------|
| claude code | CLI binary (`claude`) | interactive REPL |
| codex cli | CLI binary (`codex`) | interactive REPL |
| aider | CLI binary (`aider`) | interactive REPL |
| cursor | GUI app | not applicable |

**none of these are Node.js SDKs.** they're interactive terminal applications.

---

## architecture: BrainCli interface

rhachet-brains-* packages need a **BrainCli** interface:

```ts
// rhachet-brains-anthropic/src/genBrainCli.ts

interface BrainCli {
  /** spawn the CLI process headless */
  spawn(input: {
    sessionId: string;
    workdir: string;
  }): Promise<BrainCliProcess>;
}

interface BrainCliProcess {
  /** process id */
  pid: number;

  /** send a message to the CLI */
  send(input: { say: string }): Promise<void>;

  /** invoke a skill */
  invoke(input: { skill: Record<string, unknown> }): Promise<void>;

  /** stream output (for watch) */
  output(): AsyncIterable<BrainCliEmission>;

  /** attach stdin/stdout (for talk) */
  attach(): Promise<{ stdin: Writable; stdout: Readable }>;

  /** detach without kill */
  detach(): Promise<void>;

  /** wait for current task to complete */
  await(): Promise<BrainCliResult>;

  /** check if process is alive */
  isAlive(): boolean;

  /** kill the process */
  kill(): Promise<void>;
}

interface BrainCliEmission {
  type: 'stdout' | 'stderr' | 'tool_use' | 'thought' | 'done';
  content: string;
  timestamp: string;
}
```

---

## process management: the mechanics

### spawn headless

```ts
// rhachet-brains-anthropic/src/spawn.ts

export const spawnClaudeCli = async (input: {
  sessionId: string;
  workdir: string;
}): Promise<BrainCliProcess> => {
  // create PTY (pseudo-terminal) for interactive CLI
  const pty = spawn('claude', [
    '--headless',                    // no interactive prompts
    '--session', input.sessionId,    // resume session
    '--workdir', input.workdir,      // set cwd
  ], {
    name: 'xterm-256color',
    cols: 120,
    rows: 40,
    cwd: input.workdir,
    env: process.env,
  });

  // create IPC socket for commands
  const socketPath = `/tmp/khlone-${input.sessionId}.sock`;
  const server = createUnixSocketServer(socketPath);

  return {
    pid: pty.pid,
    pty,
    socket: server,
    // ... methods
  };
};
```

**key insight:** we use a **PTY** (pseudo-terminal) because:
- terminal escape codes work
- interactive feel preserved
- enables attach/detach (like tmux)

### the IPC layer

```
┌─────────────────────────────────────────────────────────────┐
│                     khlone process                          │
│                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │ khlone act  │    │ khlone ask  │    │ khlone talk │     │
│  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘     │
│         │                  │                  │             │
│         └────────┬─────────┴─────────┬────────┘             │
│                  │                   │                      │
│                  ▼                   ▼                      │
│         ┌────────────────┐   ┌────────────────┐            │
│         │  unix socket   │   │   PTY attach   │            │
│         │  (commands)    │   │   (talk mode)  │            │
│         └───────┬────────┘   └───────┬────────┘            │
└─────────────────┼────────────────────┼──────────────────────┘
                  │                    │
                  ▼                    ▼
┌─────────────────────────────────────────────────────────────┐
│                   clone process (claude)                    │
│                                                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │                      PTY                              │  │
│  │  ┌────────────┐  ┌────────────┐  ┌────────────────┐  │  │
│  │  │   stdin    │  │   stdout   │  │ socket server  │  │  │
│  │  │ (commands) │  │  (output)  │  │ (IPC endpoint) │  │  │
│  │  └────────────┘  └────────────┘  └────────────────┘  │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**two channels:**
1. **unix socket** — for task send (act/ask) from any khlone invocation
2. **PTY** — for attach/detach (talk mode) with full terminal

---

## khlone daemon: clone supervisor

khlone needs a **supervisor daemon** that:
1. keeps clone processes alive
2. restarts on crash
3. processes task queues
4. manages IPC connections

```
┌─────────────────────────────────────────────────────────────┐
│                    khlone daemon                            │
│                    (per zone)                               │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                 clone supervisor                     │   │
│  │                                                      │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │   │
│  │  │foreman.1 │  │mechanic.1│  │research.1│          │   │
│  │  │ pid:1234 │  │ pid:5678 │  │ pid:9012 │          │   │
│  │  │ ● active │  │ ○ idle   │  │ ● active │          │   │
│  │  └──────────┘  └──────────┘  └──────────┘          │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                 task processor                       │   │
│  │                                                      │   │
│  │  for each clone:                                     │   │
│  │    if clone.idle && queue.notEmpty:                  │   │
│  │      task = queue.dequeue()                          │   │
│  │      clone.send(task)                                │   │
│  │      clone.status = 'active'                         │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                 crash recovery                       │   │
│  │                                                      │   │
│  │  on clone exit:                                      │   │
│  │    if unexpected:                                    │   │
│  │      respawn with --session (resume)                 │   │
│  │      requeue current task                            │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### daemon lifecycle

```sh
# daemon starts on first dispatch to zone
$ khlone act "implement auth"

# checks: is daemon active for this zone?
# if not: spawns daemon
# daemon then: enrolls hero, processes queue

# daemon file
~/.khlone/zones/{zone-id}/daemon.pid
~/.khlone/zones/{zone-id}/daemon.sock
```

---

## full usecase walkthrough

### scenario

```sh
# 1. start headless in background
$ khlone act "implement auth"

# 2. send followup question
$ khlone ask "what files changed?"

# 3. watch output
$ khlone watch

# 4. attach and talk
$ khlone talk

# 5. watch some more
$ khlone watch

# 6. await and pipe output
$ khlone ask "summarize changes" --await >> summary.md
```

---

### step 1: `khlone act "implement auth"`

```
user shell                    khlone                           daemon                         clone (claude)
    │                            │                                │                                │
    │  khlone act "impl auth"    │                                │                                │
    │ ──────────────────────────►│                                │                                │
    │                            │                                │                                │
    │                            │  dispatch()                    │                                │
    │                            │  ├── inferZone()               │                                │
    │                            │  │   └── cwd → @feat/auth      │                                │
    │                            │  │                             │                                │
    │                            │  ├── is daemon active?         │                                │
    │                            │  │   └── check daemon.pid      │                                │
    │                            │  │                             │                                │
    │                            │  │   [no daemon]               │                                │
    │                            │  │                             │                                │
    │                            │  ├── spawnDaemon()             │                                │
    │                            │  │   └── fork daemon process ─────────────────────────────────►│
    │                            │  │                             │  daemon starts                 │
    │                            │  │                             │  ├── load zone state           │
    │                            │  │                             │  ├── enrollHero()              │
    │                            │  │                             │  │   └── spawnClaudeCli() ────────────────────►│
    │                            │  │                             │  │       ├── PTY created       │  claude starts │
    │                            │  │                             │  │       ├── socket created    │  --headless    │
    │                            │  │                             │  │       └── pid stored        │  --session xyz │
    │                            │  │                             │  │                             │                │
    │                            │  │                             │  └── start taskProcessor()    │                │
    │                            │  │                             │                                │                │
    │                            │  ├── connect to daemon sock    │                                │                │
    │                            │  │                             │                                │                │
    │                            │  ├── enqueueTask()             │                                │                │
    │                            │  │   └── send via socket ─────────►│                            │                │
    │                            │  │                             │  queue.push(task)              │                │
    │                            │  │                             │                                │                │
    │                            │  └── return immediately        │                                │                │
    │                            │                                │                                │                │
    │  ✓ task-001 → foreman.1    │                                │                                │                │
    │ ◄──────────────────────────│                                │                                │                │
    │                            │                                │                                │                │
    │  $ _ (shell free)          │                                │  [async: taskProcessor]        │                │
    │                            │                                │  ├── dequeue task-001          │                │
    │                            │                                │  ├── clone.send(task) ────────────────────────►│
    │                            │                                │  │                             │  receives msg  │
    │                            │                                │  │                             │  starts work   │
    │                            │                                │  └── clone.status = active     │                │
```

**what happens:**
1. `khlone act` spawns daemon if not active
2. daemon spawns clone (claude) with PTY + socket
3. task queued via daemon socket
4. shell returns immediately
5. daemon's taskProcessor sends task to clone async

---

### step 2: `khlone ask "what files changed?"`

```
user shell                    khlone                           daemon                         clone (claude)
    │                            │                                │                                │
    │                            │                                │  [clone still on task-001]     │ ● active
    │                            │                                │                                │
    │  khlone ask "what files?"  │                                │                                │
    │ ──────────────────────────►│                                │                                │
    │                            │                                │                                │
    │                            │  dispatch()                    │                                │
    │                            │  ├── daemon already active     │                                │
    │                            │  ├── connect to daemon sock    │                                │
    │                            │  ├── enqueueTask() ───────────────►│                            │
    │                            │  │                             │  queue.push(task-002)          │
    │                            │  │                             │  [task-001 still active]       │
    │                            │  │                             │                                │
    │                            │  └── return immediately        │                                │
    │                            │                                │                                │
    │  ✓ task-002 → foreman.1    │                                │                                │
    │    (queued, 1 ahead)       │                                │                                │
    │ ◄──────────────────────────│                                │                                │
    │                            │                                │                                │
    │  $ _                       │                                │                                │
```

**what happens:**
1. daemon already active
2. task queued behind task-001
3. processes when clone becomes idle

---

### step 3: `khlone watch`

```
user shell                    khlone                           daemon                         clone (claude)
    │                            │                                │                                │
    │  khlone watch              │                                │                                │ ● active
    │ ──────────────────────────►│                                │                                │
    │                            │                                │                                │
    │                            │  watchClone()                  │                                │
    │                            │  ├── connect to daemon sock    │                                │
    │                            │  ├── request output stream ───────►│                            │
    │                            │  │                             │  subscribe to clone.output()   │
    │                            │  │                             │                                │
    │                            │  │  [stream connected]         │                                │
    │                            │  │                             │                                │
    │  lets watch...             │  │                             │                                │
    │ ◄──────────────────────────│  │                             │                                │
    │                            │  │                             │                                │
    │         ┬                  │  │◄────────────────────────────────│◄───────────────────────────│
    │ foreman │ read auth.ts     │  │  [stdout piped through]     │  clone emits output            │
    │         │                  │  │                             │                                │
    │         │ create jwt.ts    │  │◄────────────────────────────────│◄───────────────────────────│
    │         │                  │  │                             │                                │
    │         │ write tests...   │  │◄────────────────────────────────│◄───────────────────────────│
    │         │                  │  │                             │                                │
    │  ^C     │                  │  │                             │                                │
    │ ────────┴──────────────────│  │                             │                                │
    │                            │  │                             │                                │
    │                            │  detach (read-only)            │                                │
    │                            │  └── disconnect stream         │  [clone continues]             │ ● active
    │                            │                                │                                │
    │  $ _                       │                                │                                │
```

**what happens:**
1. connect to daemon's output stream for clone
2. pipe PTY stdout to terminal (filtered/formatted)
3. ctrl+c detaches stream
4. clone continues work (not interrupted)

---

### step 4: `khlone talk`

```
user shell                    khlone                           daemon                         clone (claude)
    │                            │                                │                                │
    │  khlone talk               │                                │                                │ ● active
    │ ──────────────────────────►│                                │                                │
    │                            │                                │                                │
    │                            │  talkToClone()                 │                                │
    │                            │  ├── connect to daemon         │                                │
    │                            │  ├── request PTY attach ──────────►│                            │
    │                            │  │                             │  pause taskProcessor           │
    │                            │  │                             │  return PTY fd                 │
    │                            │  │                             │                                │
    │                            │  ├── attach PTY to terminal    │                                │
    │                            │  │   ├── stdin → clone.stdin   │                                │
    │                            │  │   └── clone.stdout → stdout │                                │
    │                            │  │                             │                                │
    │  ╭────────────────────╮    │  │                             │                                │
    │  │ ● foreman.1        │    │  │                             │                                │
    │  │                    │    │  │                             │                                │
    │  │ [attached]         │    │  │                             │                                │
    │  ╰────────────────────╯    │  │                             │                                │
    │                            │  │                             │                                │
    │  > what's the status?      │  │                             │                                │
    │ ─────────────────────────────────────────────────────────────────────────────────────────────►│
    │                            │  │                             │                                │ receives input
    │                            │  │                             │                                │
    │  I've created auth.ts...   │  │                             │                                │
    │ ◄────────────────────────────────────────────────────────────────────────────────────────────│
    │                            │  │                             │                                │
    │  > /exit                   │  │                             │                                │
    │ ──────────────────────────►│  │                             │                                │
    │                            │  │                             │                                │
    │                            │  detach PTY                    │                                │
    │                            │  └── signal daemon ────────────────►│                            │
    │                            │                                │  resume taskProcessor          │
    │                            │                                │                                │
    │  $ _                       │                                │                                │
```

**what happens:**
1. daemon pauses task queue
2. PTY attached bidirectionally to terminal
3. direct conversation with clone
4. `/exit` detaches and resumes queue

---

### step 5: `khlone watch` (again)

same as step 3 — connect read-only stream, ctrl+c to detach

---

### step 6: `khlone ask "summarize" --await >> summary.md`

```
user shell                    khlone                           daemon                         clone (claude)
    │                            │                                │                                │
    │  khlone ask "sum" --await  │                                │                                │ ○ idle
    │ ──────────────────────────►│                                │                                │
    │                            │                                │                                │
    │                            │  dispatch()                    │                                │
    │                            │  ├── enqueueTask() ───────────────►│                            │
    │                            │  │                             │  queue.push(task-003)          │
    │                            │  │                             │                                │
    │                            │  │  [--await flag]             │  [clone idle, picks up]        │
    │                            │  │                             │  clone.send(task-003) ─────────────────────────►│
    │                            │  │                             │                                │ starts work
    │                            │  │                             │                                │
    │                            │  awaitTask(task-003)           │                                │
    │                            │  ├── subscribe to completion ─────►│                            │
    │                            │  │                             │                                │
    │  [shell blocked]           │  │                             │                                │
    │                            │  │                             │                                │ work...
    │                            │  │                             │                                │
    │                            │  │                             │                                │ done!
    │                            │  │                             │◄─────────────────────────────────│
    │                            │  │◄────────────────────────────────│ task-003 complete          │
    │                            │  │                             │  emit completion event         │
    │                            │  │                             │                                │
    │                            │  └── return output             │                                │
    │                            │                                │                                │
    │  Here's a summary of...    │                                │                                │
    │ ◄──────────────────────────│                                │                                │
    │                            │                                │                                │
    │  >> summary.md             │                                │                                │
    │                            │                                │                                │
    │  $ _                       │                                │                                │
```

**what happens:**
1. task queued as usual
2. `--await` subscribes to completion event
3. shell blocks until task done
4. output captured and emitted to stdout
5. shell redirect pipes to file

---

## filediff treestruct

```
packages/khlone/
├── [+] package.json
├── [+] tsconfig.json
│
├── bin/
│   └── [+] khlone.ts                          # cli entrypoint
│
├── src/
│   ├── contract/
│   │   └── cli/
│   │       ├── [+] index.ts                   # commander setup
│   │       ├── [+] act.ts
│   │       ├── [+] ask.ts
│   │       ├── [+] watch.ts
│   │       ├── [+] talk.ts
│   │       ├── [+] status.ts
│   │       ├── [+] list.ts
│   │       ├── [+] init.ts
│   │       └── [+] log.ts
│   │
│   ├── daemon/
│   │   ├── [+] spawnDaemon.ts                 # fork daemon for zone
│   │   ├── [+] daemonMain.ts                  # daemon entry point
│   │   ├── [+] cloneSupervisor.ts             # manage clone processes
│   │   ├── [+] taskProcessor.ts               # dequeue and send tasks
│   │   ├── [+] ipcServer.ts                   # unix socket server
│   │   ├── [+] ipcClient.ts                   # unix socket client
│   │   └── [+] crashRecovery.ts               # respawn on exit
│   │
│   ├── domain.objects/
│   │   ├── [+] Orchestrator.ts
│   │   ├── [+] Site.ts
│   │   ├── [+] SiteConfig.ts
│   │   ├── [+] Zone.ts
│   │   ├── [+] ZoneAddress.ts
│   │   ├── [+] Clone.ts
│   │   ├── [+] Task.ts
│   │   ├── [+] SkillInvocation.ts
│   │   ├── [+] CloneStreamEmission.ts
│   │   ├── [+] DaemonState.ts
│   │   ├── [+] TaskQueuedEvent.ts
│   │   ├── [+] TaskStartedEvent.ts
│   │   ├── [+] TaskCompletedEvent.ts
│   │   ├── [+] TaskFailedEvent.ts
│   │   ├── [+] CloneEnrolledEvent.ts
│   │   ├── [+] CloneCrashedEvent.ts
│   │   └── [+] paths.ts
│   │
│   ├── domain.operations/
│   │   ├── orchestrator/
│   │   │   ├── [+] getOrchestrator.ts
│   │   │   ├── [+] registerSite.ts
│   │   │   └── [+] unregisterSite.ts
│   │   │
│   │   ├── site/
│   │   │   ├── [+] getOneSite.ts
│   │   │   ├── [+] getAllSites.ts
│   │   │   └── [+] parseSiteConfig.ts
│   │   │
│   │   ├── zone/
│   │   │   ├── [+] getOneZone.ts
│   │   │   ├── [+] getAllZones.ts
│   │   │   ├── [+] initZone.ts
│   │   │   ├── [+] ensureZone.ts
│   │   │   ├── [+] inferZone.ts
│   │   │   └── [+] parseZoneAddress.ts
│   │   │
│   │   ├── clone/
│   │   │   ├── [+] getOneClone.ts
│   │   │   ├── [+] getAllClones.ts
│   │   │   ├── [+] enrollClone.ts
│   │   │   ├── [+] deleteClone.ts
│   │   │   ├── [+] setCloneStatus.ts
│   │   │   ├── [+] inferClone.ts
│   │   │   └── [+] resolveRoleBrain.ts
│   │   │
│   │   ├── task/
│   │   │   ├── [+] getOneTask.ts
│   │   │   ├── [+] getAllTasks.ts
│   │   │   ├── [+] enqueueTask.ts
│   │   │   ├── [+] setTaskAsStarted.ts
│   │   │   ├── [+] setTaskAsCompleted.ts
│   │   │   ├── [+] setTaskAsFailed.ts
│   │   │   └── [+] generateTaskSlug.ts
│   │   │
│   │   ├── dispatch/
│   │   │   ├── [+] dispatch.ts
│   │   │   └── [+] dispatchWithSkill.ts
│   │   │
│   │   ├── observe/
│   │   │   ├── [+] watchClone.ts
│   │   │   ├── [+] talkToClone.ts
│   │   │   ├── [+] awaitTask.ts
│   │   │   └── [+] getTranscript.ts
│   │   │
│   │   ├── daemon/
│   │   │   ├── [+] ensureDaemon.ts
│   │   │   ├── [+] connectToDaemon.ts
│   │   │   └── [+] isDaemonAlive.ts
│   │   │
│   │   └── status/
│   │       ├── [+] getStatus.ts
│   │       ├── [+] listResources.ts
│   │       └── [+] inferScope.ts
│   │
│   └── access/
│       └── daos/
│           ├── [+] daoOrchestrator.ts
│           ├── [+] daoSite.ts
│           ├── [+] daoZone.ts
│           ├── [+] daoClone.ts
│           ├── [+] daoTask.ts
│           ├── [+] daoDaemon.ts
│           ├── [+] daoTranscript.ts
│           └── [+] index.ts

packages/rhachet-brains-anthropic/
├── [+] package.json
├── [+] tsconfig.json
│
├── src/
│   ├── [+] index.ts                           # exports
│   ├── [+] genBrainCli.ts                     # BrainCli factory
│   ├── [+] spawnClaudePty.ts                  # PTY spawn
│   ├── [+] claudeIpc.ts                       # send/receive commands
│   ├── [+] claudeAttach.ts                    # attach/detach PTY
│   ├── [+] claudeOutput.ts                    # output stream parser
│   └── [+] claudeSession.ts                   # session persistence
│
│   └── domain.objects/
│       ├── [+] BrainCli.ts                    # interface
│       ├── [+] BrainCliProcess.ts             # process handle
│       └── [+] BrainCliEmission.ts            # output event
```

---

## codepath treestruct

```
contract/cli/
├── [+] index.ts
│     ├── createProgram()
│     └── registerCommands()
│
├── [+] act.ts
│     └── handleAct(args)
│           ├── parseFlags()
│           ├── ensureDaemon()                 # spawn daemon if not active
│           ├── connectToDaemon()              # IPC client
│           ├── dispatch()                     # via IPC
│           ├── formatOutput()
│           └── if --watch → watchClone()
│
├── [+] watch.ts
│     └── handleWatch(args)
│           ├── connectToDaemon()
│           ├── subscribeToOutput()            # request stream
│           └── pipeToStdout()
│
└── [+] talk.ts
      └── handleTalk(args)
            ├── connectToDaemon()
            ├── requestPtyAttach()
            ├── attachTerminal()               # stdin/stdout
            └── onExit → detach()

daemon/
├── [+] daemonMain.ts
│     └── main()
│           ├── loadZoneState()
│           ├── startIpcServer()
│           ├── startCloneSupervisor()
│           └── startTaskProcessor()
│
├── [+] cloneSupervisor.ts
│     └── CloneSupervisor
│           ├── enrollClone()
│           │     ├── resolveRoleBrain()
│           │     ├── brainCli.spawn()         # [←] from rhachet-brains-*
│           │     └── registerProcess()
│           │
│           ├── onCloneExit()
│           │     ├── if unexpected → respawn()
│           │     └── requeueCurrentTask()
│           │
│           └── getCloneProcess()
│
├── [+] taskProcessor.ts
│     └── TaskProcessor
│           ├── loop()
│           │     ├── for each idle clone
│           │     │     ├── dequeue task
│           │     │     ├── clone.send(task)   # via BrainCliProcess
│           │     │     └── setTaskAsStarted()
│           │     │
│           │     └── on task complete
│           │           ├── setTaskAsCompleted()
│           │           └── emit event
│           │
│           ├── pause()                        # for talk mode
│           └── resume()
│
└── [+] ipcServer.ts
      └── IpcServer
            ├── onConnect()
            ├── handleEnqueue()                # dispatch → enqueue
            ├── handleWatch()                  # subscribe to output
            ├── handleAttach()                 # PTY attach
            └── handleAwait()                  # completion subscription

domain.operations/
├── dispatch/
│   └── [+] dispatch.ts
│         └── dispatch(input, context)
│               ├── ensureDaemon()
│               ├── connectToDaemon()
│               ├── inferZone()
│               ├── inferClone()
│               ├── ipc.enqueueTask()          # send via socket
│               └── return { task, clone }
│
└── observe/
    ├── [+] watchClone.ts
    │     └── watchClone(input, context)
    │           ├── connectToDaemon()
    │           ├── ipc.subscribeOutput()
    │           └── yield* emissions
    │
    ├── [+] talkToClone.ts
    │     └── talkToClone(input, context)
    │           ├── connectToDaemon()
    │           ├── ipc.requestAttach()
    │           ├── attachPty()
    │           └── return TalkSession
    │
    └── [+] awaitTask.ts
          └── awaitTask(input, context)
                ├── connectToDaemon()
                ├── ipc.subscribeCompletion()
                └── await completion

rhachet-brains-anthropic/
├── [+] genBrainCli.ts
│     └── genBrainCli(config)
│           └── return { spawn }
│
├── [+] spawnClaudePty.ts
│     └── spawnClaudePty(input)
│           ├── [←] node-pty.spawn()
│           ├── createSocketServer()
│           └── return BrainCliProcess
│
├── [+] BrainCliProcess (methods)
│     ├── send(input)
│     │     └── pty.write(formatMessage(input))
│     │
│     ├── output()
│     │     └── yield* parseOutputStream(pty.onData)
│     │
│     ├── attach()
│     │     └── return { stdin: pty.stdin, stdout: pty.stdout }
│     │
│     ├── detach()
│     │     └── disconnect terminal, keep process
│     │
│     ├── await()
│     │     └── wait for done emission
│     │
│     └── kill()
│           └── pty.kill()
│
└── [+] claudeOutput.ts
      └── parseOutputStream(stream)
            ├── detect output type (tool_use, thought, etc)
            └── yield BrainCliEmission
```

---

## domain objects

### Clone (extended)

```ts
interface Clone {
  uuid?: string;
  slug: string;                    // "mechanic.1"
  zone: Ref<typeof Zone>;
  role: string;                    // alias
  roleRef: string;                 // "ehmpathy/mechanic"
  brain: string;                   // alias
  brainRef: string;                // "anthropic/claude/code/opus/v4.5"
  status: 'idle' | 'active';
  task: {
    focus: { slug: string; progress: number } | null;
    queue: Ref<typeof Task>[];
  };
  process: {
    pid: number;
    socketPath: string;            // for IPC
  } | null;
}
```

### DaemonState

```ts
interface DaemonState {
  zone: Ref<typeof Zone>;
  pid: number;
  socketPath: string;
  startedAt: string;
  clones: Ref<typeof Clone>[];
}
```

### BrainCliProcess (rhachet-brains-*)

```ts
interface BrainCliProcess {
  pid: number;
  sessionId: string;
  socketPath: string;

  send(input: { say: string }): Promise<void>;
  invoke(input: { skill: Record<string, unknown> }): Promise<void>;
  output(): AsyncIterable<BrainCliEmission>;
  attach(): Promise<{ stdin: Writable; stdout: Readable }>;
  detach(): Promise<void>;
  await(): Promise<BrainCliResult>;
  isAlive(): boolean;
  kill(): Promise<void>;
}
```

---

## test coverage

### unit tests

```
src/domain.operations/**/*.test.ts
├── dispatch/
│   ├── dispatch.test.ts
│   └── dispatchWithSkill.test.ts
│
├── zone/
│   ├── inferZone.test.ts
│   ├── parseZoneAddress.test.ts
│   └── ensureZone.test.ts
│
├── clone/
│   ├── inferClone.test.ts
│   ├── resolveRoleBrain.test.ts
│   └── enrollClone.test.ts
│
├── task/
│   ├── enqueueTask.test.ts
│   └── task lifecycle tests
│
└── daemon/
    ├── ensureDaemon.test.ts
    └── isDaemonAlive.test.ts
```

### integration tests

```
src/**/*.integration.test.ts
├── daemon/
│   ├── ipcServer.integration.test.ts    # socket communication
│   ├── taskProcessor.integration.test.ts
│   └── cloneSupervisor.integration.test.ts
│
├── access/daos/
│   ├── daoOrchestrator.integration.test.ts
│   ├── daoSite.integration.test.ts
│   ├── daoZone.integration.test.ts
│   ├── daoClone.integration.test.ts
│   ├── daoTask.integration.test.ts
│   └── daoDaemon.integration.test.ts
│
└── rhachet-brains-anthropic/
    ├── spawnClaudePty.integration.test.ts
    ├── claudeIpc.integration.test.ts
    └── claudeAttach.integration.test.ts
```

### acceptance tests

```
src/contract/cli/**/*.acceptance.test.ts
├── act.acceptance.test.ts
│   ├── given: zone not bound
│   │   └── when: khlone act "task" → daemon spawns, task queued
│   │
│   └── given: daemon active
│       └── when: khlone act "task" → task queued via IPC
│
├── watch.acceptance.test.ts
│   └── given: clone active
│       └── when: khlone watch → streams output, ctrl+c detaches
│
├── talk.acceptance.test.ts
│   └── given: clone active
│       └── when: khlone talk → PTY attached, /exit detaches
│
└── await.acceptance.test.ts
    └── given: task queued
        └── when: khlone ask --await → blocks, returns output
```

---

## what needs to be built vs reused

### needs to be built

| component | location | description |
|-----------|----------|-------------|
| **BrainCli interface** | rhachet-brains-* | PTY spawn, IPC socket, attach/detach |
| **khlone daemon** | khlone/daemon | clone supervisor, task processor |
| **IPC protocol** | khlone + rhachet | command/response over unix socket |
| **PTY management** | rhachet-brains-* | spawn, attach, detach |
| **crash recovery** | khlone daemon | detect exit, respawn, requeue |

### can be reused

| component | source | how |
|-----------|--------|-----|
| **node-pty** | npm package | PTY spawn library |
| **claude --resume** | claude code | session persistence |
| **unix socket** | node net module | IPC transport |
| **rhachet roles** | rhachet | role definitions unchanged |

### uncertain (needs research)

| component | question |
|-----------|----------|
| **claude --headless** | does this flag exist? or do we need to request it? |
| **claude session IPC** | can we send commands to active session? |
| **claude MCP** | could MCP provide IPC channel? |

---

## claude code integration options

### option A: PTY wrapper (works today) ✓ chosen

```ts
// rhachet-brains-anthropic wraps claude CLI via PTY

const pty = spawn('claude', [], { ... });

// send by write to stdin
pty.write('implement auth\n');

// receive by read stdout
pty.onData((data) => emit(data));
```

**pros:** works with current claude code, stable interface
**cons:** output parse requires pattern detection

### option B: claude --headless mode (future)

```sh
claude --headless --session abc123 --socket /tmp/claude.sock
```

**pros:** clean IPC, designed for automation
**cons:** doesn't exist yet (feature request to Anthropic)

### ~~option C: MCP~~ **FORBIDDEN**

MCP is **not applicable** for khlone:
- MCP is for Claude to call tools (wrong direction)
- we need to call Claude, not provide tools to Claude
- adds unnecessary complexity and fragility

see `3.1.research.ipc-process-management.v1.i1.md` for details

---

## summary

**the gap:** dispatch blueprint assumed SDK-like brains, but they're CLIs

**the solution:**
1. **BrainCli interface** in rhachet-brains-* — PTY spawn, IPC, attach/detach
2. **khlone daemon** — per-zone supervisor for clone processes
3. **IPC layer** — unix socket for commands, PTY for talk mode
4. **crash recovery** — respawn with session resume

**the full flow:**
1. `khlone act` → daemon spawns clone (PTY), queues task, returns
2. `khlone ask` → queues task via daemon socket
3. `khlone watch` → streams PTY output (read-only)
4. `khlone talk` → attaches PTY bidirectionally
5. `khlone --await` → blocks on task completion event
