# khlone v0.0: domain distillation

> declastruct domain.objects and domain.operations

---

## usecases → contract envision

### usecase.1: dispatch task

```ts
// queue task to hero (default)
const task = await khlone.act({ say: "implement auth" }, context);
// => Task { slug: "task-abc-123", status: "queued", clone: "foreman.1" }

// queue task to specific clone
const task = await khlone.ask({ say: "research patterns", who: "researcher.1" }, context);

// enroll clone and queue task
const task = await khlone.act({ say: "review code", who: "reviewer++" }, context);
// => enrolls reviewer.1, queues task to it

// dispatch via skill (routes to capable role)
const task = await khlone.ask({ skill: { choice: "review.architecture" } }, context);
// => routes to role that knows skill, enrolls if needed

// dispatch via skill with passthrough args
const task = await khlone.act({
  skill: {
    choice: "init.behavior",
    input: { name: "add-cool-feature", zone: "@feat/xyz" },
  },
}, context);
// => skill receives all args for reuse of khlone context
```

### usecase.2: observe clone

```ts
// stream clone output
const stream = await khlone.watch({ who: "foreman.1" }, context);
// => AsyncIterable<CloneStreamEmission>

// interactive session
const session = await khlone.talk({ who: "foreman.1" }, context);
// => TalkSession { send(), receive(), exit() }

// block until complete
const output = await khlone.await({ task: "task-abc-123" }, context);
// => string (final output)
```

### usecase.3: inspect state

```ts
// list resources
const sites = await khlone.list({ scope: "sites" }, context);
const zones = await khlone.list({ scope: "zones", site: "ehmpathy/myrepo" }, context);
const crews = await khlone.list({ scope: "crews", zone: "@feat/auth" }, context);
const tasks = await khlone.list({ scope: "tasks", zone: "@feat/auth" }, context);

// status with smart defaults
const status = await khlone.status({}, context); // auto-selects scope from pwd
const status = await khlone.status({ scope: "zone" }, context);
const status = await khlone.status({ task: "task-abc-123" }, context);
const status = await khlone.status({ who: "mechanic.1" }, context);
```

### usecase.4: cross-scope dispatch

```ts
// dispatch to different zone
const task = await khlone.act({
  say: "fix bug",
  zone: "@hotfix/typo",
}, context);

// dispatch to different site
const task = await khlone.ask({
  say: "how does auth work",
  zone: "svc-auth@main",
  who: "researcher++",
  await: true,
}, context);
```

---

## domain.objects

### entities

#### Orchestrator

singleton that tracks all sites on machine.

```ts
interface Orchestrator {
  // no id — singleton
  sites: Ref<typeof Site>[];
}

class Orchestrator extends DomainEntity<Orchestrator> {
  public static primary = [] as const; // singleton
  public static unique = [] as const;
}
```

**state:** `~/.khlone/orchestrator.yml`

---

#### Site

repo-level container. one per `org/repo`.

```ts
interface Site {
  uuid?: string;
  slug: string;                    // "ehmpathy/myrepo"
  path: string;                    // "/home/user/repos/myrepo"
  config: SiteConfig;              // parsed khlone.yml
  zones: Ref<typeof Zone>[];
}

class Site extends DomainEntity<Site> {
  public static primary = ['uuid'] as const;
  public static unique = ['slug'] as const;
}
```

**state:** `~/.khlone/sites/{slug}/site.yml`

---

#### Zone

worktree instance. one per branch checkout.

```ts
interface Zone {
  uuid?: string;
  slug: string;                    // "@feat/auth"
  site: Ref<typeof Site>;
  path: string;                    // worktree path
  host: 'local' | 'cloud';
  hero: Ref<typeof Clone>;         // default clone
  clones: Ref<typeof Clone>[];
  tasks: Ref<typeof Task>[];
}

class Zone extends DomainEntity<Zone> {
  public static primary = ['uuid'] as const;
  public static unique = ['site', 'slug'] as const;
}
```

**state:** `{worktree}/.khlone/.bind/zone.yml`

---

#### Clone

an enrolled brain — a brain bound to a role within a zone. runs headless.

```ts
interface Clone {
  uuid?: string;
  slug: string;                    // "mechanic.1"
  zone: Ref<typeof Zone>;
  role: string;                    // role alias from crew.roles
  roleRef: string;                 // resolved "ehmpathy/mechanic"
  brain: string;                   // brain alias from crew.brains
  brainRef: string;                // resolved "anthropic/claude/code/opus/v4.5"
  status: CloneStatus;
  task: {
    focus: {
      choice: RefByUnique<typeof Task> | null;
      progress: number | null;     // 0-100 when active
    };
    queue: RefByUnique<typeof Task>[];
  };
  pid: number | null;
}

type CloneStatus = 'idle' | 'active';

class Clone extends DomainEntity<Clone> {
  public static primary = ['uuid'] as const;
  public static unique = ['zone', 'slug'] as const;
}
```

**state:** `{worktree}/.khlone/clones/{slug}/state.yml`

---

#### Task

unit of work. ask or act.

```ts
interface Task {
  uuid?: string;
  slug: string;                    // "task-abc-123"
  zone: Ref<typeof Zone>;
  clone: Ref<typeof Clone>;
  type: 'ask' | 'act';
  say: string | null;              // freeform prompt (null if skill-only)
  skill: SkillInvocation | null;   // skill invoked, if any
  status: TaskStatus;
  artifact: Artifact<GitFile> | null; // captured on complete (from rhachet-artifact)
  createdAt: string;
  startedAt: string | null;
  completedAt: string | null;
}

type TaskStatus = 'queued' | 'active' | 'done' | 'failed';

class Task extends DomainEntity<Task> {
  public static primary = ['uuid'] as const;
  public static unique = ['slug'] as const;
}
```

**state:** `{worktree}/.khlone/.bind/tasks/{slug}.yml`

---

### events

#### TaskQueuedEvent

```ts
interface TaskQueuedEvent {
  task: Ref<typeof Task>;
  clone: Ref<typeof Clone>;
  zone: Ref<typeof Zone>;
  occurredAt: string;
}

class TaskQueuedEvent extends DomainEvent<TaskQueuedEvent> {
  public static unique = ['task', 'occurredAt'] as const;
}
```

#### TaskStartedEvent

```ts
interface TaskStartedEvent {
  task: Ref<typeof Task>;
  clone: Ref<typeof Clone>;
  occurredAt: string;
}

class TaskStartedEvent extends DomainEvent<TaskStartedEvent> {
  public static unique = ['task', 'occurredAt'] as const;
}
```

#### TaskCompletedEvent

```ts
interface TaskCompletedEvent {
  task: Ref<typeof Task>;
  clone: Ref<typeof Clone>;
  artifact: Artifact<GitFile>;       // from rhachet-artifact
  occurredAt: string;
}

class TaskCompletedEvent extends DomainEvent<TaskCompletedEvent> {
  public static unique = ['task', 'occurredAt'] as const;
}
```

#### TaskFailedEvent

```ts
interface TaskFailedEvent {
  task: Ref<typeof Task>;
  clone: Ref<typeof Clone>;
  error: string;
  occurredAt: string;
}

class TaskFailedEvent extends DomainEvent<TaskFailedEvent> {
  public static unique = ['task', 'occurredAt'] as const;
}
```

#### CloneEnrolledEvent

```ts
interface CloneEnrolledEvent {
  clone: Ref<typeof Clone>;
  zone: Ref<typeof Zone>;
  role: string;
  brain: string;
  occurredAt: string;
}

class CloneEnrolledEvent extends DomainEvent<CloneEnrolledEvent> {
  public static unique = ['clone', 'occurredAt'] as const;
}
```

---

### literals

#### SiteConfig

parsed from khlone.yml.

```ts
interface SiteConfig {
  zone: {
    host: 'local' | 'cloud';
  };
  crew: {
    hero: {
      role: string;
      brain: string;
    };
    roles: Record<string, string>;   // alias -> fully qualified
    brains: Record<string, string>;  // alias -> fully qualified
  };
}

class SiteConfig extends DomainLiteral<SiteConfig> {}
```

#### CloneStreamEmission

streamed output from clone.

```ts
interface CloneStreamEmission {
  clone: Ref<typeof Clone>;
  type: 'progress' | 'result' | 'error';
  content: string;
  timestamp: string;
}

class CloneStreamEmission extends DomainLiteral<CloneStreamEmission> {}
```

#### ZoneAddress

parsed zone address.

```ts
interface ZoneAddress {
  org: string | null;              // "ahbode" or null (current)
  repo: string | null;             // "svc-jobs" or null (current)
  branch: string;                  // "feat/auth"
}

class ZoneAddress extends DomainLiteral<ZoneAddress> {}
```

#### SkillInvocation

skill invocation with passthrough args.

```ts
interface SkillInvocation {
  choice: string;                  // skill name (e.g., "review.architecture")
  input: Record<string, unknown>;  // passthrough args from cli flags
}

class SkillInvocation extends DomainLiteral<SkillInvocation> {}
```

---

## domain.operations

### orchestrator operations

```ts
// get orchestrator state
getOrchestrator(): Promise<Orchestrator>

// register site in orchestrator
registerSite(input: { site: Site }): Promise<Orchestrator>

// unregister site from orchestrator
unregisterSite(input: { site: Ref<typeof Site> }): Promise<Orchestrator>
```

### site operations

```ts
// get one site by ref
getOneSite(input: { by: { slug: string } | { path: string } }): Promise<Site | null>

// get all sites
getAllSites(): Promise<Site[]>

// upsert site (from khlone.yml discovery)
upsertSite(input: { path: string }): Promise<Site>
```

### zone operations

```ts
// get one zone by ref
getOneZone(input: {
  by: { site: Ref<typeof Site>; slug: string } | { path: string }
}): Promise<Zone | null>

// get all zones in site
getAllZones(input: { site: Ref<typeof Site> }): Promise<Zone[]>

// init zone (bind worktree)
initZone(input: { path: string }): Promise<Zone>

// ensure zone exists (auto-init if absent)
ensureZone(input: { address: ZoneAddress }): Promise<Zone>
```

### clone operations

```ts
// get one clone by ref
getOneClone(input: {
  by: { zone: Ref<typeof Zone>; slug: string }
}): Promise<Clone | null>

// get all clones in zone
getAllClones(input: { zone: Ref<typeof Zone> }): Promise<Clone[]>

// enroll new clone
enrollClone(input: {
  zone: Ref<typeof Zone>;
  role: string;
  brain?: string;
}): Promise<Clone>

// delete clone (remove from crew)
deleteClone(input: { clone: Ref<typeof Clone> }): Promise<void>


// update clone status
setCloneStatus(input: {
  clone: Ref<typeof Clone>;
  status: CloneStatus;
  progress?: number;
}): Promise<Clone>
```

### task operations

```ts
// get one task by ref
getOneTask(input: { by: { slug: string } }): Promise<Task | null>

// get all tasks in zone
getAllTasks(input: { zone: Ref<typeof Zone> }): Promise<Task[]>

// enqueue new task
enqueueTask(input: {
  zone: Ref<typeof Zone>;
  clone: Ref<typeof Clone>;
  type: 'ask' | 'act';
  say?: string;
  skill?: SkillInvocation;
  priority?: 'normal' | 'front' | 'disrupt';
}): Promise<Task>

// set task as started (clone picks up from queue)
setTaskAsStarted(input: { task: Ref<typeof Task> }): Promise<Task>

// set task as completed
setTaskAsCompleted(input: {
  task: Ref<typeof Task>;
  artifact: Artifact<GitFile>;
}): Promise<Task>

// set task as failed
setTaskAsFailed(input: {
  task: Ref<typeof Task>;
  error: string;
}): Promise<Task>
```

### dispatch operations (high-level)

```ts
// dispatch ask/act (infers clone, enqueues task)
dispatch(input: {
  type: 'ask' | 'act';
  say?: string;
  zone?: ZoneAddress;
  who?: string;                    // clone slug or "role++"
  skill?: SkillInvocation;
  brain?: string;
  priority?: 'normal' | 'front' | 'disrupt';
}): Promise<{ task: Task; clone: Clone; enrolled: boolean }>

// infer clone from --who flag
inferClone(input: {
  zone: Zone;
  who?: string;
  skill?: string;
}): Promise<{ clone: Clone; enrolled: boolean }>

// infer zone from address
inferZone(input: {
  address?: ZoneAddress;
  cwd: string;
}): Promise<Zone>
```

### observation operations

```ts
// watch clone output
watchClone(input: {
  clone: Ref<typeof Clone>;
}): AsyncIterable<CloneStreamEmission>

// talk to clone (interactive)
talkToClone(input: {
  clone: Ref<typeof Clone>;
}): Promise<TalkSession>

// await task completion
awaitTask(input: {
  task: Ref<typeof Task>;
}): Promise<string>

// get clone transcript
getTranscript(input: {
  clone: Ref<typeof Clone>;
}): Promise<TranscriptEntry[]>
```

### status operations

```ts
// get status (smart scope resolution)
getStatus(input: {
  scope?: 'orchestrator' | 'site' | 'zone';
  site?: Ref<typeof Site>;
  zone?: Ref<typeof Zone>;
  clone?: Ref<typeof Clone>;
  task?: Ref<typeof Task>;
  cwd?: string;
}): Promise<StatusSnapshot>

// list resources
listResources(input: {
  scope: 'sites' | 'zones' | 'crews' | 'tasks';
  site?: Ref<typeof Site>;
  zone?: Ref<typeof Zone>;
}): Promise<ResourceList>
```

---

## access.daos

### daoOrchestrator

```ts
interface DaoOrchestrator {
  get: {
    one(): Promise<Orchestrator>;
  };
  set: {
    upsert(orchestrator: Orchestrator): Promise<Orchestrator>;
  };
}
```

**storage:** `~/.khlone/orchestrator.yml`

### daoSite

```ts
interface DaoSite {
  get: {
    one: {
      bySlug(input: { slug: string }): Promise<Site | null>;
      byPath(input: { path: string }): Promise<Site | null>;
    };
    all(): Promise<Site[]>;
  };
  set: {
    upsert(site: Site): Promise<Site>;
  };
  del: {
    bySlug(input: { slug: string }): Promise<void>;
  };
}
```

**storage:** `~/.khlone/sites/{slug}/site.yml`

### daoZone

```ts
interface DaoZone {
  get: {
    one: {
      byRef(input: { site: Ref<typeof Site>; slug: string }): Promise<Zone | null>;
      byPath(input: { path: string }): Promise<Zone | null>;
    };
    all: {
      bySite(input: { site: Ref<typeof Site> }): Promise<Zone[]>;
    };
  };
  set: {
    upsert(zone: Zone): Promise<Zone>;
  };
  del: {
    byRef(input: { site: Ref<typeof Site>; slug: string }): Promise<void>;
  };
}
```

**storage:** `{worktree}/.khlone/.bind/zone.yml`

### daoClone

```ts
interface DaoClone {
  get: {
    one: {
      byRef(input: { zone: Ref<typeof Zone>; slug: string }): Promise<Clone | null>;
    };
    all: {
      byZone(input: { zone: Ref<typeof Zone> }): Promise<Clone[]>;
    };
  };
  set: {
    upsert(clone: Clone): Promise<Clone>;
  };
  del: {
    byRef(input: { zone: Ref<typeof Zone>; slug: string }): Promise<void>;
  };
}
```

**storage:** `{worktree}/.khlone/clones/{slug}/state.yml`

### daoTask

```ts
interface DaoTask {
  get: {
    one: {
      bySlug(input: { slug: string }): Promise<Task | null>;
    };
    all: {
      byZone(input: { zone: Ref<typeof Zone> }): Promise<Task[]>;
      byClone(input: { clone: Ref<typeof Clone> }): Promise<Task[]>;
    };
  };
  set: {
    upsert(task: Task): Promise<Task>;
  };
  del: {
    bySlug(input: { slug: string }): Promise<void>;
  };
}
```

**storage:** `{worktree}/.khlone/.bind/tasks/{slug}.yml`

### daoTranscript

```ts
interface DaoTranscript {
  get: {
    all: {
      byClone(input: { clone: Ref<typeof Clone> }): Promise<TranscriptEntry[]>;
    };
  };
  set: {
    append(input: { clone: Ref<typeof Clone>; entry: TranscriptEntry }): Promise<void>;
  };
}
```

**storage:** `{worktree}/.khlone/clones/{slug}/transcript.jsonl`

---

## relationships

### treestruct

```
Orchestrator (singleton)
└── Site* (1:N)
    ├── SiteConfig (1:1, embedded)
    └── Zone* (1:N)
        ├── Clone* (1:N)
        │   └── Task* (1:N, queue)
        └── Task* (1:N, all in zone)
```

### dependencies

| from | to | relationship |
|------|----|--------------|
| Site | Orchestrator | registered in |
| Zone | Site | belongs to |
| Clone | Zone | lives in |
| Clone | SiteConfig.crew.roles | role resolved from |
| Clone | SiteConfig.crew.brains | brain resolved from |
| Task | Zone | belongs to |
| Task | Clone | assigned to |

### decoration treestruct

```
role (template from rhachet)
└── Clone (instance)
    ├── adds: status, pid, queue, progress
    └── adds: brain (selected from config)

skill (template from rhachet)
└── Task (instance when --skill used)
    ├── adds: status, artifact
    └── adds: clone assignment
```

---

## composition flow

### dispatch flow

```
user: khlone act "implement auth"
  │
  ├─► inferZone(cwd)
  │     └─► Zone (from worktree path)
  │
  ├─► inferClone(zone, who=null)
  │     └─► Clone (zone.hero)
  │
  └─► enqueueTask(zone, clone, "act", prompt)
        ├─► Task (status=queued)
        └─► emit TaskQueuedEvent
```

### enroll flow

```
user: khlone act "research" --who researcher++
  │
  ├─► inferZone(cwd)
  │
  ├─► inferClone(zone, who="researcher++")
  │     ├─► parse "researcher" role, "++" = enroll
  │     ├─► resolve role alias from crew.roles
  │     ├─► resolve brain alias from crew.brains
  │     └─► enrollClone(zone, role, brain)
  │           ├─► Clone (status=idle)
  │           └─► emit CloneEnrolledEvent
  │
  └─► enqueueTask(zone, clone, "act", prompt)
```

### observation flow

```
user: khlone watch
  │
  ├─► inferClone(zone, who=null)
  │     └─► Clone (zone.hero)
  │
  └─► watchClone(clone)
        └─► AsyncIterable<CloneStreamEmission>
              ├─► stream progress to stdout
              └─► ctrl+c: return to shell
```
