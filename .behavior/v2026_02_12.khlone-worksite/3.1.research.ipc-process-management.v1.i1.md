# khlone v0.0: IPC and process management research

> answers to critical integration questions

---

## what is IPC?

**IPC = inter-process communication**

mechanisms for separate processes to exchange data and coordinate.

| mechanism | how it works | use case |
|-----------|--------------|----------|
| **unix socket** | file-like endpoint for bidirectional bytes | local process coordination |
| **pipe** | unidirectional byte stream between processes | parent-child communication |
| **shared memory** | memory segment accessible by multiple processes | high-performance data share |
| **signals** | kernel-level notifications (SIGTERM, SIGKILL, etc) | process control |
| **message queue** | kernel-managed queue of typed messages | async coordination |

### for khlone: unix sockets

khlone uses **unix domain sockets** for IPC:

```
/tmp/khlone-{session-id}.sock
```

**why unix sockets:**
- bidirectional (both send and receive)
- fast (kernel-level, no network stack)
- file-based (easy cleanup, permissions)
- works with `node net` module

**the flow:**
```
khlone CLI                    daemon                         clone (claude)
    │                            │                                │
    │  connect to socket         │                                │
    │ ──────────────────────────►│                                │
    │                            │                                │
    │  send: { type: 'enqueue',  │                                │
    │          task: {...} }     │                                │
    │ ──────────────────────────►│                                │
    │                            │  write to PTY stdin            │
    │                            │ ──────────────────────────────►│
    │                            │                                │
    │  recv: { type: 'ack',      │                                │
    │          taskId: '...' }   │                                │
    │ ◄──────────────────────────│                                │
```

---

## MCP is forbidden

**MCP = Model Context Protocol**

MCP is Anthropic's protocol for tool/resource provision to Claude.

### why MCP is forbidden for khlone

| concern | explanation |
|---------|-------------|
| **wrong direction** | MCP is for Claude to call tools; we need the inverse (call Claude) |
| **complexity** | MCP adds protocol overhead for a use case it wasn't designed for |
| **dependency** | would require Claude to expose MCP server (it's a client, not server) |
| **latency** | MCP handshake adds latency vs direct PTY communication |
| **fragility** | MCP changes between versions; PTY is stable |

### what MCP is for (not our use case)

```
┌─────────────────────────────────────────────────────────────┐
│                    MCP use case                             │
│                                                             │
│  Claude ──────────────► MCP Server ──────────────► Tools    │
│         (calls tools)              (provides tools)         │
│                                                             │
│  Example: Claude calls a "read_file" MCP tool               │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                   khlone use case (different!)              │
│                                                             │
│  khlone ──────────────► Claude ──────────────► work         │
│         (sends tasks)          (executes)                   │
│                                                             │
│  Example: khlone asks Claude to "implement auth"            │
└─────────────────────────────────────────────────────────────┘
```

### the decision

**use PTY + unix sockets, not MCP.**

- PTY for terminal emulation (attach/detach, escape codes)
- unix socket for command dispatch (enqueue tasks)

---

## does `claude --headless` exist?

**answer: no (as of 2025-05)**

claude code does not have a `--headless` flag.

### current claude code flags

```sh
$ claude --help

# available flags (subset):
--resume, -r     resume most recent conversation
--continue, -c   continue most recent conversation
--print, -p      print response without interactive mode
--dangerously-skip-permissions  skip permission prompts
```

### workaround: PTY with `-p` flag

```ts
// spawn claude with print flag for non-interactive output
const pty = spawn('claude', ['-p'], { ... });

// or resume a session
const pty = spawn('claude', ['--resume'], { ... });
```

**the `-p` flag** makes claude emit response and exit — not quite headless, but usable for one-shot tasks.

**for persistent sessions**, we need PTY to keep the process alive and send multiple commands.

---

## can we send commands to active claude session?

**answer: yes, via PTY stdin**

when claude is in interactive mode, it reads from stdin:

```
╭─────────────────────────────────────────╮
│ ● Claude Code                           │
│ /help for commands, /exit to quit       │
╰─────────────────────────────────────────╯
> _
```

### the approach

```ts
// spawn with PTY
const pty = spawn('claude', ['--resume'], { ... });

// send command by write to stdin
pty.write('implement auth\n');

// read response from stdout
pty.onData((data) => {
  // parse and handle output
});
```

### challenges

| challenge | mitigation |
|-----------|------------|
| **output parse** | detect "done" via patterns (tool completion, prompt return) |
| **escape codes** | strip ANSI codes or use raw mode |
| **prompt detection** | detect `> ` prompt to know when ready for next command |
| **task boundaries** | track when one task ends and another can begin |

---

## session persistence

**claude has built-in session support:**

```sh
# resume most recent conversation
$ claude --resume

# conversations stored in
~/.claude/conversations/
```

### for khlone

```ts
// spawn with resume to continue session
const pty = spawn('claude', ['--resume', sessionId], { ... });
```

**note:** need to verify exact flag syntax for session selection.

---

## PTY vs stdin/stdout

**why PTY instead of simple pipes?**

| feature | stdin/stdout pipes | PTY |
|---------|-------------------|-----|
| terminal emulation | no | yes |
| escape codes | breaks | works |
| interactive prompts | breaks | works |
| attach/detach | no | yes (like tmux) |
| window size | no | yes (rows/cols) |

**PTY enables:**
- `khlone talk` → attach bidirectionally
- `khlone watch` → read-only stream
- proper terminal escape codes
- ctrl+c handler

---

## the daemon is a tmux-like PTY multiplexer

since `claude --headless` doesn't exist, the daemon serves as the **PTY owner** that enables attach/detach — exactly like tmux.

**the parallel:**

| tmux | khlone daemon |
|------|---------------|
| `tmux new-session -d` | daemon spawns claude in PTY |
| session runs headless | clone works without terminal attached |
| `tmux send-keys "cmd"` | daemon writes to PTY stdin |
| `tmux attach` | `khlone talk` |
| `ctrl+b d` (detach) | `/exit` in talk mode |
| `tmux capture-pane` | `khlone watch` (read-only stream) |
| `tmux kill-session` | clone shutdown |

**why not just use tmux?**

| option | pros | cons |
|--------|------|------|
| use tmux directly | mature, battle-tested | external dependency, shell out complexity |
| use node-pty | same PTY capability, native node | we control the interface |
| use screen | alternative to tmux | same issues as tmux |

**decision: node-pty**

node-pty gives us the same PTY ownership that tmux provides, but as a native node module. no shell-out, no parsing tmux output.

```ts
import { spawn } from 'node-pty';

// daemon spawns claude, owns the PTY
const pty = spawn('claude', ['--resume'], { ... });

// headless: daemon writes commands
pty.write('implement auth\n');

// talk mode: pipe PTY to user's terminal
process.stdin.pipe(pty);
pty.pipe(process.stdout);

// detach: unpipe, PTY continues
process.stdin.unpipe(pty);
pty.unpipe(process.stdout);
// claude still alive, daemon still owns PTY
```

**the daemon lifecycle:**

```
daemon start
├── spawn PTY with claude
├── listen on unix socket for commands
│
├── [headless mode]
│   ├── receive task via socket
│   ├── write to PTY stdin
│   └── stream PTY stdout to watchers
│
├── [talk mode]
│   ├── receive attach request via socket
│   ├── pipe user terminal ↔ PTY
│   └── on /exit: unpipe, return to headless
│
└── daemon stop
    └── kill PTY (claude exits)
```

---

## daemon scope: one daemon per zone, one PTY per clone

**decision:**
- **one daemon per zone** — the supervisor process
- **one PTY per clone** — each clone is a separate claude process

```
zone (@feat/auth)
└── daemon (pid: 1000)              ← one daemon
    └── clone supervisor
        ├── PTY: foreman.1 (pid: 1001)    ← one PTY per clone
        ├── PTY: mechanic.1 (pid: 1002)
        └── PTY: researcher.1 (pid: 1003)
```

**the daemon owns multiple PTYs:**

```ts
// daemon maintains clone → PTY map
const clonePtys = new Map<string, IPty>();

// enroll creates a new PTY for the clone
clonePtys.set('foreman.1', spawn('claude', ['--resume', 'foreman-session']));
clonePtys.set('mechanic.1', spawn('claude', ['--resume', 'mechanic-session']));

// commands route to the right PTY
const handleAct = (cloneSlug: string, task: Task) => {
  const pty = clonePtys.get(cloneSlug);
  pty.write(task.say + '\n');
};

// talk attaches user terminal to specific clone's PTY
const handleTalk = (cloneSlug: string) => {
  const pty = clonePtys.get(cloneSlug);
  process.stdin.pipe(pty);
  pty.pipe(process.stdout);
};
```

**like tmux server with multiple sessions:**

| tmux | khlone |
|------|--------|
| tmux server (1 per user) | daemon (1 per zone) |
| tmux session (N per server) | PTY (N per daemon, 1 per clone) |
| `tmux attach -t sess1` | `khlone talk --who foreman.1` |
| `tmux send -t sess2 "cmd"` | `khlone act "cmd" --who mechanic.1` |

**why this split:**

| scope | process | count | why |
|-------|---------|-------|-----|
| zone | daemon | 1 | single coordinator, single socket |
| clone | PTY (claude) | N | each clone is separate brain session |

**socket paths:**
```
# one socket per zone (daemon listens here)
/tmp/khlone-zone-{zone-id}.sock

# daemon routes to correct PTY internally
# no per-clone sockets needed
```

---

## integration architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     khlone daemon                           │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │            unix socket server                        │   │
│  │            /tmp/khlone-{zone}.sock                   │   │
│  │                                                      │   │
│  │  accepts connections from:                           │   │
│  │  - khlone act                                        │   │
│  │  - khlone ask                                        │   │
│  │  - khlone watch                                      │   │
│  │  - khlone status                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                           │                                 │
│                           ▼                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │            clone supervisor                          │   │
│  │                                                      │   │
│  │  for each enrolled clone:                            │   │
│  │  ┌─────────────────────────────────────────────┐    │   │
│  │  │ PTY process                                  │    │   │
│  │  │ ├── pid: 12345                               │    │   │
│  │  │ ├── stdin: writable                          │    │   │
│  │  │ ├── stdout: readable                         │    │   │
│  │  │ └── state: active | idle                     │    │   │
│  │  └─────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

---

## rhachet-brains-anthropic implementation

the BrainCli interface for Claude:

```ts
// rhachet-brains-anthropic/src/genBrainCli.ts

import { spawn as ptySpawn } from 'node-pty';

export const genBrainCli = () => {
  return {
    spawn: async (input: {
      sessionId: string;
      workdir: string;
    }): Promise<BrainCliProcess> => {
      // spawn claude with PTY
      const pty = ptySpawn('claude', ['--resume'], {
        name: 'xterm-256color',
        cols: 120,
        rows: 40,
        cwd: input.workdir,
        env: process.env,
      });

      // create process wrapper
      return {
        pid: pty.pid,

        send: async (input: { say: string }) => {
          pty.write(input.say + '\n');
        },

        output: async function* () {
          // yield parsed emissions from stdout
        },

        attach: async () => ({
          stdin: pty,
          stdout: pty,
        }),

        detach: async () => {
          // disconnect from terminal, keep process
        },

        await: async () => {
          // wait for task completion
        },

        isAlive: () => !pty.killed,

        kill: async () => {
          pty.kill();
        },
      };
    },
  };
};
```

---

## summary

| question | answer |
|----------|--------|
| **what is IPC?** | inter-process communication; khlone uses unix sockets |
| **use MCP?** | **no** — wrong direction, adds complexity, not designed for this |
| **claude --headless?** | doesn't exist; use PTY for persistent sessions |
| **send to active session?** | yes, write to PTY stdin |
| **session persistence?** | claude has `--resume`; stored in ~/.claude/ |
| **PTY vs pipes?** | PTY for terminal emulation, attach/detach |

**the stack:**
1. **unix socket** — khlone CLI ↔ daemon IPC
2. **PTY** — daemon ↔ claude process
3. **no MCP** — simpler, stable, correct direction

