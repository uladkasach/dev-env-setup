# khlone v0.0: PTY research

> what is a pseudo-terminal, why it exists, how it works

---

## what is a PTY?

**PTY = pseudo-terminal**

a pair of virtual character devices that provide a bidirectional communication channel.

```
┌─────────────────────────────────────────────────────────────┐
│                         PTY pair                            │
│                                                             │
│  ┌──────────────┐              ┌──────────────┐            │
│  │   PTM        │◄────────────►│   PTS        │            │
│  │   (manager)  │              │  (subsidiary)│            │
│  │              │              │              │            │
│  │  /dev/ptmx   │              │  /dev/pts/N  │            │
│  └──────────────┘              └──────────────┘            │
│        │                              │                     │
│        ▼                              ▼                     │
│   control process               shell/program               │
│   (terminal emulator,           (bash, claude,              │
│    tmux, ssh, etc)               vim, etc)                  │
└─────────────────────────────────────────────────────────────┘
```

**the two ends:**

| end | name | who uses it | device |
|-----|------|-------------|--------|
| **PTM** | manager (was: master) | terminal emulator, tmux, khlone daemon | /dev/ptmx |
| **PTS** | subsidiary (was: slave) | shell, programs | /dev/pts/N |

**note:** terminology updated in POSIX Issue 8 (2024) from master/slave to manager/subsidiary.

---

## why PTY exists

### the problem

real terminals (TTY) are physical devices — keyboards and screens. but we need:
- terminal emulators (xterm, gnome-terminal)
- remote sessions (ssh)
- terminal multiplexers (tmux, screen)
- programmatic terminal control (expect, khlone)

### the solution

PTY is a **software emulation** of a terminal that:
- looks like a real terminal to programs
- can be controlled by another program
- enables all the above use cases

```
without PTY:
  program ──────► physical terminal (hardware)

with PTY:
  program ──────► PTS ──────► PTM ──────► control program
                 (looks like terminal)   (terminal emulator)
```

---

## how PTY works

### step 1: open the manager

```c
// control program opens /dev/ptmx
int ptm = open("/dev/ptmx", O_RDWR | O_NOCTTY);

// this creates a new /dev/pts/N device
char *pts_path = ptsname(ptm);  // e.g., "/dev/pts/3"

// unlock the subsidiary
grantpt(ptm);
unlockpt(ptm);
```

### step 2: fork and connect subsidiary

```c
pid_t pid = fork();

if (pid == 0) {
    // child process

    // create new session (detach from parent terminal)
    setsid();

    // open the subsidiary
    int pts = open(pts_path, O_RDWR);

    // make it the control terminal
    ioctl(pts, TIOCSCTTY, 0);

    // redirect stdin/stdout/stderr
    dup2(pts, STDIN_FILENO);
    dup2(pts, STDOUT_FILENO);
    dup2(pts, STDERR_FILENO);

    // execute the target program
    execl("/bin/bash", "bash", NULL);
}
```

### step 3: bidirectional communication

```c
// in parent (control program)

// write to manager → appears as input on subsidiary
write(ptm, "ls -la\n", 7);

// read from manager → captures output from subsidiary
char buf[1024];
read(ptm, buf, sizeof(buf));
```

---

## what makes PTY special

### terminal semantics

the subsidiary end behaves **exactly like a real terminal**:

| feature | PTY provides |
|---------|-------------|
| line discipline | buffered input, line edit (backspace, etc) |
| signal generation | ctrl+c → SIGINT, ctrl+z → SIGTSTP |
| terminal modes | raw, cooked, echo, etc |
| window size | TIOCGWINSZ/TIOCSWINSZ ioctls |
| terminal escape codes | cursor movement, colors, etc |

### versus pipes

| feature | pipe | PTY |
|---------|------|-----|
| bidirectional | no (need two) | yes |
| terminal behavior | no | yes |
| line discipline | no | yes |
| signal generation | no | yes |
| isatty() returns | false | true |

**why this matters:**

many programs check `isatty()` and behave differently:
- `ls` — no colors without terminal
- `grep` — no colors without terminal
- interactive prompts — disabled without terminal

PTY makes these programs think they're on a real terminal.

---

## the data flow

```
┌─────────────────────────────────────────────────────────────┐
│                      PTY data flow                          │
│                                                             │
│  control program                           target program   │
│  (tmux, khlone)                            (bash, claude)   │
│       │                                          │          │
│       │  write("hello\n")                        │          │
│       ├─────────────►┐                           │          │
│       │              │                           │          │
│       │         ┌────▼────┐                      │          │
│       │         │   PTM   │                      │          │
│       │         │         │                      │          │
│       │         └────┬────┘                      │          │
│       │              │                           │          │
│       │         [line discipline]                │          │
│       │         [terminal process]               │          │
│       │              │                           │          │
│       │         ┌────▼────┐                      │          │
│       │         │   PTS   │                      │          │
│       │         │         │                      │          │
│       │         └────┬────┘                      │          │
│       │              │                           │          │
│       │              └───────────────────────────►          │
│       │                    stdin receives "hello\n"         │
│       │                                          │          │
│       │                    program writes output │          │
│       │              ┌───────────────────────────┤          │
│       │              │                           │          │
│       │         ┌────▼────┐                      │          │
│       │         │   PTS   │                      │          │
│       │         └────┬────┘                      │          │
│       │              │                           │          │
│       │         ┌────▼────┐                      │          │
│       │         │   PTM   │                      │          │
│       │         └────┬────┘                      │          │
│       │              │                           │          │
│       ◄──────────────┘                           │          │
│       │  read() returns output                   │          │
│       │                                          │          │
└─────────────────────────────────────────────────────────────┘
```

---

## UNIX 98 vs BSD PTY

### UNIX 98 (modern, use this)

```
/dev/ptmx          ← single entry point
/dev/pts/0         ← dynamically created
/dev/pts/1
/dev/pts/N
```

- open /dev/ptmx → get new manager
- subsidiary auto-created in /dev/pts/
- no name conflicts
- kernel manages allocation

### BSD (deprecated since Linux 2.6.4)

```
/dev/ptyp0 ← manager    /dev/ttyp0 ← subsidiary
/dev/ptyp1              /dev/ttyp1
...                     ...
```

- fixed number of devices
- must search for unused pair
- name conflicts possible

---

## kernel limits

```bash
# current usage
cat /proc/sys/kernel/pty/nr

# maximum allowed
cat /proc/sys/kernel/pty/max

# typically 4096, adjustable
echo 8192 > /proc/sys/kernel/pty/max
```

---

## PTY in node.js (node-pty)

```ts
import { spawn } from 'node-pty';

// spawn creates PTY pair and forks
const pty = spawn('bash', [], {
  name: 'xterm-256color',
  cols: 80,
  rows: 24,
  cwd: process.env.HOME,
  env: process.env,
});

// write to manager → input to bash
pty.write('echo hello\n');

// read from manager → output from bash
pty.onData((data) => {
  console.log(data);
});

// resize terminal
pty.resize(120, 40);

// terminate
pty.kill();
```

---

## why khlone needs PTY

| requirement | why PTY solves it |
|-------------|-------------------|
| claude needs terminal | `isatty()` returns true |
| interactive prompts | terminal semantics |
| escape codes (colors) | terminal handler |
| ctrl+c handler | signal generation |
| attach/detach | manager stays open |
| window resize | TIOCSWINSZ ioctl |

**the key insight:**

the program on the subsidiary (claude) doesn't know it's not a real terminal. it behaves exactly as if a human were at a keyboard.

meanwhile, the manager (khlone daemon) can:
- send commands programmatically
- capture output
- stay attached when user detaches
- reattach user later

---

## summary

| term | definition |
|------|------------|
| **PTY** | pseudo-terminal — software terminal emulation |
| **PTM** | manager end — held by control program |
| **PTS** | subsidiary end — used by target program |
| **/dev/ptmx** | entry point to create new PTY pair |
| **/dev/pts/N** | subsidiary device for PTY N |
| **line discipline** | kernel layer for terminal handler |

**sources:**
- [pty(7) - Linux manual page](https://man7.org/linux/man-pages/man7/pty.7.html)
- [Pseudoterminal - Wikipedia](https://en.wikipedia.org/wiki/Pseudoterminal)
- [The Elegant Architecture of PTYs](https://medium.com/@krithikanithyanandam/the-elegant-architecture-of-ptys-behind-your-terminal-a-quick-byte-b724a50a98b4)
