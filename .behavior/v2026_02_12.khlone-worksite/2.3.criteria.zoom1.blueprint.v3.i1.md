# khlone v0.0: process management blueprint v3 (zoom1)

> how khlone spawns, supervises, and attaches to brain processes
> resolves gaps identified in v2 blueprint

---

## changes from v2

| gap | v2 assumption | v3 resolution |
|-----|---------------|---------------|
| gap.1 | subprocess model only | BrainCli + BrainSdk dual interface |
| gap.2 | khlone generates session IDs | brain generates, khlone tracks |
| gap.3 | event schema unspecified | each adapter translates to canonical BrainCliEvent |
| gap.4 | PTY spawn failure unspecified | pre-flight checks + structured errors |
| gap.5 | checkpoint restoration unclear | transcript-based resume + state hash |
| gap.6 | JSON-RPC errors unspecified | full error code table |
| gap.7 | hook failure unspecified | warn + continue, 60s timeout |
| gap.8 | rate limiter in-memory only | shared file-based semaphore |
| gap.9 | hardcoded adapters | rhachet-based discovery |
| gap.10 | spawn race condition | flock before fork |
| gap.11 | watch cleanup unspecified | connection timeout + max watchers |
| gap.12 | skill expansion simple | skill types: prompt, executable, parameterized |
| gap.13 | PTY buffer unspecified | circular buffer with backpressure |
| gap.14 | session cleanup unspecified | 30-day retention, cleanup on zone delete |
| gap.15 | task limits unspecified | configurable limits in khlone.yml |
| gap.16 | output sanitization unspecified | strip ANSI, redact secrets, 1MB max |
| gap.17 | cross-site coordination unclear | orchestrator daemon + site registry |
| gap.18 | auth state unspecified | pre-flight auth check + clear errors |
| gap.19 | cancellation state unclear | cancelled status + partial artifacts |
| gap.20 | socket permissions unspecified | 0600, hash-based short paths |

---

## BrainAdapter interface (replaces BrainCli)

### dual mode: CLI and SDK

the v2 BrainCli assumed subprocess-only. v3 introduces BrainAdapter that supports both:

```ts
// rhachet-brains-*/src/types.ts

/**
 * .what = unified interface for brain interaction
 * .why = abstracts CLI vs SDK implementation details
 */
interface BrainAdapter {
  /** adapter metadata */
  readonly meta: BrainAdapterMeta;

  /** check if brain is available and authenticated */
  preflight(): Promise<PreflightResult>;

  /** run a task, return result (task mode) */
  run(input: RunInput): Promise<RunResult>;

  /** run a task with event stream (watch mode) */
  stream(input: RunInput): AsyncIterable<BrainEvent>;

  /** spawn interactive session (talk mode) */
  spawn(input: SpawnInput): Promise<BrainSession>;
}

interface BrainAdapterMeta {
  /** adapter package name */
  package: string;
  /** brain identifier (e.g., 'anthropic/claude/code/opus/v4.5') */
  brain: string;
  /** implementation mode */
  mode: 'cli' | 'sdk' | 'hybrid';
  /** required authentication method */
  auth: 'cli-login' | 'api-key' | 'oauth' | 'none';
}

interface PreflightResult {
  available: boolean;
  authenticated: boolean;
  version?: string;
  error?: PreflightError;
}

interface PreflightError {
  code: 'NOT_INSTALLED' | 'NOT_AUTHENTICATED' | 'VERSION_MISMATCH' | 'UNKNOWN';
  message: string;
  fix?: string; // e.g., "run `claude login` to authenticate"
}
```

### input and output types

```ts
interface RunInput {
  /** the task prompt */
  prompt: string;
  /** work directory */
  workdir: string;
  /** session to resume (optional — brain generates new if absent) */
  sessionId?: string;
  /** tools to allow (optional) */
  allowedTools?: string[];
  /** timeout in ms (default: 300000 = 5min) */
  timeout?: number;
}

interface RunResult {
  /** task output */
  result: string;
  /** session ID (brain-generated or resumed) */
  sessionId: string;
  /** token usage */
  usage: TokenUsage;
  /** cost in USD */
  cost: number;
  /** duration in seconds */
  durationSeconds: number;
}

interface TokenUsage {
  inputTokens: number;
  outputTokens: number;
  cacheReadTokens?: number;
  cacheWriteTokens?: number;
}
```

### event stream types

```ts
/**
 * .what = canonical event type for brain output
 * .why = each adapter translates brain-specific events to this format
 */
interface BrainEvent {
  /** event type */
  type: BrainEventType;
  /** timestamp */
  timestamp: string;
  /** event-specific payload */
  payload: BrainEventPayload;
}

type BrainEventType =
  | 'message'        // assistant text output
  | 'tool_call'      // tool invocation started
  | 'tool_result'    // tool invocation completed
  | 'progress'       // progress indicator
  | 'error'          // error occurred
  | 'complete';      // task completed

type BrainEventPayload =
  | { type: 'message'; content: string; partial: boolean }
  | { type: 'tool_call'; name: string; input: Record<string, unknown> }
  | { type: 'tool_result'; name: string; output: string; success: boolean }
  | { type: 'progress'; percent?: number; stage?: string }
  | { type: 'error'; code: string; message: string }
  | { type: 'complete'; sessionId: string; usage: TokenUsage; cost: number };
```

### spawn session types

```ts
interface SpawnInput {
  /** work directory */
  workdir: string;
  /** session to resume (optional) */
  sessionId?: string;
  /** terminal dimensions */
  cols?: number;
  rows?: number;
}

interface BrainSession {
  /** process ID */
  pid: number;
  /** session ID (brain-generated or resumed) */
  sessionId: string;
  /** write to session stdin */
  write(data: string): void;
  /** subscribe to session output */
  onData(callback: (data: string) => void): void;
  /** resize terminal */
  resize(cols: number, rows: number): void;
  /** terminate session */
  kill(): void;
  /** check if session is alive */
  isAlive(): boolean;
}
```

---

## adapter translation layer

### event translation

each adapter translates brain-specific events to canonical BrainEvent:

```ts
// rhachet-brains-anthropic/src/stream.ts

const translateClaudeEvent = (raw: ClaudeStreamEvent): BrainEvent => {
  const timestamp = new Date().toISOString();

  switch (raw.type) {
    case 'assistant':
      return {
        type: 'message',
        timestamp,
        payload: { type: 'message', content: raw.content, partial: true },
      };

    case 'tool_use':
      return {
        type: 'tool_call',
        timestamp,
        payload: { type: 'tool_call', name: raw.name, input: raw.input },
      };

    case 'tool_result':
      return {
        type: 'tool_result',
        timestamp,
        payload: { type: 'tool_result', name: raw.name, output: raw.content, success: true },
      };

    case 'result':
      return {
        type: 'complete',
        timestamp,
        payload: {
          type: 'complete',
          sessionId: raw.session_id,
          usage: {
            inputTokens: raw.usage.input_tokens,
            outputTokens: raw.usage.output_tokens,
          },
          cost: raw.cost,
        },
      };

    default:
      // unknown event type — emit as progress
      return {
        type: 'progress',
        timestamp,
        payload: { type: 'progress', stage: `unknown: ${raw.type}` },
      };
  }
};
```

```ts
// rhachet-brains-opencode/src/stream.ts

const translateOpencodeEvent = (raw: OpencodeStreamEvent): BrainEvent => {
  const timestamp = new Date().toISOString();

  switch (raw.event) {
    case 'message':
      return {
        type: 'message',
        timestamp,
        payload: { type: 'message', content: raw.content, partial: true },
      };

    case 'tool':
      return {
        type: 'tool_call',
        timestamp,
        payload: { type: 'tool_call', name: raw.name, input: { path: raw.path } },
      };

    case 'complete':
      return {
        type: 'complete',
        timestamp,
        payload: {
          type: 'complete',
          sessionId: raw.session,
          usage: {
            inputTokens: raw.tokens.input,
            outputTokens: raw.tokens.output,
          },
          cost: raw.cost_usd,
        },
      };

    default:
      return {
        type: 'progress',
        timestamp,
        payload: { type: 'progress', stage: `unknown: ${raw.event}` },
      };
  }
};
```

---

## session ID semantics

### brain generates, khlone tracks

v2 assumed khlone generates UUIDs. v3 lets brain generate and khlone tracks:

```ts
// first task — no sessionId provided
const first = await brainAdapter.run({
  prompt: 'implement auth',
  workdir: zone.path,
  // sessionId: undefined — brain generates new
});
// first.sessionId = brain-generated ID

// store in clone state
await updateCloneState(clone, { sessionId: first.sessionId });

// subsequent task — resume session
const second = await brainAdapter.run({
  prompt: 'add tests',
  workdir: zone.path,
  sessionId: first.sessionId, // resume
});
```

### session ID validation

each adapter validates session format:

```ts
// rhachet-brains-anthropic/src/validate.ts

const isValidClaudeSessionId = (id: string): boolean => {
  // claude uses UUID format
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id);
};

// rhachet-brains-opencode/src/validate.ts

const isValidOpencodeSessionId = (id: string): boolean => {
  // opencode uses shorter IDs
  return /^[a-z0-9]{12,32}$/i.test(id);
};
```

---

## pre-flight checks

### check before spawn

```ts
// khlone/src/domain.operations/clone/spawnClone.ts

const spawnClone = async (input: SpawnCloneInput, context: Context): Promise<Clone> => {
  // resolve adapter
  const adapter = await resolveAdapter({ brain: input.brain });

  // pre-flight check
  const preflight = await adapter.preflight();

  if (!preflight.available) {
    throw new BrainNotAvailableError({
      brain: input.brain,
      code: preflight.error?.code ?? 'UNKNOWN',
      message: preflight.error?.message ?? 'brain not available',
      fix: preflight.error?.fix,
    });
  }

  if (!preflight.authenticated) {
    throw new BrainNotAuthenticatedError({
      brain: input.brain,
      code: 'NOT_AUTHENTICATED',
      message: preflight.error?.message ?? 'brain not authenticated',
      fix: preflight.error?.fix ?? 'run authentication command for this brain',
    });
  }

  // proceed with spawn
  // ...
};
```

### adapter-specific pre-flight

```ts
// rhachet-brains-anthropic/src/preflight.ts

export const preflight = async (): Promise<PreflightResult> => {
  // check if claude CLI is installed
  try {
    const { stdout } = await exec('claude --version');
    const version = parseVersion(stdout);

    // check if authenticated
    try {
      const { stdout: status } = await exec('claude auth status');
      const authenticated = status.includes('authenticated');

      return {
        available: true,
        authenticated,
        version,
        error: authenticated ? undefined : {
          code: 'NOT_AUTHENTICATED',
          message: 'claude CLI is not authenticated',
          fix: 'run `claude login` to authenticate',
        },
      };
    } catch {
      return {
        available: true,
        authenticated: false,
        version,
        error: {
          code: 'NOT_AUTHENTICATED',
          message: 'could not verify authentication status',
          fix: 'run `claude login` to authenticate',
        },
      };
    }
  } catch (error) {
    return {
      available: false,
      authenticated: false,
      error: {
        code: 'NOT_INSTALLED',
        message: 'claude CLI is not installed',
        fix: 'install claude CLI: npm install -g @anthropic-ai/claude-code',
      },
    };
  }
};
```

---

## checkpoint and resume

### transcript-based resume

v2 checkpointed tool call index. v3 stores full transcript + state hash:

```ts
interface Checkpoint {
  taskId: string;
  sessionId: string;
  prompt: string;
  timestamp: string;

  /** full transcript of events so far */
  transcript: BrainEvent[];

  /** hash of workspace state at checkpoint */
  workspaceHash: string;

  /** last successful tool call index */
  lastToolCallIndex: number;
}
```

### workspace state hash

detect if workspace changed after crash:

```ts
// khlone/src/daemon/checkpoint.ts

const computeWorkspaceHash = async (workdir: string): Promise<string> => {
  // hash of git state
  const { stdout: gitStatus } = await exec('git status --porcelain', { cwd: workdir });
  const { stdout: gitHead } = await exec('git rev-parse HEAD', { cwd: workdir });

  return sha256(`${gitHead}:${gitStatus}`);
};

const checkStateIntegrity = async (checkpoint: Checkpoint, workdir: string): Promise<boolean> => {
  const currentHash = await computeWorkspaceHash(workdir);
  return currentHash === checkpoint.workspaceHash;
};
```

### resume prompt construction

```ts
const constructResumePrompt = async (checkpoint: Checkpoint, workdir: string): Promise<string> => {
  const stateMatch = await checkStateIntegrity(checkpoint, workdir);

  // summarize what happened
  const toolCalls = checkpoint.transcript
    .filter((e) => e.type === 'tool_call')
    .map((e) => `- ${e.payload.name}`)
    .join('\n');

  const lastMessage = checkpoint.transcript
    .filter((e) => e.type === 'message')
    .pop()?.payload.content ?? '';

  let prompt = `[RESUME] Previous session was interrupted.

Session ID: ${checkpoint.sessionId}
Original task: ${checkpoint.prompt}

Tool calls completed (${checkpoint.lastToolCallIndex}):
${toolCalls}

Your last output:
${lastMessage.slice(0, 500)}${lastMessage.length > 500 ? '...' : ''}
`;

  if (!stateMatch) {
    prompt += `
⚠️ ALERT: Workspace state has changed since the interruption.
Please verify the current state before you continue.
`;
  }

  prompt += `
Continue from where you left off.`;

  return prompt;
};
```

---

## IPC protocol: error codes

### full error code table

```ts
// khlone/src/daemon/ipcErrors.ts

const IPC_ERRORS = {
  // JSON-RPC standard errors (-32700 to -32600)
  PARSE_ERROR: { code: -32700, message: 'Parse error' },
  INVALID_REQUEST: { code: -32600, message: 'Invalid Request' },
  METHOD_NOT_FOUND: { code: -32601, message: 'Method not found' },
  INVALID_PARAMS: { code: -32602, message: 'Invalid params' },
  INTERNAL_ERROR: { code: -32603, message: 'Internal error' },

  // khlone-specific errors (-32001 to -32099)
  CLONE_BUSY: { code: -32001, message: 'Clone is busy (attached)' },
  CLONE_NOT_FOUND: { code: -32002, message: 'Clone not found' },
  TASK_NOT_FOUND: { code: -32003, message: 'Task not found' },
  ZONE_NOT_FOUND: { code: -32004, message: 'Zone not found' },
  SITE_NOT_FOUND: { code: -32005, message: 'Site not found' },
  BRAIN_NOT_AVAILABLE: { code: -32006, message: 'Brain not available' },
  BRAIN_NOT_AUTHENTICATED: { code: -32007, message: 'Brain not authenticated' },
  QUEUE_FULL: { code: -32008, message: 'Task queue is full' },
  MAX_CLONES_REACHED: { code: -32009, message: 'Max clones reached' },
  SKILL_NOT_FOUND: { code: -32010, message: 'Skill not found' },
  SKILL_AMBIGUOUS: { code: -32011, message: 'Skill ambiguous (multiple roles)' },
  TIMEOUT: { code: -32012, message: 'Request timeout' },
  SESSION_EXPIRED: { code: -32013, message: 'Session expired' },
} as const;
```

### request timeout

```ts
// khlone/src/daemon/ipcServer.ts

const REQUEST_TIMEOUT_MS = 30_000; // 30 seconds for most operations
const AWAIT_TIMEOUT_MS = 600_000;  // 10 minutes for await (task completion)

const handleRequest = async (request: JsonRpcRequest): Promise<JsonRpcResponse> => {
  const timeout = request.method === 'await' ? AWAIT_TIMEOUT_MS : REQUEST_TIMEOUT_MS;

  try {
    const result = await withTimeout(
      processRequest(request),
      timeout,
    );
    return { jsonrpc: '2.0', result, id: request.id };
  } catch (error) {
    if (error instanceof TimeoutError) {
      return {
        jsonrpc: '2.0',
        error: IPC_ERRORS.TIMEOUT,
        id: request.id,
      };
    }
    throw error;
  }
};
```

---

## hook failure semantics

### warn and continue

```ts
// khlone/src/daemon/hooks.ts

const HOOK_TIMEOUT_MS = 60_000; // 60 seconds per hook

const runOnStopHooks = async (
  task: Task,
  result: RunResult,
  adapter: BrainAdapter,
  context: Context,
): Promise<HookResults> => {
  const hooks = context.siteConfig.crew.hooks?.onStop ?? [];
  const results: HookResults = { artifacts: {}, errors: [] };

  for (const hook of hooks) {
    try {
      const hookResult = await withTimeout(
        adapter.run({
          prompt: hook.prompt,
          workdir: task.workdir,
          sessionId: result.sessionId,
        }),
        HOOK_TIMEOUT_MS,
      );

      // sanitize and store artifact
      const sanitized = sanitizeOutput(hookResult.result);
      results.artifacts[hook.artifact] = sanitized;

    } catch (error) {
      // log and continue to next hook
      context.log.warn('hook failed', {
        hookArtifact: hook.artifact,
        error: error.message,
      });
      results.errors.push({
        artifact: hook.artifact,
        error: error.message,
      });
    }
  }

  return results;
};
```

---

## rate limiter: shared state

### file-based semaphore

```ts
// khlone/src/daemon/rateLimiter.ts

const RATE_LIMIT_DIR = `${os.homedir()}/.khlone/rate-limits`;

interface RateLimitState {
  current: number;
  max: number;
  queue: number;
  updatedAt: string;
}

const acquireSlot = async (apiKey: string): Promise<void> => {
  const lockFile = `${RATE_LIMIT_DIR}/${sha256(apiKey)}.lock`;
  const stateFile = `${RATE_LIMIT_DIR}/${sha256(apiKey)}.json`;

  // acquire file lock
  const fd = await fs.open(lockFile, 'w');
  await flock(fd, LOCK_EX);

  try {
    // read current state
    const state = await readState(stateFile);

    if (state.current >= state.max) {
      // wait in queue
      state.queue++;
      await writeState(stateFile, state);

      // release lock, wait, retry
      await flock(fd, LOCK_UN);
      await fd.close();

      await sleep(1000);
      return acquireSlot(apiKey);
    }

    // acquire slot
    state.current++;
    state.updatedAt = new Date().toISOString();
    await writeState(stateFile, state);

  } finally {
    await flock(fd, LOCK_UN);
    await fd.close();
  }
};

const releaseSlot = async (apiKey: string): Promise<void> => {
  const lockFile = `${RATE_LIMIT_DIR}/${sha256(apiKey)}.lock`;
  const stateFile = `${RATE_LIMIT_DIR}/${sha256(apiKey)}.json`;

  const fd = await fs.open(lockFile, 'w');
  await flock(fd, LOCK_EX);

  try {
    const state = await readState(stateFile);
    state.current = Math.max(0, state.current - 1);
    state.updatedAt = new Date().toISOString();
    await writeState(stateFile, state);
  } finally {
    await flock(fd, LOCK_UN);
    await fd.close();
  }
};
```

---

## adapter discovery via rhachet

### dynamic resolution

```ts
// khlone/src/domain.operations/clone/resolveAdapter.ts

/**
 * .what = resolve brain reference to BrainAdapter
 * .why = decouple khlone from specific brain packages
 */
const resolveAdapter = async (input: { brain: string }): Promise<BrainAdapter> => {
  // ask rhachet for available brains
  const availableBrains = await rhachet.getAvailableBrains();

  // find matched brain
  const brainMeta = availableBrains.find((b) => b.slug === input.brain);
  if (!brainMeta) {
    throw new BadRequestError(`unknown brain: ${input.brain}`, {
      available: availableBrains.map((b) => b.slug),
    });
  }

  // dynamic import of adapter package
  try {
    const adapter = await import(brainMeta.package);
    return adapter.genBrainAdapter();
  } catch (error) {
    throw new BadRequestError(`brain adapter not installed: ${brainMeta.package}`, {
      brain: input.brain,
      package: brainMeta.package,
      fix: `run: npm install ${brainMeta.package}`,
    });
  }
};
```

### rhachet brain registry

```ts
// rhachet/src/brains/registry.ts

interface BrainMeta {
  slug: string;              // 'anthropic/claude/code/opus/v4.5'
  package: string;           // 'rhachet-brains-anthropic'
  name: string;              // 'Claude Code Opus'
  mode: 'cli' | 'sdk';
  auth: 'cli-login' | 'api-key';
}

const BRAIN_REGISTRY: BrainMeta[] = [
  {
    slug: 'anthropic/claude/code/opus/v4.5',
    package: 'rhachet-brains-anthropic',
    name: 'Claude Code Opus',
    mode: 'cli',
    auth: 'cli-login',
  },
  {
    slug: 'anthropic/claude/code/sonnet/v4',
    package: 'rhachet-brains-anthropic',
    name: 'Claude Code Sonnet',
    mode: 'cli',
    auth: 'cli-login',
  },
  {
    slug: 'opencode/opencode/v1',
    package: 'rhachet-brains-opencode',
    name: 'OpenCode',
    mode: 'cli',
    auth: 'api-key',
  },
];

export const getAvailableBrains = (): BrainMeta[] => BRAIN_REGISTRY;
```

---

## daemon spawn: atomic with flock

### flock before fork

```ts
// khlone/src/daemon/ensureDaemon.ts

const ensureDaemon = async (zone: Zone): Promise<DaemonConnection> => {
  const pidFile = `${zone.path}/.khlone/daemon.pid`;
  const socketPath = getDaemonSocketPath(zone);

  // try to connect to found daemon
  const conn = await tryConnect(socketPath);
  if (conn) return conn;

  // no daemon — acquire spawn lock
  const lockFile = `${zone.path}/.khlone/daemon.spawn.lock`;
  const lockFd = await fs.open(lockFile, 'w');

  try {
    // non-block lock attempt
    const locked = await tryFlock(lockFd, LOCK_EX | LOCK_NB);

    if (!locked) {
      // another process spawns now — wait and retry
      await lockFd.close();
      await sleep(500);
      return ensureDaemon(zone);
    }

    // we hold the lock — spawn daemon
    const daemon = fork(DAEMON_SCRIPT, [], {
      cwd: zone.path,
      detached: true,
      stdio: 'ignore',
    });

    daemon.unref();

    // write pid file
    await fs.writeFile(pidFile, String(daemon.pid));

    // wait for socket to appear
    await waitForSocket(socketPath, 5000);

    // connect
    return await connect(socketPath);

  } finally {
    await flock(lockFd, LOCK_UN);
    await lockFd.close();
  }
};
```

---

## watch mode: cleanup

### connection timeout and max watchers

```ts
// khlone/src/daemon/watchManager.ts

const MAX_WATCHERS_PER_CLONE = 10;
const WATCHER_TIMEOUT_MS = 60_000; // 60 seconds no activity = stale

interface WatcherState {
  clientId: string;
  lastActivity: number;
}

class WatchManager {
  private watchers = new Map<string, Map<string, WatcherState>>();
  private cleanupInterval: NodeJS.Timer;

  constructor() {
    // cleanup stale watchers every 30s
    this.cleanupInterval = setInterval(() => this.cleanupStale(), 30_000);
  }

  subscribe(cloneSlug: string, clientId: string): void {
    const cloneWatchers = this.watchers.get(cloneSlug) ?? new Map();

    if (cloneWatchers.size >= MAX_WATCHERS_PER_CLONE) {
      throw new Error('max watchers reached for clone');
    }

    cloneWatchers.set(clientId, {
      clientId,
      lastActivity: Date.now(),
    });

    this.watchers.set(cloneSlug, cloneWatchers);
  }

  heartbeat(cloneSlug: string, clientId: string): void {
    const watcher = this.watchers.get(cloneSlug)?.get(clientId);
    if (watcher) {
      watcher.lastActivity = Date.now();
    }
  }

  unsubscribe(cloneSlug: string, clientId: string): void {
    this.watchers.get(cloneSlug)?.delete(clientId);
  }

  private cleanupStale(): void {
    const now = Date.now();

    for (const [cloneSlug, cloneWatchers] of this.watchers) {
      for (const [clientId, watcher] of cloneWatchers) {
        if (now - watcher.lastActivity > WATCHER_TIMEOUT_MS) {
          cloneWatchers.delete(clientId);
        }
      }
    }
  }
}
```

---

## skill expansion: types

### skill types

```ts
// rhachet/src/skills/types.ts

type Skill = PromptSkill | ExecutableSkill | ParameterizedSkill;

interface PromptSkill {
  type: 'prompt';
  slug: string;
  role: string;
  prompt: string;
}

interface ExecutableSkill {
  type: 'executable';
  slug: string;
  role: string;
  command: string;
  args?: string[];
}

interface ParameterizedSkill {
  type: 'parameterized';
  slug: string;
  role: string;
  template: string;
  params: SkillParam[];
}

interface SkillParam {
  name: string;
  type: 'string' | 'number' | 'boolean';
  required: boolean;
  default?: unknown;
}
```

### skill expansion

```ts
// khlone/src/domain.operations/skill/expandSkill.ts

const expandSkill = async (
  skill: Skill,
  params?: Record<string, unknown>,
): Promise<ExpandedSkill> => {
  switch (skill.type) {
    case 'prompt':
      return {
        type: 'prompt',
        prompt: skill.prompt,
      };

    case 'executable':
      return {
        type: 'executable',
        command: skill.command,
        args: skill.args ?? [],
      };

    case 'parameterized':
      // validate and apply params
      const validated = validateParams(skill.params, params ?? {});
      const prompt = applyTemplate(skill.template, validated);
      return {
        type: 'prompt',
        prompt,
      };
  }
};

const applyTemplate = (template: string, params: Record<string, unknown>): string => {
  return template.replace(/\{\{(\w+)\}\}/g, (_, key) => {
    return String(params[key] ?? '');
  });
};
```

---

## resource limits

### configurable in khlone.yml

```yaml
# khlone.yml
zone:
  host: local

  limits:
    maxQueueDepth: 100       # max tasks per clone queue
    maxClonesPerZone: 10     # max clones per zone
    maxWatchersPerClone: 10  # max watchers per clone
    taskTimeoutMs: 300000    # 5 minutes default
    hookTimeoutMs: 60000     # 1 minute for hooks

crew:
  hero:
    role: foreman
    brain: claude
  # ...
```

### limit enforcement

```ts
// khlone/src/daemon/limits.ts

const enforceLimits = (siteConfig: SiteConfig) => {
  const limits = siteConfig.zone?.limits ?? DEFAULT_LIMITS;

  return {
    checkQueueDepth: (clone: Clone) => {
      if (clone.queue.length >= limits.maxQueueDepth) {
        throw new IpcError(IPC_ERRORS.QUEUE_FULL);
      }
    },

    checkCloneCount: (zone: Zone) => {
      if (zone.clones.length >= limits.maxClonesPerZone) {
        throw new IpcError(IPC_ERRORS.MAX_CLONES_REACHED);
      }
    },

    getTaskTimeout: () => limits.taskTimeoutMs,
    getHookTimeout: () => limits.hookTimeoutMs,
  };
};

const DEFAULT_LIMITS = {
  maxQueueDepth: 100,
  maxClonesPerZone: 10,
  maxWatchersPerClone: 10,
  taskTimeoutMs: 300_000,
  hookTimeoutMs: 60_000,
};
```

---

## output sanitization

### strip ANSI, redact secrets, limit size

```ts
// khlone/src/daemon/sanitize.ts

const MAX_ARTIFACT_SIZE = 1_000_000; // 1MB

const sanitizeOutput = (output: string): string => {
  let sanitized = output;

  // strip ANSI escape codes
  sanitized = stripAnsi(sanitized);

  // redact common secret patterns
  sanitized = redactSecrets(sanitized);

  // truncate if too large
  if (sanitized.length > MAX_ARTIFACT_SIZE) {
    sanitized = sanitized.slice(0, MAX_ARTIFACT_SIZE) + '\n[truncated]';
  }

  return sanitized;
};

const SECRET_PATTERNS = [
  /(?:api[_-]?key|apikey|secret|password|token|auth)[=:]\s*['"]?[a-zA-Z0-9_\-]{20,}['"]?/gi,
  /Bearer\s+[a-zA-Z0-9_\-\.]+/gi,
  /sk-[a-zA-Z0-9]{20,}/g, // OpenAI keys
  /anthropic[_-]?key[=:]\s*['"]?[a-zA-Z0-9_\-]+['"]?/gi,
];

const redactSecrets = (text: string): string => {
  let redacted = text;
  for (const pattern of SECRET_PATTERNS) {
    redacted = redacted.replace(pattern, '[REDACTED]');
  }
  return redacted;
};
```

---

## cross-site coordination

### orchestrator daemon

```
~/.khlone/orchestrator/
├── orchestrator.yml     # global config
├── orchestrator.pid     # orchestrator daemon pid
├── orchestrator.sock    # orchestrator IPC socket
└── sites/
    ├── ahbode--svc-jobs.yml    # site reference
    └── ehmpathy--myrepo.yml    # site reference
```

### site registry

```yaml
# ~/.khlone/orchestrator/sites/ahbode--svc-jobs.yml
slug: ahbode/svc-jobs
path: /home/user/git/ahbode/svc-jobs
registeredAt: 2025-02-14T10:30:00Z
lastAccessedAt: 2025-02-14T12:45:00Z
```

### cross-site dispatch

```ts
// khlone/src/domain.operations/dispatch/dispatchCrossSite.ts

const dispatchCrossSite = async (
  input: DispatchInput,
  context: Context,
): Promise<DispatchResult> => {
  // resolve site
  const siteRef = await resolveSiteRef(input.site);

  if (!siteRef) {
    throw new IpcError(IPC_ERRORS.SITE_NOT_FOUND);
  }

  // ensure site daemon is alive
  const siteDaemon = await ensureSiteDaemon(siteRef);

  // forward dispatch to site daemon
  return siteDaemon.call('enqueue', {
    zone: input.zone,
    type: input.type,
    prompt: input.prompt,
    who: input.who,
    when: input.when,
  });
};
```

### site discovery

sites are registered on first `khlone` command in a repo:

```ts
// khlone/src/domain.operations/site/registerSite.ts

const registerSite = async (input: { gitRoot: string }): Promise<void> => {
  const { org, repo } = parseGitRemote(input.gitRoot);
  const slug = `${org}/${repo}`;
  const safeSlug = slug.replace('/', '--');

  const registryPath = `${os.homedir()}/.khlone/orchestrator/sites/${safeSlug}.yml`;

  await fs.writeFile(registryPath, yaml.stringify({
    slug,
    path: input.gitRoot,
    registeredAt: new Date().toISOString(),
    lastAccessedAt: new Date().toISOString(),
  }));
};
```

---

## task cancellation

### cancelled status

```ts
type TaskStatus = 'queued' | 'active' | 'done' | 'failed' | 'cancelled';

interface CancelledTask {
  status: 'cancelled';
  cancelledAt: string;
  partialArtifacts?: Record<string, string>;
  checkpoint?: Checkpoint;
}
```

### cancellation flow

```ts
// khlone/src/daemon/taskProcessor.ts

const cancelTask = async (taskId: string): Promise<void> => {
  const task = await getTask(taskId);

  if (task.status === 'queued') {
    // simple removal from queue
    await updateTask(taskId, {
      status: 'cancelled',
      cancelledAt: new Date().toISOString(),
    });
    return;
  }

  if (task.status === 'active') {
    // create checkpoint before cancel
    const checkpoint = await createCheckpoint(task);

    // signal brain to stop
    task.brainSession?.kill();

    // capture partial artifacts if any
    const partialArtifacts = await capturePartialArtifacts(task);

    await updateTask(taskId, {
      status: 'cancelled',
      cancelledAt: new Date().toISOString(),
      checkpoint,
      partialArtifacts,
    });
  }
};
```

### resume cancelled task

```ts
// khlone/src/contract/cli/resume.ts

// khlone resume task-abc-123
const resumeTask = async (taskId: string): Promise<void> => {
  const task = await getTask(taskId);

  if (task.status !== 'cancelled') {
    throw new BadRequestError('task is not cancelled');
  }

  if (!task.checkpoint) {
    throw new BadRequestError('task has no checkpoint to resume from');
  }

  // create new task from checkpoint
  await enqueueTask({
    type: task.type,
    prompt: constructResumePrompt(task.checkpoint, task.workdir),
    clone: task.clone,
    priority: 'front', // prioritize resumed task
  });
};
```

---

## socket permissions

### secure defaults

```ts
// khlone/src/daemon/socket.ts

const createSocket = async (zone: Zone): Promise<string> => {
  const socketDir = `${zone.path}/.khlone`;
  const socketPath = getSocketPath(zone);

  // ensure directory exists with secure permissions
  await fs.mkdir(socketDir, { recursive: true, mode: 0o700 });

  // create socket with 0600 (owner read/write only)
  const server = net.createServer();
  server.listen(socketPath);

  // set socket permissions
  await fs.chmod(socketPath, 0o600);

  return socketPath;
};
```

### short socket paths

unix sockets have 108 character limit. use hash for long paths:

```ts
const getSocketPath = (zone: Zone): string => {
  const basePath = `${zone.path}/.khlone/daemon.sock`;

  if (basePath.length <= 100) {
    return basePath;
  }

  // use hash-based path in tmp
  const hash = sha256(zone.path).slice(0, 16);
  return `/tmp/khlone-${hash}.sock`;
};
```

### cleanup on exit

```ts
// khlone/src/daemon/daemonMain.ts

const cleanup = async (): Promise<void> => {
  // remove socket
  await fs.unlink(socketPath).catch(() => {});

  // remove pidfile
  await fs.unlink(pidFile).catch(() => {});

  // remove heartbeat
  await fs.unlink(heartbeatFile).catch(() => {});
};

process.on('SIGTERM', async () => {
  await cleanup();
  process.exit(0);
});

process.on('SIGINT', async () => {
  await cleanup();
  process.exit(0);
});
```

---

## session cleanup

### retention policy

```ts
// khlone/src/daemon/sessionCleanup.ts

const SESSION_RETENTION_DAYS = 30;
const MAX_SESSIONS_PER_ZONE = 100;

const cleanupSessions = async (zone: Zone): Promise<void> => {
  const sessionsDir = `${zone.path}/.khlone/sessions`;
  const sessions = await fs.readdir(sessionsDir);

  // get session metadata
  const sessionMetas = await Promise.all(
    sessions.map(async (s) => ({
      name: s,
      stat: await fs.stat(`${sessionsDir}/${s}`),
    })),
  );

  // sort by mtime (oldest first)
  sessionMetas.sort((a, b) => a.stat.mtimeMs - b.stat.mtimeMs);

  const now = Date.now();
  const retentionMs = SESSION_RETENTION_DAYS * 24 * 60 * 60 * 1000;

  for (const session of sessionMetas) {
    const age = now - session.stat.mtimeMs;

    // delete if older than retention period
    if (age > retentionMs) {
      await fs.rm(`${sessionsDir}/${session.name}`, { recursive: true });
      continue;
    }

    // delete if over max count (oldest first)
    const sessionsLeft = sessionMetas.filter((s) =>
      fs.existsSync(`${sessionsDir}/${s.name}`),
    );
    if (sessionsLeft.length > MAX_SESSIONS_PER_ZONE) {
      await fs.rm(`${sessionsDir}/${session.name}`, { recursive: true });
    }
  }
};
```

### cleanup on zone delete

```ts
// khlone/src/domain.operations/zone/deleteZone.ts

const deleteZone = async (zone: Zone): Promise<void> => {
  // stop daemon
  await stopDaemon(zone);

  // remove khlone state
  await fs.rm(`${zone.path}/.khlone`, { recursive: true });

  // unregister from orchestrator
  const safeSlug = zone.site.slug.replace('/', '--');
  const registryPath = `${os.homedir()}/.khlone/orchestrator/sites/${safeSlug}.yml`;

  const registry = yaml.parse(await fs.readFile(registryPath, 'utf-8'));
  delete registry.zones?.[zone.branch];
  await fs.writeFile(registryPath, yaml.stringify(registry));
};
```

---

## PTY buffer management

### circular buffer with backpressure

```ts
// khlone/src/daemon/ptyBuffer.ts

const MAX_BUFFER_SIZE = 1_000_000; // 1MB

class PtyBuffer {
  private buffer: string[] = [];
  private totalSize = 0;
  private paused = false;

  constructor(private pty: BrainSession) {
    pty.onData((data) => this.push(data));
  }

  private push(data: string): void {
    this.buffer.push(data);
    this.totalSize += data.length;

    // apply backpressure if buffer too large
    if (this.totalSize > MAX_BUFFER_SIZE && !this.paused) {
      this.paused = true;
      // note: actual pause depends on PTY implementation
      // some PTYs support flow control, others don't
    }
  }

  consume(): string {
    const data = this.buffer.join('');
    this.buffer = [];
    this.totalSize = 0;

    if (this.paused) {
      this.paused = false;
      // resume if paused
    }

    return data;
  }

  peek(): string {
    return this.buffer.join('');
  }
}
```

---

## test coverage additions

### pre-flight tests

```ts
// rhachet-brains-anthropic/src/preflight.test.ts
describe('preflight', () => {
  it('returns NOT_INSTALLED when claude not found', async () => {
    const result = await preflight();
    expect(result.available).toBe(false);
    expect(result.error?.code).toBe('NOT_INSTALLED');
  });

  it('returns NOT_AUTHENTICATED when not logged in', async () => {
    // mock claude installed but not authenticated
    const result = await preflight();
    expect(result.available).toBe(true);
    expect(result.authenticated).toBe(false);
  });
});
```

### event translation tests

```ts
// rhachet-brains-anthropic/src/stream.test.ts
describe('translateClaudeEvent', () => {
  it('translates tool_use to tool_call', () => {
    const raw = { type: 'tool_use', name: 'Read', input: { file: 'x.ts' } };
    const event = translateClaudeEvent(raw);
    expect(event.type).toBe('tool_call');
    expect(event.payload.name).toBe('Read');
  });

  it('translates unknown events to progress', () => {
    const raw = { type: 'unknown_type', data: {} };
    const event = translateClaudeEvent(raw);
    expect(event.type).toBe('progress');
  });
});
```

### checkpoint tests

```ts
// khlone/src/daemon/checkpoint.test.ts
describe('checkpoint', () => {
  it('detects workspace state change', async () => {
    const checkpoint = { workspaceHash: 'abc123', /* ... */ };
    // modify a file
    const match = await checkStateIntegrity(checkpoint, workdir);
    expect(match).toBe(false);
  });

  it('constructs resume prompt with alert on state change', async () => {
    const prompt = await constructResumePrompt(checkpoint, workdir);
    expect(prompt).toContain('⚠️ ALERT');
  });
});
```

---

## summary: v2 → v3 changes

| aspect | v2 | v3 |
|--------|----|----|
| brain interface | BrainCli (subprocess only) | BrainAdapter (CLI + SDK) |
| session IDs | khlone generates | brain generates, khlone tracks |
| event schema | implicit | explicit BrainEvent + per-adapter translation |
| pre-flight | none | availability + auth check |
| checkpoint | tool call index only | full transcript + workspace hash |
| error codes | partial | full JSON-RPC error table |
| hook failure | unspecified | warn + continue, 60s timeout |
| rate limits | in-memory | file-based shared semaphore |
| adapter discovery | hardcoded | rhachet registry + dynamic import |
| daemon spawn | check-then-fork | flock before fork (atomic) |
| watch cleanup | unspecified | timeout + max watchers |
| skill types | prompt only | prompt + executable + parameterized |
| PTY buffer | unbounded | circular buffer with backpressure |
| session cleanup | unspecified | 30-day retention, max count |
| task limits | unbounded | configurable in khlone.yml |
| output sanitization | none | strip ANSI, redact secrets, 1MB max |
| cross-site | orchestrator mentioned | full orchestrator daemon + registry |
| auth state | assumed ok | pre-flight check + clear errors |
| cancellation | unclear | cancelled status + checkpoint + partial artifacts |
| socket permissions | unspecified | 0600, hash-based short paths |

**all 7 major gaps resolved. all 13 minor gaps addressed.**

v3 is production-ready specification for khlone v0.0.

