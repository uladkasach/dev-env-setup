# khlone v0.0: dispatch blueprint

> zoomed-in view of dispatch flow and rhachet integration

---

## dispatch overview

dispatch is the core operation that routes `ask` and `act` commands to clones. it must:

1. resolve zone (from cwd or `--zone` flag)
2. resolve clone (from hero default, `--who` flag, or `--skill` route)
3. resolve brain (from config default or `--brain` flag)
4. create task and enqueue to clone
5. return result to shell

---

## rhachet integration: actual SDK

rhachet formula: `roles (skills + briefs) + brains = actors`

khlone creates **actors** via rhachet, then dispatches work to them.

```
dispatch flow
│
├─► enrollClone()
│   └─► genActor({ role, brains })     # [1] create actor from role + brains
│
└─► executeTask()
    ├─► actor.ask({ say })              # [2] read-only mode
    ├─► actor.ask({ skill })            # [3] read-only via skill
    ├─► actor.act({ say })              # [4] read-write mode
    └─► actor.act({ skill })            # [5] read-write via skill
```

---

## rhachet SDK usage

```ts
import { genActor, genRole } from 'rhachet';
import { genBrainRepl } from 'rhachet-brains-claude';

// roles define capabilities (briefs + skills)
const mechanicRole = genRole({
  slug: 'ehmpathy/mechanic',
  briefs: ['briefs/**/*.md'],
  skills: ['skills/**/*.sh'],
});

// brains provide inference
const claudeBrain = genBrainRepl({
  slug: 'anthropic/claude/code/opus/v4.5',
});

// actors combine role + brain
const mechanic = genActor({
  role: mechanicRole,
  brains: [claudeBrain],
});

// two action modes (matches BrainChoice paradigm)
await mechanic.ask({ say: 'how does auth work?' });               // read-only
await mechanic.act({ say: 'implement jwt validation' });          // read-write
await mechanic.act({ skill: { 'review.pr': { pr: prRef } } });    // read-write via skill
```

---

## action mode selection

| khlone command | rhachet method | mode |
|----------------|----------------|------|
| `khlone ask "..."` | `actor.ask({ say })` | read-only (query, explain, research) |
| `khlone act "..."` | `actor.act({ say })` | read-write (modify, create, delete) |
| `khlone act --skill X` | `actor.act({ skill })` | read-write via skill |
| `khlone ask --skill X` | `actor.ask({ skill })` | read-only via skill |

**BrainChoice paradigm:**
- `ask` = read-only — queries, explanations, research (no mutations)
- `act` = read-write — implementations, modifications, file changes

---

## rhachet context contract

```ts
import { Actor, Role, BrainAtom, BrainRepl } from 'rhachet';
import { getAvailableBrains } from 'rhachet/brains';

/**
 * rhachet integration context for khlone
 */
interface RhachetContext {
  /**
   * discover installed brains from rhachet-brains-* packages
   * @returns atoms (stateless) and repls (stateful) brains
   */
  getAvailableBrains(): Promise<{ atoms: BrainAtom[]; repls: BrainRepl[] }>;

  /**
   * load role definition by ref
   * @param roleRef - e.g., "ehmpathy/mechanic"
   * @returns role with briefs and skills loaded
   */
  loadRole(roleRef: string): Promise<Role>;

  /**
   * create brain instance by ref
   * @param brainRef - e.g., "anthropic/claude/code/opus/v4.5"
   * @returns brain ready to attach to actor
   */
  createBrain(brainRef: string): Promise<BrainRepl>;

  /**
   * create actor from role + brains
   * @param input - role and brain instances
   * @returns actor ready to execute work
   */
  createActor(input: { role: Role; brains: BrainRepl[] }): Actor;
}

/**
 * actor instance (created via genActor)
 * follows BrainChoice paradigm: ask = read-only, act = read-write
 */
interface Actor {
  /** read-only — queries, explanations, research (no mutations) */
  ask(input: { say: string } | { skill: Record<string, unknown> }): Promise<ActorResult>;

  /** read-write — implementations, modifications, file changes */
  act(input: { say: string } | { skill: Record<string, unknown> }): Promise<ActorResult>;
}

/**
 * result from actor execution
 */
interface ActorResult {
  output: string;
  artifacts: Artifact<GitFile>[];
  tokens: { input: number; output: number };
}
```

---

## dispatch filediff

```
src/domain.operations/dispatch/
├── [+] dispatch.ts                 # main dispatch orchestrator
├── [+] dispatchWithSkill.ts        # skill-based route
├── [+] resolveRoleBrain.ts         # alias to ref resolution
└── [+] generateDispatchResult.ts   # format output
```

---

## dispatch.ts codepath

```ts
/**
 * .what = routes ask/act to a clone, returns immediately
 * .why = core dispatch operation that enables shell-native flow
 */
export const dispatch = async (
  input: {
    type: 'ask' | 'act';
    say: string | null;           // freeform message
    skill: string | null;         // skill choice slug
    who: string | null;           // clone slug or "role++"
    zone: string | null;          // zone address
    brain: string | null;         // brain alias override
    when: 'enqueue' | 'disrupt';
    prioritize: boolean;
  },
  context: KhloneContext,
): Promise<DispatchResult> => {
  // resolve zone from address or cwd
  const zone = await ensureZone(
    { address: input.zone, cwd: process.cwd() },
    context,
  );

  // resolve clone target
  const { clone, enrolled } = await inferClone(
    {
      zone,
      who: input.who,
      skill: input.skill,
      brain: input.brain,
    },
    context,
  );

  // create and enqueue task
  const task = await enqueueTask(
    {
      zone,
      clone,
      type: input.type,
      say: input.say,
      skill: input.skill ? { choice: input.skill, input: input.say } : null,
      when: input.when,
      prioritize: input.prioritize,
    },
    context,
  );

  return generateDispatchResult({ task, clone, zone, enrolled });
};
```

---

## inferClone.ts codepath

```ts
/**
 * .what = resolves which clone receives the task
 * .why = handles hero default, explicit who, enroll, and skill route
 */
export const inferClone = async (
  input: {
    zone: Zone;
    who: string | null;           // null | "mechanic.1" | "researcher++"
    skill: string | null;         // skill choice slug
    brain: string | null;         // brain alias override
  },
  context: KhloneContext,
): Promise<{ clone: Clone; enrolled: boolean }> => {
  // case 1: no who, no skill → hero clone
  if (!input.who && !input.skill) {
    const hero = await getOneClone(
      { zone: input.zone, slug: input.zone.hero.slug },
      context,
    );
    return { clone: hero, enrolled: false };
  }

  // case 2: skill dispatch → route to capable role
  if (input.skill) {
    return dispatchWithSkill(
      { zone: input.zone, skill: input.skill, brain: input.brain },
      context,
    );
  }

  // case 3: explicit clone slug → get it
  if (input.who && !input.who.endsWith('++')) {
    const clone = await getOneClone(
      { zone: input.zone, slug: input.who },
      context,
    );
    if (!clone) {
      throw new BadRequestError('clone not found', {
        slug: input.who,
        zone: input.zone.slug,
      });
    }
    return { clone, enrolled: false };
  }

  // case 4: enroll new clone → "role++"
  if (input.who && input.who.endsWith('++')) {
    const roleAlias = input.who.slice(0, -2); // "researcher++" → "researcher"
    const clone = await enrollClone(
      { zone: input.zone, roleAlias, brain: input.brain },
      context,
    );
    return { clone, enrolled: true };
  }

  throw new UnexpectedCodePathError('invalid who value', { who: input.who });
};
```

---

## dispatchWithSkill.ts codepath

```ts
/**
 * .what = routes task to clone that knows the skill
 * .why = enables --skill flag to auto-route to capable role
 */
export const dispatchWithSkill = async (
  input: {
    zone: Zone;
    skill: string;      // "review.architecture"
    brain: string | null;
  },
  context: KhloneContext,
): Promise<{ clone: Clone; enrolled: boolean }> => {
  const site = await getOneSite({ zone: input.zone }, context);

  // check if hero role knows the skill
  const heroRoleRef = site.config.crew.roles[site.config.crew.hero.role];
  const heroRole = await context.rhachet.loadRole(heroRoleRef);
  const heroKnows = heroRole.skills.some((s) => s.slug === input.skill);

  if (heroKnows) {
    const hero = await getOneClone(
      { zone: input.zone, slug: input.zone.hero.slug },
      context,
    );
    return { clone: hero, enrolled: false };
  }

  // find all roles that know the skill
  const rolesWithSkill: { alias: string; roleRef: string }[] = [];

  for (const [alias, roleRef] of Object.entries(site.config.crew.roles)) {
    const role = await context.rhachet.loadRole(roleRef);
    if (role.skills.some((s) => s.slug === input.skill)) {
      rolesWithSkill.push({ alias, roleRef });
    }
  }

  // failfast: no role knows skill
  if (rolesWithSkill.length === 0) {
    throw new BadRequestError('skill not found in any role', {
      skill: input.skill,
      availableSkills: await getAvailableSkills(site, context),
    });
  }

  // failfast: ambiguous — multiple roles know skill
  if (rolesWithSkill.length > 1) {
    throw new BadRequestError('skill is ambiguous — known by multiple roles', {
      skill: input.skill,
      roles: rolesWithSkill.map((r) => r.alias),
      suggestion: 'use --who to disambiguate',
    });
  }

  // single role knows skill → enroll clone of that role
  const { alias } = rolesWithSkill[0];
  const clone = await enrollClone(
    { zone: input.zone, roleAlias: alias, brain: input.brain },
    context,
  );
  return { clone, enrolled: true };
};
```

---

## resolveRoleBrain.ts codepath

```ts
/**
 * .what = resolves role alias and brain alias to full refs
 * .why = khlone.yml defines aliases, rhachet loads definitions
 */
export const resolveRoleBrain = async (
  input: {
    site: Site;
    roleAlias: string;          // "mechanic"
    brainAlias: string | null;  // "grok" or null for default
  },
  context: KhloneContext,
): Promise<{ roleRef: string; brainRef: string; role: Role }> => {
  // resolve role alias to ref
  const roleRef = input.site.config.crew.roles[input.roleAlias];
  if (!roleRef) {
    throw new BadRequestError('unknown role', {
      alias: input.roleAlias,
      available: Object.keys(input.site.config.crew.roles),
    });
  }

  // load role from rhachet
  const role = await context.rhachet.loadRole(roleRef);

  // resolve brain alias to ref
  const brainAlias = input.brainAlias ?? input.site.config.crew.hero.brain;
  const brainRef = input.site.config.crew.brains[brainAlias];
  if (!brainRef) {
    throw new BadRequestError('unknown brain', {
      alias: brainAlias,
      available: Object.keys(input.site.config.crew.brains),
    });
  }

  // validate brain is installed via rhachet
  const { repls } = await context.rhachet.getAvailableBrains();
  const brainFound = repls.find((r) => r.slug === brainRef);
  if (!brainFound) {
    throw new BadRequestError('brain not installed', {
      ref: brainRef,
      installed: repls.map((r) => r.slug),
    });
  }

  return { roleRef, brainRef, role };
};
```

---

## enrollClone.ts codepath

```ts
/**
 * .what = enrolls a new clone in the zone
 * .why = creates actor from role + brain via rhachet
 */
export const enrollClone = async (
  input: {
    zone: Zone;
    roleAlias: string;
    brain: string | null;
  },
  context: KhloneContext,
): Promise<Clone> => {
  const site = await getOneSite({ zone: input.zone }, context);

  // resolve role and brain refs
  const { roleRef, brainRef, role } = await resolveRoleBrain(
    { site, roleAlias: input.roleAlias, brainAlias: input.brain },
    context,
  );

  // generate clone slug: "{role}.{n}"
  const clonesFound = await getAllClones({ zone: input.zone }, context);
  const roleClones = clonesFound.filter(
    (c) => c.role === input.roleAlias,
  );
  const n = roleClones.length + 1;
  const slug = `${input.roleAlias}.${n}`;

  // create brain instance via rhachet
  const brain = await context.rhachet.createBrain(brainRef);

  // create actor via rhachet (role + brains = actor)
  const actor = context.rhachet.createActor({ role, brains: [brain] });

  // create clone entity (holds actor reference)
  const clone = new Clone({
    slug,
    zone: { slug: input.zone.slug },
    role: input.roleAlias,
    roleRef,
    brain: input.brain ?? site.config.crew.hero.brain,
    brainRef,
    status: 'idle',
    task: { focus: null, queue: [] },
    actor,  // rhachet actor instance
  });

  // persist clone state (actor is not serialized)
  await context.daoClone.set.upsert(clone);

  // emit event
  await emitCloneEnrolledEvent({ clone, zone: input.zone }, context);

  return clone;
};
```

---

## enqueueTask.ts codepath

```ts
/**
 * .what = creates task and adds to clone queue
 * .why = task is the unit of work dispatched to a clone
 */
export const enqueueTask = async (
  input: {
    zone: Zone;
    clone: Clone;
    type: 'ask' | 'act';
    say: string | null;
    skill: SkillInvocation | null;
    when: 'enqueue' | 'disrupt';
    prioritize: boolean;
  },
  context: KhloneContext,
): Promise<Task> => {
  // generate task slug
  const slug = generateTaskSlug();

  // create task entity
  const task = new Task({
    slug,
    zone: { slug: input.zone.slug },
    clone: { slug: input.clone.slug },
    type: input.type,
    say: input.say,
    skill: input.skill,
    status: 'queued',
    artifact: null,
    createdAt: new Date().toISOString(),
    startedAt: null,
    completedAt: null,
  });

  // persist task
  await context.daoTask.set.upsert(task);

  // add to clone queue
  const cloneUpdated = input.clone.clone({
    task: {
      ...input.clone.task,
      queue: input.prioritize
        ? [{ slug: task.slug }, ...input.clone.task.queue]
        : [...input.clone.task.queue, { slug: task.slug }],
    },
  });
  await context.daoClone.set.upsert(cloneUpdated);

  // emit event
  await emitTaskQueuedEvent({ task, clone: input.clone, zone: input.zone }, context);

  // handle disrupt mode
  if (input.when === 'disrupt') {
    await interruptClone({ clone: input.clone, task }, context);
  }

  return task;
};
```

---

## dispatch flow diagram

```
khlone act "implement auth"
│
├─► dispatch()
│   │
│   ├─► ensureZone()
│   │   ├── inferZone() from cwd
│   │   ├── if not bound → initZone()
│   │   │   ├── parseSiteConfig()
│   │   │   ├── bind zone state files
│   │   │   └── enrollClone() for hero
│   │   └── return zone
│   │
│   ├─► inferClone()
│   │   ├── if no --who, no --skill → return hero
│   │   ├── if --skill → dispatchWithSkill()
│   │   │   ├── rhachet.loadRole(hero.role)
│   │   │   ├── check role.skills for match
│   │   │   ├── if hero knows → return hero
│   │   │   ├── else scan roles → loadRole(each)
│   │   │   ├── if single match → enrollClone() that role
│   │   │   ├── if multiple → BadRequestError (ambiguous)
│   │   │   └── if zero → BadRequestError (not found)
│   │   ├── if --who "role++" → enrollClone()
│   │   │   ├── resolveRoleBrain()
│   │   │   │   ├── lookup alias in site.config.crew.roles
│   │   │   │   ├── rhachet.loadRole(roleRef)
│   │   │   │   ├── lookup brain alias in site.config.crew.brains
│   │   │   │   └── rhachet.getAvailableBrains() for validation
│   │   │   ├── rhachet.createBrain(brainRef)
│   │   │   ├── rhachet.createActor({ role, brains })
│   │   │   ├── daoClone.set.upsert()
│   │   │   └── emit CloneEnrolledEvent
│   │   └── if --who "clone.n" → getOneClone()
│   │
│   ├─► enqueueTask()
│   │   ├── generateTaskSlug()
│   │   ├── create Task entity
│   │   ├── daoTask.set.upsert()
│   │   ├── update clone.task.queue
│   │   ├── daoClone.set.upsert()
│   │   ├── emit TaskQueuedEvent
│   │   └── if disrupt → interruptClone()
│   │
│   └─► generateDispatchResult()
│       └── return { task, clone, zone, enrolled }
│
└─► cli formats output
    └── "✓ task-abc-123 → mechanic.1 (@feature-auth)"


task execution flow (background)
│
├─► processTaskQueue()
│   ├── dequeue next task
│   ├── setTaskAsStarted()
│   │
│   ├─► executeTask()
│   │   ├── if task.type='ask' && task.skill → actor.ask({ skill })
│   │   ├── if task.type='ask' → actor.ask({ say: task.say })
│   │   ├── if task.type='act' && task.skill → actor.act({ skill })
│   │   └── if task.type='act' → actor.act({ say: task.say })
│   │
│   └── setTaskAsCompleted() or setTaskAsFailed()
```

---

## test coverage for dispatch

```
src/domain.operations/dispatch/
├── dispatch.test.ts
│   ├── given: zone bound, hero enrolled
│   │   ├── when: act with no flags → queues to hero
│   │   ├── when: ask with no flags → queues to hero
│   │   └── when: act with --prioritize → queues at front
│   │
│   ├── given: zone not bound
│   │   └── when: act with no flags → inits zone, enrolls hero, queues
│   │
│   └── given: zone bound, no hero
│       └── when: act with no flags → enrolls hero, queues
│
├── dispatchWithSkill.test.ts
│   ├── given: hero knows skill
│   │   └── when: --skill X → queues to hero
│   │
│   ├── given: single role knows skill
│   │   └── when: --skill X → enrolls role, queues
│   │
│   ├── given: multiple roles know skill
│   │   └── when: --skill X → BadRequestError (ambiguous)
│   │
│   └── given: no role knows skill
│       └── when: --skill X → BadRequestError (not found)
│
├── resolveRoleBrain.test.ts
│   ├── given: valid role alias, valid brain alias
│   │   └── when: resolve → returns refs and loaded role
│   │
│   ├── given: unknown role alias
│   │   └── when: resolve → BadRequestError
│   │
│   ├── given: unknown brain alias
│   │   └── when: resolve → BadRequestError
│   │
│   └── given: brain not in getAvailableBrains().repls
│       └── when: resolve → BadRequestError (not installed)
│
├── enrollClone.test.ts
│   ├── given: no prior clones of role
│   │   └── when: enroll → creates {role}.1
│   │
│   ├── given: one prior clone of role
│   │   └── when: enroll → creates {role}.2
│   │
│   ├── given: rhachet.createBrain fails
│   │   └── when: enroll → propagates error
│   │
│   └── given: valid inputs
│       └── when: enroll → actor created via createActor()
│
└── inferClone.test.ts
    ├── given: no --who, no --skill
    │   └── when: infer → returns hero
    │
    ├── given: --who "mechanic.1"
    │   └── when: infer → returns mechanic.1
    │
    ├── given: --who "researcher++"
    │   └── when: infer → enrolls researcher, returns it
    │
    └── given: --skill "review.architecture"
        └── when: infer → calls dispatchWithSkill
```

---

## summary

dispatch integrates with rhachet via the actor model:

1. **`getAvailableBrains()`** — discover installed brains from `rhachet-brains-*` packages
2. **`loadRole(ref)`** — load role definition (briefs + skills)
3. **`createBrain(ref)`** — instantiate brain for actor
4. **`createActor({ role, brains })`** — compose actor from role + brains
5. **`actor.ask/act({ ... })`** — execute work via BrainChoice paradigm

**rhachet formula:** `roles (skills + briefs) + brains = actors`

**BrainChoice paradigm:**
| mode | method | behavior |
|------|--------|----------|
| read-only | `actor.ask()` | queries, explanations, research (no mutations) |
| read-write | `actor.act()` | implementations, modifications, file changes |

khlone owns:
- zone resolution and auto-init
- clone target inference (hero, explicit, enroll, skill route)
- task creation and queue management
- event emission

rhachet owns:
- role definitions (briefs + skills)
- brain instantiation and lifecycle
- actor composition and execution
