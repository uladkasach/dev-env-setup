# khlone v0.0: research references

> citations and lessons from reference materials

---

## lesson.1 = rhachet provides role resolution

**source:** `.behavior/v2026_02_12.khlone-worksite/.refs/old.1.vision.md:525`

**quote:**
> "role init: `--who role++` spawns a clone with the specified role alias. alias resolves to fully qualified name (e.g., `mechanic` â†’ `ehmpathy/mechanic`). rhachet knows how to init each role (briefs, skills, hooks)."

**implication:**
- khlone calls rhachet to resolve role aliases to fully qualified refs
- rhachet owns role definitions (briefs, skills, hooks)
- khlone.yml only defines aliases, not role content

---

## lesson.2 = rhachet provides skill discovery

**source:** `.behavior/v2026_02_12.khlone-worksite/3.2.distill.domain._.v1.i1.md`

**quote:**
> "skill (template from rhachet) â””â”€â”€ Task (instance when --skill used)"

**implication:**
- skills are templates defined in rhachet roles
- khlone queries rhachet to find which roles know which skills
- skill dispatch routes to the role that owns the skill

---

## lesson.3 = rhachet uses actor model (actual SDK)

**source:** `npm view rhachet readme` (v1.33.0)

**quote:**
> "rhachet formula: ðŸ§¢ roles (ðŸ’ª skills + ðŸ“š briefs) + ðŸ§  brains = ðŸŽ­ actors"

**actual API (with BrainChoice update per lesson.13):**
```ts
import { genActor, genRole } from 'rhachet';
import { genBrainRepl } from 'rhachet-brains-openai';

const mechanic = genActor({
  role: mechanicRole,
  brains: [genBrainRepl({ slug: 'openai/codex' })],
});

await mechanic.ask({ say: 'how to simplify...?' });           // read-only
await mechanic.act({ skill: { review: { pr } } });            // read-write via skill
await mechanic.act({ say: 'implement this feature' });        // read-write
```

**implication:**
- khlone creates actors via `genActor({ role, brains })`
- actors combine role (skills + briefs) with brains
- two action modes: ask (read-only), act (read-write) â€” see lesson.13
- no separate `spawnBrain()` â€” brains are composed into actors

---

## lesson.4 = rhachet-artifact provides task output storage

**source:** `.behavior/v2026_02_12.khlone-worksite/3.2.distill.domain._.v1.i1.md`

**quote:**
> "artifact: Artifact<GitFile> | null; // captured on complete (from rhachet-artifact)"

**implication:**
- task outputs stored via `Artifact<GitFile>` from rhachet-artifact
- enables git-tracked artifact storage
- onStop hooks capture artifacts into this structure

---

## lesson.5 = clone is a bound brain instance

**source:** `.behavior/v2026_02_12.khlone-worksite/3.2.distill.domain._.v1.i1.md`

**quote:**
> "role (template from rhachet) â””â”€â”€ Clone (instance) â”œâ”€â”€ adds: status, pid, queue, progress â””â”€â”€ adds: brain (selected from config)"

**implication:**
- role = template from rhachet
- clone = role + brain + zone context + runtime state
- khlone manages clone lifecycle, rhachet provides role/brain definitions

---

## lesson.6 = khlone.yml defines aliases, not content

**source:** `.behavior/v2026_02_12.khlone-worksite/.refs/old.1.vision.md:484-489`

**quote:**
```yaml
roles:                        # role aliases available for --who role++
  mechanic: ehmpathy/mechanic # alias -> fully qualified (repo/role)
  researcher: ehmpathy/researcher
  reviewer: ehmpathy/reviewer
  auditor: acme/auditor       # can combine roles from different repos
```

**implication:**
- khlone.yml maps short aliases to fully qualified role refs
- actual role content lives in rhachet repositories
- enables roles from different organizations to coexist

---

## lesson.7 = brain aliases resolve to brain instances

**source:** `.behavior/v2026_02_12.khlone-worksite/1.vision.md:190-206`

**quote:**
```yaml
brains:                         # brain aliases for --brain
  claude: anthropic/claude/code/opus/v4.5
  grok: xai/grok/code-fast-1
  codex: openai/codex/v5.3
  gemini: google/gemini/code/v2
```

**implication:**
- brain aliases in khlone.yml map to fully qualified brain refs
- khlone creates brain instances via rhachet brain packages (e.g., `rhachet-brains-claude`)
- brains are composed into actors via `genActor({ role, brains })`
- enables override per-task via `--brain` flag

---

## lesson.8 = dispatch routes to hero by default

**source:** `.behavior/v2026_02_12.khlone-worksite/1.vision.md:108-132`

**quote:**
> "the hero is the default clone for a zone â€” all tasks queue here unless `--who` specifies otherwise."

**implication:**
- dispatch always has a target clone
- if no `--who` flag, target = zone.hero
- hero is enrolled on zone init per `crew.hero` config

---

## lesson.9 = skill dispatch has priority cascade

**source:** `.behavior/v2026_02_12.khlone-worksite/1.vision.md:151-187`

**quote:**
> "if hero knows the skill â†’ hero gets it. if exactly one role knows it â†’ that role gets it (enroll if needed). if multiple roles know it â†’ failfast, ask for disambiguation. if zero roles know it â†’ failfast, inform user."

**implication:**
- skill dispatch checks hero first
- then checks all roles for unique match
- ambiguity and not-found are fail-fast errors

---

## lesson.10 = implicit init on first dispatch

**source:** `.behavior/v2026_02_12.khlone-worksite/.refs/old.1.vision.md:493-513`

**quote:**
> "first `khlone ask` or `khlone act` triggers implicit `khlone init`: 1. read config â€” find `khlone.worksite.yml` at gitroot 2. resolve worktree â€” detect branch + worktree path 3. bind worksite â€” create `.khlone/.bind.worksite/` in worktree 4. spawn clone.0 â€” start default clone per crew config"

**implication:**
- dispatch must handle zones that are not yet bound
- ensureZone() creates zone + enrolls hero if needed
- user never needs explicit init

---

## lesson.11 = cross-zone dispatch creates zones

**source:** `.behavior/v2026_02_12.khlone-worksite/2.1.criteria.blackbox.md:220-225`

**quote:**
```
given(zone does not exist)
  when(user runs `khlone act "task" --zone @nonexistent`)
    then(zone is created)
    then(hero clone is enrolled in new zone)
    then(task is queued)
```

**implication:**
- dispatch to nonexistent zone triggers zone creation
- hero enrollment happens automatically
- enables on-the-fly zone provision

---

## lesson.12 = rhachet cli for role bootstrap

**source:** `.behavior/v2026_02_12.khlone-worksite/.ref.[feedback].v1.[given].by_human.md`

**quote:**
> "npx rhachet roles boot --repo ehmpathy --role mechanic"

**implication:**
- rhachet has cli for role bootstrap
- khlone can shell out to rhachet or use programmatic api
- role init is rhachet's responsibility

---

## lesson.13 = BrainChoice paradigm (ask = read-only, act = read-write)

**source:** khlone design decision

**âš ï¸ REQUIRED UPDATE TO RHACHET:**
rhachet currently exposes `actor.{run,act,ask}` (solid/rigid/fluid). we require an update to simplify to `actor.{act,ask}` to match the BrainChoice paradigm.

**rationale:**
we simplify the actor interface from three methods (`run/act/ask`) to two (`act/ask`) to be more explicit about intent:
- `actor.ask()` = read-only â€” queries, explanations, research (no mutations)
- `actor.act()` = read-write â€” implementations, modifications, file changes

**solid/rigid/fluid is a RoleSkill concern:**
the three grains of determinism still exist, but at the **skill registration** level:
- ðŸª¨ solid skill â€” deterministic, no brain (e.g., `lint.fix`, `test.run`)
- ðŸ”© rigid skill â€” harness controls flow, brain augments (e.g., `review.pr`)
- ðŸ’§ fluid skill â€” probabilistic, brain decides path (e.g., `research.topic`)

when a skill is invoked via `actor.ask({ skill })` or `actor.act({ skill })`, the actor internally resolves the skill's grain and executes accordingly:
```ts
// skill registration declares grain
const skills = [
  { slug: 'lint.fix', grain: 'solid', handler: lintFixHandler },
  { slug: 'review.pr', grain: 'rigid', handler: reviewPrHandler },
  { slug: 'research.topic', grain: 'fluid', handler: researchHandler },
];

// actor invocation specifies mode (ask/act), actor resolves grain
await actor.act({ skill: { 'lint.fix': { path } } });     // solid skill, read-write mode
await actor.ask({ skill: { 'review.pr': { pr } } });      // rigid skill, read-only mode
```

**khlone command map:**

| khlone command | mode | rhachet method |
|----------------|------|----------------|
| `khlone ask "..."` | read-only | `actor.ask({ say })` |
| `khlone ask --skill X` | read-only | `actor.ask({ skill })` |
| `khlone act "..."` | read-write | `actor.act({ say })` |
| `khlone act --skill X` | read-write | `actor.act({ skill })` |

---

## lesson.14 = brain packages are separate (actual SDK)

**source:** `npm view rhachet readme` (v1.33.0)

**quote:**
> "brains provide thought... see rhachet-brains-openai for example"

**implication:**
- brains are instantiated via separate packages
- e.g., `rhachet-brains-openai`, `rhachet-brains-claude`
- each brain package provides `genBrainRepl()` or similar
- khlone must depend on brain packages for each supported brain

---

## lesson.15 = getAvailableBrains discovers installed brains

**source:** `github.com/ehmpathy/rhachet/src/domain.operations/brains/getAvailableBrains.ts`

**signature:**
```ts
import { getAvailableBrains } from 'rhachet/brains';

const { atoms, repls } = await getAvailableBrains();
// atoms: BrainAtom[] â€” single-turn inference
// repls: BrainRepl[] â€” multi-turn agentic loops
```

**implication:**
- rhachet auto-discovers brains from installed `rhachet-brains-*` packages
- returns two categories: atoms (stateless) and repls (stateful)
- khlone can validate brain aliases against available brains
- enables dynamic brain discovery without hardcoded list

---

## summary

### rhachet formula

> `roles (skills + briefs) + brains = actors`

### actual rhachet SDK (v1.33.0)

| capability | rhachet api | khlone usage |
|------------|-------------|--------------|
| role load | `genRole()` or load from repo | resolve alias to role instance |
| brain discover | `getAvailableBrains()` | validate brain aliases |
| brain create | `genBrainRepl()` from brain package | instantiate brain for actor |
| actor create | `genActor({ role, brains })` | compose clone from role + brain |
| read-only | `actor.ask({ say \| skill })` | queries, research, explanations |
| read-write | `actor.act({ say \| skill })` | implementations, modifications |
| artifact storage | `Artifact<GitFile>` | store task outputs |

### BrainChoice paradigm

| mode | method | description |
|------|--------|-------------|
| read-only | `actor.ask()` | queries, explanations, research (no mutations) |
| read-write | `actor.act()` | implementations, modifications, file changes |

### khlone owns

- zone lifecycle (init, ensure, bind)
- clone management (enroll, status, queue)
- task lifecycle (enqueue, start, complete, fail)
- dispatch route (hero default, skill cascade)
- observation (watch, talk, await)

### rhachet owns

- role definitions (briefs + skills)
- brain packages (`rhachet-brains-*`)
- actor composition and execution
- thought route semantics
