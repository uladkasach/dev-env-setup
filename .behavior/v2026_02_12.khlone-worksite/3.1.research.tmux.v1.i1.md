# khlone v0.0: tmux research

> how tmux works, why detach/reattach works, what khlone can learn

---

## what is tmux?

**tmux = terminal multiplexer**

a program that:
- creates persistent terminal sessions that survive disconnects
- multiplexes multiple windows/panes within a session
- allows detach and reattach from any terminal

```
┌─────────────────────────────────────────────────────────────┐
│                      tmux architecture                       │
│                                                             │
│  ┌──────────────────┐         ┌──────────────────┐         │
│  │   tmux client    │         │   tmux client    │         │
│  │   (terminal 1)   │         │   (terminal 2)   │         │
│  └────────┬─────────┘         └────────┬─────────┘         │
│           │                            │                    │
│           │     unix socket            │                    │
│           │   /tmp/tmux-1000/default   │                    │
│           │                            │                    │
│           └────────────┬───────────────┘                    │
│                        │                                    │
│                        ▼                                    │
│           ┌────────────────────────┐                        │
│           │     tmux server        │                        │
│           │     (long-lived)       │                        │
│           │                        │                        │
│           │  ┌──────┐  ┌──────┐   │                        │
│           │  │ PTY  │  │ PTY  │   │                        │
│           │  │sess 0│  │sess 1│   │                        │
│           │  └──┬───┘  └──┬───┘   │                        │
│           │     │         │        │                        │
│           │     ▼         ▼        │                        │
│           │  ┌──────┐  ┌──────┐   │                        │
│           │  │ bash │  │ vim  │   │                        │
│           │  └──────┘  └──────┘   │                        │
│           └────────────────────────┘                        │
└─────────────────────────────────────────────────────────────┘
```

---

## client-server architecture

### the server

tmux server is a **long-lived daemon** that:
- owns all PTYs (pseudo-terminals)
- runs programs (bash, vim, etc) attached to those PTYs
- persists even when no clients are connected
- manages sessions, windows, and panes

```sh
# server starts automatically on first tmux command
$ tmux new-session -s work

# server lives here
/tmp/tmux-${UID}/default    # unix socket
```

**key insight:** the server never exits while sessions exist. this is why programs survive disconnects.

### the client

tmux client is a **short-lived process** that:
- connects to server via unix socket
- renders server's PTY output to your terminal
- sends your keystrokes to server
- can detach and reattach freely

```sh
# client connects to server
$ tmux attach -t work

# client detaches (ctrl+b d)
# client process exits
# server continues

# new client connects
$ tmux attach -t work
# same session, same state
```

---

## why detach/reattach works

### the PTY ownership model

```
WITHOUT tmux:

  your terminal ──────► bash ──────► program
       │
       └── if terminal closes, SIGHUP → bash dies → program dies


WITH tmux:

  your terminal ──────► tmux client
       │                    │
       │               unix socket
       │                    │
       │               tmux server ──────► PTY ──────► bash ──────► program
       │                    │
       └── if terminal closes:
           - tmux client dies
           - server stays alive (owns PTY)
           - bash continues (PTY still open)
           - program continues
```

**the key:** tmux server owns the PTY, not your terminal. your terminal is just a viewer.

### session persistence

when you detach:
1. client disconnects from socket
2. server keeps running
3. PTY stays open
4. programs continue (no SIGHUP)
5. output buffers in server

when you reattach:
1. new client connects to socket
2. server pipes PTY output to new client
3. your terminal renders current state
4. you see exactly where you left off

---

## the unix socket protocol

### socket location

```sh
# default socket
/tmp/tmux-${UID}/default

# custom socket
tmux -S /path/to/socket new-session
```

### protocol (simplified)

```
┌─────────────────────────────────────────────────────────────┐
│                 tmux protocol (conceptual)                   │
│                                                             │
│  client → server:                                           │
│  ┌────────────────────────────────────────────────────┐    │
│  │ MSG_IDENTIFY   │ client info, terminal size        │    │
│  │ MSG_COMMAND    │ "attach-session -t work"          │    │
│  │ MSG_STDIN      │ raw keystrokes                    │    │
│  │ MSG_RESIZE     │ terminal size changed             │    │
│  └────────────────────────────────────────────────────┘    │
│                                                             │
│  server → client:                                           │
│  ┌────────────────────────────────────────────────────┐    │
│  │ MSG_READY      │ connection accepted               │    │
│  │ MSG_STDOUT     │ PTY output to render              │    │
│  │ MSG_EXIT       │ session ended                     │    │
│  └────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

the actual protocol is more complex (see `tmux/tty-keys.c` and `tmux/server-client.c` in source), but the principle is:
- client sends commands + keystrokes
- server sends rendered output

---

## PTY management in tmux

### how tmux creates a PTY

```c
// simplified from tmux source

// 1. open the manager end
int ptm = open("/dev/ptmx", O_RDWR | O_NOCTTY);

// 2. get subsidiary path
char *pts_path = ptsname(ptm);  // e.g., "/dev/pts/3"

// 3. unlock and grant
grantpt(ptm);
unlockpt(ptm);

// 4. fork
pid_t pid = fork();

if (pid == 0) {
    // child: the shell
    setsid();                          // new session
    int pts = open(pts_path, O_RDWR);  // open subsidiary
    dup2(pts, STDIN_FILENO);
    dup2(pts, STDOUT_FILENO);
    dup2(pts, STDERR_FILENO);
    execl("/bin/bash", "bash", NULL);
}

// parent: server owns ptm
// reads/writes to ptm to communicate with shell
```

### the data flow

```
┌─────────────────────────────────────────────────────────────┐
│                     PTY data flow in tmux                    │
│                                                             │
│  user terminal                tmux server              shell │
│       │                            │                      │ │
│       │  keystroke 'l'             │                      │ │
│       ├───────────────────────────►│                      │ │
│       │  (via unix socket)         │                      │ │
│       │                            │  write(ptm, "l")     │ │
│       │                            ├─────────────────────►│ │
│       │                            │                      │ │
│       │                            │  read(ptm) ← output  │ │
│       │                            │◄─────────────────────┤ │
│       │  rendered output           │                      │ │
│       │◄───────────────────────────┤                      │ │
│       │  (via unix socket)         │                      │ │
│       │                            │                      │ │
└─────────────────────────────────────────────────────────────┘
```

---

## tmux features relevant to khlone

### 1. detach without kill

```sh
# detach current client
ctrl+b d

# or programmatically
tmux detach-client
```

the session continues. this is how khlone's `/exit` in talk mode should work.

### 2. send keys to session

```sh
# send keystrokes to a session without attach
tmux send-keys -t work "echo hello" Enter
```

this is how khlone dispatches tasks headlessly — write to PTY without attach.

### 3. capture output

```sh
# capture current pane content
tmux capture-pane -t work -p

# stream output (pipe-pane)
tmux pipe-pane -t work 'cat >> /tmp/log.txt'
```

this is how `khlone watch` streams output without full attach.

### 4. multiple clients, one session

```sh
# terminal 1
tmux attach -t work

# terminal 2 (same time)
tmux attach -t work

# both see the same session
# both can type
```

khlone could support multiple watchers/talkers to same clone.

---

## what khlone learns from tmux

| tmux concept | khlone equivalent |
|--------------|-------------------|
| tmux server | khlone daemon |
| tmux session | clone PTY |
| tmux attach | khlone talk |
| tmux detach | /exit in talk |
| tmux send-keys | khlone act (headless) |
| tmux capture-pane | khlone watch |
| unix socket | daemon IPC socket |

### the parallel architecture

```
tmux:
  server (1) ────► sessions (N) ────► shells (N)
    │
  socket
    │
  clients (attach/detach freely)


khlone:
  daemon (1) ────► PTYs (N) ────► clones (N)
    │
  socket
    │
  CLI invocations (ask/act/watch/talk)
```

---

## why not just use tmux directly?

| option | pros | cons |
|--------|------|------|
| use tmux | battle-tested, mature | external dependency, shell out complexity |
| use node-pty | same capability, native node | we control the interface |
| use screen | alternative | same issues as tmux |

**decision: node-pty**

node-pty gives us the same PTY ownership that tmux provides, but as a native node module. no shell-out, no parse of tmux output.

```ts
import { spawn } from 'node-pty';

// same as tmux new-session, but in-process
const pty = spawn('claude', ['--resume'], { ... });

// same as tmux send-keys
pty.write('implement auth\n');

// same as tmux capture-pane (streaming)
pty.onData((data) => emit(data));

// same as tmux attach
process.stdin.pipe(pty);
pty.pipe(process.stdout);

// same as tmux detach
process.stdin.unpipe(pty);
pty.unpipe(process.stdout);
// pty continues running
```

---

## summary

| question | answer |
|----------|--------|
| **what is tmux?** | terminal multiplexer — server owns PTYs, clients attach/detach |
| **why does detach work?** | server owns PTY, not your terminal; SIGHUP never reaches programs |
| **how do clients talk to server?** | unix socket with command/output protocol |
| **how does this help khlone?** | same architecture: daemon owns clone PTYs, CLI commands attach/detach |

**the core insight:**

tmux solved the "terminal ownership" problem by split: a long-lived server owns the PTY, short-lived clients just view it.

khlone does the same: a long-lived daemon owns clone PTYs, short-lived CLI invocations dispatch commands or attach for interaction.

**sources:**
- [tmux wiki - how tmux works](https://github.com/tmux/tmux/wiki/Getting-Started)
- [tmux source code](https://github.com/tmux/tmux)
- [pty(7) - Linux manual page](https://man7.org/linux/man-pages/man7/pty.7.html)
- [tmux servers and sessions guide](https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/)
- [TTYs, PTYs, SSH, and tmux explained](https://yakking.branchable.com/posts/terminal-sharing/)

