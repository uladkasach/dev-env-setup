# khlone v0.0: site orchestration

> orchestrate robot actors via shell-native dispatch

---

## the outcome world

### before

```
$ claude-code
[10 seconds to load...]
[type "implement auth"]
[ui freezes while it thinks]
[keystrokes lag, get lost]
[crash mid-task, lose context]
[restart, re-explain, hope it remembers]
[laptop fans spin, terminal frozen]
[force-quit, lose work, start over]
```

your shell is hijacked. your work is fragile. tokens spent, work lost.

### after

```
$ khlone act "implement auth"

✓ task-001 → foreman.1 (@feature-auth)
$ _                              # instant, shell is yours

$ khlone act "add tests"         # queue more while first runs

✓ task-002 → foreman.1 (@feature-auth)

$ khlone ask "what files changed?" --watch

lets watch...

            ┬
● foreman.1 │ 3 files changed: auth.ts, jwt.ts, auth.test.ts
^C
$ _                              # ctrl+c, back to shell

$ khlone status

zone @feature-auth (local)
├─ ● foreman.1  67%  implement auth
└─ queue 1 task

$ khlone list zones

site ehmpathy/myrepo
├─ @main           ○ foreman.1
└─ @feature-auth   ● foreman.1 (67%), ○ researcher.1
```

your shell stays yours. work survives crashes. tokens tracked.

**note:** all tasks queue to the **hero clone** (foreman.1) by default. the hero can delegate to specialists, or you can bypass with `--who researcher++`.

### the "aha" moment

you `khlone act "refactor auth"` and immediately think of three more tasks. you type them all — instant, no wait. they queue up. you walk away.

when you return: first two done, third in progress. the repl crashed once — you didn't notice because khlone restarted it and continued. you type `khlone ask "what changed?" --await >> changelog.md` and the output pipes to a file.

the repl is no longer in your way.

---

## domain model

### hierarchy

```
orchestrator (~/.khlone/)              # global state across machine
└── site (org/repo)                # shared config, role aliases
    └── zone (@branch)                 # per worktree — independent state
        ├── crew                       # clones in the zone
        │   ├── mechanic.1             # role instance
        │   ├── reviewer.1
        │   └── researcher.1
        └── task                       # tasks in the zone
            ├── task-abc-123           # assigned to mechanic.1
            └── task-def-456           # queued
```

### scopes

| scope | slug example | description |
|-------|--------------|-------------|
| `orchestrator` | — | global: all sites on machine |
| `site` | `ehmpathy/myrepo` | repo-level: zones + config |
| `zone` | `@feat/auth` or `svc-jobs@main` | branch-level: crew + tasks |
| `crew` | `mechanic.1` | clone instances |
| `task` | `task-abc-123` | units of work |
| `skill` | `review.architecture` | role-based skills (via rhachet) |

### domain objects

#### Site

the repo-level container. one site per `org/repo`.

```yaml
# khlone.yml (at gitroot)
zone:
  host: local                     # local | cloud

crew:
  hero:
    role: foreman                 # default role — all tasks queue here unless --who
    brain: claude                 # default brain — used unless --brain specified

  roles:                          # role aliases for --who role++
    mechanic: ehmpathy/mechanic
    researcher: ehmpathy/researcher
    reviewer: ehmpathy/reviewer
    foreman: ehmpathy/foreman

  brains:                         # brain aliases for --brain
    claude: anthropic/claude/code/opus/v4.5
    grok: xai/grok/code-fast-1
    codex: openai/codex/v5.3
    gemini: google/gemini/code/v2

  # skills are inherited from roles via rhachet
  # some skills are solid (no brain needed)
  # some skills are fluid/rigid (brain required)
  # rhachet resolves brain requirements per skill

  hooks:
    onStop:                       # fires when task ends
      - prompt: "1-line summary"
        artifact: summary
      - prompt: "fully done? yes/no/partial"
        artifact: complete
```

**properties:**
- `slug`: `org/repo` (e.g., `ehmpathy/myrepo`)
- `config`: parsed from `khlone.yml`
- `zones`: active zones in this site

#### Zone

a worktree instance. one zone per branch checkout.

**properties:**
- `slug`: `@branch` (e.g., `@feat/auth`, `@main`)
- `address`: `org/repo@branch` (full), `repo@branch` (same org), `@branch` (same site)
- `site`: parent site ref
- `crew`: clones in this zone
- `host`: `local` | `cloud`
- `path`: worktree filesystem path

**state files:**
```
{worktree}/.khlone/.bind/
├── zone.yml      # zone config snapshot
├── crew.yml      # active clones
└── task.yml      # tasks + artifacts
```

#### Clone

an enrolled brain — a brain bound to a role within a zone. runs headless.

**properties:**
- `slug`: `{role}.{n}` (e.g., `mechanic.1`, `foreman.1`)
- `role`: role alias (resolves to fully qualified `repo/role`)
- `brain`: brain alias (resolves to fully qualified `org/brain/variant`)
- `status`: `idle` | `active`
- `task`:
  - `focus`: current task (`choice` + `progress`)
  - `queue`: queued tasks
- `pid`: process id of headless repl

**brain resolution:**
- defaults to `crew.hero.brain` from `khlone.yml`
- override per-task via `--brain` flag
- rhachet provides `getAvailableBrains()` for validation

#### Hero Clone

the **hero** is the default clone for a zone — all tasks queue here unless `--who` specifies otherwise.

**two patterns:**

1. **delegator hero** (recommended)
   - hero role is a foreman/orchestrator (e.g., `foreman`, `lead`)
   - foreman receives tasks and delegates to specialists (`--who mechanic++`, `--who researcher++`)
   - user dispatches to hero, hero handles coordination
   ```yaml
   crew:
     hero: foreman    # foreman delegates to mechanic, researcher, etc
   ```

2. **direct hero**
   - hero role is a doer (e.g., `mechanic`)
   - user manually delegates via `--who` when specialist needed
   - simpler setup, more manual coordination
   ```yaml
   crew:
     hero: mechanic   # user handles delegation via --who
   ```

**dispatch flow:**
```sh
# these are equivalent — both queue to hero
$ khlone act "implement auth"

✓ task-001 → foreman.1

$ khlone act "implement auth" --who hero

✓ task-002 → foreman.1

# explicit delegation bypasses hero
$ khlone act "research patterns" --who researcher++

✓ enrolled researcher.1
✓ task-003 → researcher.1
```

**state files:**
```
{worktree}/.khlone/clones/{clone.id}/
├── state.json        # current status
├── checkpoint.json   # resume point
└── transcript.jsonl  # full log
```

#### Skill

role-based skills (via rhachet). can be prompts, executables, or both.

**ergonomics:** skills are the most frictionless way to dispatch work. one command handles it all:

```sh
$ khlone act --skill review.architecture
```

that's it. khlone will:
1. find which role knows `review.architecture`
2. enroll a clone of that role (if needed)
3. run the skill
4. store output in the clone's artifacts

no need to remember role names or manually enroll clones.

**properties:**
- `slug`: `skill.name` (e.g., `review.architecture`, `research.patterns`)
- `role`: which role provides this skill

**dispatch logic for `--skill`:**
1. if hero knows the skill → hero gets it
2. if exactly one role knows it → that role gets it (enroll if needed)
3. if multiple roles know it → failfast, ask for disambiguation
4. if zero roles know it → failfast, inform user

**examples:**
```sh
# hero (foreman) knows review.architecture → foreman handles it
$ khlone ask --skill review.architecture

✓ task-001 → foreman.1 (skill review.architecture)

# only researcher knows research.patterns → enrolls researcher
$ khlone ask --skill research.patterns

✓ enrolled researcher.1
✓ task-002 → researcher.1 (skill research.patterns)

# multiple roles know code.review → failfast
$ khlone ask --skill code.review

✗ ambiguous  code.review known by [reviewer, mechanic]
  ↳ use --who reviewer++ or --who mechanic++

# no role knows unknown.skill → failfast
$ khlone ask --skill unknown.skill

✗ no role knows skill unknown.skill
  ↳ available  review.architecture, research.patterns, ...
```

#### Task

a unit of work assigned to a clone.

**properties:**
- `slug`: `task-{short-uuid}` (e.g., `task-abc-123`)
- `type`: `ask` | `act`
- `prompt`: the user's request (or skill ref)
- `skill`: optional skill that was invoked
- `clone`: assigned clone ref
- `status`: `queued` | `active` | `done` | `failed`
- `priority`: queue position
- `artifacts`: captured on completion (summary, complete, tokens)

#### Session

continuity across shell invocations.

**properties:**
- `id`: uuid (stored in `$KHLONE_SESSION`)
- `zone`: current zone ref
- `clone`: default clone for this session

---

## domain operations

### core verbs

| verb | arguments | what it does |
|------|-----------|--------------|
| `init` | — | bind worktree to zone, enroll default clone |
| `ask` | `"prompt"` | queue a question (creates task), return to shell |
| `act` | `"prompt"` | queue an action (creates task), return to shell |
| `list` | `scope` | enumerate resources: `sites\|zones\|crews\|tasks` |
| `status` | `scope?` | inspect state (smart defaults based on pwd) |
| `watch` | — | stream clone output (passive observe) |
| `talk` | — | interactive session (active converse) |
| `log` | — | view transcript |

**status scope resolution:**
- `khlone status` → smart default (zone/site/orchestrator based on pwd)
- `khlone status zone` → explicit scope
- `khlone status --task task-abc-123` → specific resource by slug

### smart defaults for `status`

`khlone status` auto-selects scope based on pwd:

| pwd context | defaults to | shows |
|-------------|-------------|-------|
| feature branch | `zone` | clones, tasks, progress |
| main branch | `site` | all zones in repo |
| not a git repo | `orchestrator` | all sites on machine |

explicit scope always available: `khlone status orchestrator`

### operation: init

bind current worktree to a zone.

```
init() → Zone
```

**behavior:**
1. find `khlone.yml` at gitroot
2. detect worktree branch
3. create `.khlone/.bind/` state files
4. enroll hero clone (per `crew.hero` config)
5. return zone

**implicit init:** first `ask` or `act` triggers init automatically.

```sh
$ khlone act "implement auth"

✓ init @feature-auth → foreman.1
✓ task-abc-123 → foreman.1 (@feature-auth)
```

### operation: ask

queue a question to a clone. **defaults to hero** unless `--who` specified.

```
ask(prompt, options?) → Task
```

**options:**
- `--who CLONE` — target specific clone (e.g., `--who mechanic.1`)
- `--who role++` — enroll new clone, target it (e.g., `--who researcher++`)
- `--when enqueue` — add to queue (default)
- `--when disrupt` — interrupt current work, handle now
- `--watch` — queue, then stream output
- `--talk` — queue, then interactive mode
- `--zone ADDR` — dispatch to different zone
- `--await` — block until done, emit output to stdout

**examples:**
```sh
$ khlone ask "what files changed?"              # → queues to hero (e.g., foreman.1)
$ khlone ask "explain auth flow" --watch        # → hero, then stream
$ khlone ask "status?" --when disrupt           # → interrupt hero's current task
$ khlone ask "research this" --who researcher++ # → enroll researcher, bypass hero
$ khlone ask "summarize" --await >> summary.md  # → hero, block until done
```

### operation: act

queue an action to a clone. **defaults to hero** unless `--who` specified.

```
act(prompt, options?) → Task
```

**options:** same as `ask`, plus:
- `--prioritize` — queue at front (after current task)

**examples:**
```sh
$ khlone act "implement jwt validation"         # → queues to hero (e.g., foreman.1)
$ khlone act "refactor db" --watch              # → hero, then stream
$ khlone act "hotfix prod bug" --prioritize     # → hero, jump the queue
$ khlone act "review auth" --who reviewer++     # → enroll reviewer, bypass hero
$ khlone act "fix lint" --zone @hotfix-typo     # → hero in different zone
```

### operation: watch

stream clone output (passive observe).

```
watch(clone?) → stream
```

**behavior:**
- streams filtered progress output
- `ctrl+c` returns to shell
- clone continues work

**examples:**
```sh
$ khlone watch                    # watch default clone
$ khlone watch --who reviewer.1   # watch specific clone
$ khlone act "task" --watch       # queue then watch
```

### operation: talk

interactive session with clone (active converse).

```
talk(clone?) → session
```

**behavior:**
- drops into clone's repl session
- direct input/output with clone
- `/exit` returns to shell
- queue pauses while you talk

**examples:**
```sh
$ khlone talk                     # talk to default clone
$ khlone talk mechanic.1          # talk to specific clone
$ khlone act "task" --talk        # queue then talk
```

### operation: list

enumerate resources at a given scope.

```
list(scope) → resource[]
```

**scopes:** `sites` | `zones` | `crews` | `tasks` (singular aliases supported)

**examples:**
```sh
$ khlone list sites              # all sites on machine

orchestrator ~/.khlone/
├─ ehmpathy/myrepo       2 zones │ ●3 active
└─ ehmpathy/other-repo   1 zone  │ ○ idle

$ khlone list zones              # all zones in current site

site ehmpathy/myrepo
├─ @main           ○ mechanic.1
├─ @feature-auth   ● mechanic.1 (67%), ○ researcher.1
└─ @hotfix-typo    ● mechanic.1 (12%)

$ khlone list crews              # all clones in current zone

zone @feature-auth (local)
├─ ● mechanic.1     claude   67%   2 tasks
├─ ○ reviewer.1     claude    —    0 tasks
└─ ● researcher.1   claude   12%   1 task

$ khlone list tasks              # all tasks in current zone

zone @feature-auth (local)
├─ ✓ task-abc-123  "setup project"    mechanic.1   4,521 tok
├─ ● task-def-456  "implement auth"   mechanic.1   67%
└─ ◌ task-ghi-789  "add tests"        mechanic.1   queued
```

### operation: status

inspect state at a given scope — smart defaults based on pwd.

```
status(scope?) → snapshot
```

**scopes:** `orchestrator` | `site` | `zone` | `crew` | `task`

**smart defaults:**
- feature branch pwd → `zone`
- main branch pwd → `site`
- not a git repo → `orchestrator`

**examples:**
```sh
$ khlone status                  # auto-selects based on pwd

zone @feature-auth (local)
│
├─ ● mechanic.1  67%  implement auth
│  ├─ ✓ setup project structure
│  │  ├─ summary   created src/ with auth module skeleton
│  │  ├─ complete  yes
│  │  └─ tokens    4,521
│  └─ ● implement jwt validation
│
└─ queue 2 tasks

$ khlone status orchestrator     # explicit: all sites

orchestrator ~/.khlone/
├─ ehmpathy/myrepo       2 zones │ ●3 clones │ $4.21 today
└─ ehmpathy/other-repo   1 zone  │ ○ idle

$ khlone status site             # explicit: current repo

site ehmpathy/myrepo
├─ zones    3
├─ clones   ●4 active  ○2 idle
├─ tasks    ✓5 done  ●2 active  ◌3 queued
└─ tokens   45,210 today

$ khlone status --task task-abc-123   # specific task

task task-abc-123
├─ type      act
├─ prompt    "setup project structure"
├─ clone     mechanic.1
├─ status    ✓ done
└─ artifacts
   ├─ summary   created src/ with auth module skeleton
   ├─ complete  yes
   └─ tokens    4,521

$ khlone status --crew mechanic.1     # specific clone

clone mechanic.1
├─ role      ehmpathy/mechanic
├─ brain     claude
├─ status    ● active (67%)
├─ current   task-def-456 "implement auth"
├─ queue     1 task
└─ tokens    12,450 session
```

---

## flags reference

### scope flags (universal)

these flags work across all verbs to narrow scope:

| flag | narrows to | example |
|------|-----------|---------|
| `--site SLUG` | specific repo | `--site ehmpathy/svc-jobs` |
| `--zone ADDR` | specific zone | `--zone @feat/auth` or `--zone svc-jobs@main` |
| `--who SLUG` | specific clone | `--who mechanic.1` |
| `--who role++` | enroll new clone | `--who researcher++` |
| `--task SLUG` | specific task | `--task task-abc-123` |

**zone address formats:**
```
@branch                    # current site, this branch
repo@branch                # same org, different repo
org/repo@branch            # full address
```

**examples:**
```sh
--zone @feat/auth                      # zone in current site
--zone svc-jobs@main                   # zone in svc-jobs (same org)
--zone ahbode/svc-jobs@feat/invoice    # fully qualified zone
```

**cross-scope examples:**
```sh
# ask in different site (enrolls zone + clone there)
khlone ask 'how to use xyz' --zone svc-ads@main --who researcher++ >> howto.md

# status of clone in different zone (same site)
khlone status --zone @feat/auth --who architect.1

# list tasks in different site/zone (full address)
khlone list tasks --zone ahbode/svc-jobs@hotfix

# act in different site (two ways - equivalent)
khlone act 'fix bug' --site svc-jobs --zone @hotfix --who mechanic.1
khlone act 'fix bug' --zone svc-jobs@hotfix --who mechanic.1
```

### behavior flags (ask/act)

| flag | purpose |
|------|---------|
| `--skill NAME` | invoke skill (routes to capable role) |
| `--brain NAME` | use specific brain (default: hero brain) |
| `--when enqueue` | add to queue (default) |
| `--when disrupt` | interrupt current work, handle now |
| `--prioritize` | queue at front (after current task) |
| `--watch` | queue then stream output (passive) |
| `--talk` | queue then interactive mode (active) |
| `--await` | block until done, emit output to stdout |

**skill dispatch:**
```sh
# invoke skill — routes to role that knows it
$ khlone ask --skill review.architecture
$ khlone act --skill refactor.extract-method

# combine with --who to force specific clone
$ khlone ask --skill review.architecture --who reviewer++

# override brain for this task
$ khlone act "complex refactor" --brain grok
$ khlone ask "explain this" --brain gemini --await
```

---

## output legend

| symbol | indicates |
|--------|-----------|
| `●` | active (in progress) |
| `○` | idle (available) |
| `✓` | done (completed) |
| `◌` | queued (pending) |
| `✗` | failed (error) |
| `→` | enqueued to |
| `├─` `└─` `│` | tree structure |

---

## envvars

| envvar | purpose |
|--------|---------|
| `KHLONE_SESSION` | current session id (auto-set on ask/act) |
| `KHLONE_WHO` | default clone for ask/act |
| `KHLONE_WHEN` | default: enqueue or disrupt |
| `KHLONE_ZONE` | default zone (overrides cwd resolution) |

---

## cross-scope dispatch

### the pattern

```
khlone <verb> [args] [--site X] [--zone X] [--who X] [--task X]
```

you can be anywhere and reach into any scope. the orchestrator at `~/.khlone/` knows about all sites you've touched, so cross-scope address just works.

### playtest: multi-repo coordination

**scenario:** you're in `app-hometools-native`, and coordinate work across multiple backend services.

```sh
# check what's active in svc-jobs (site-level status)
$ khlone status --site svc-jobs

site ahbode/svc-jobs
├─ @main          ○ foreman.1
└─ @feat/invoice  ● foreman.1 (45%)

# peek at the invoice feature progress (zone address includes site)
$ khlone status --zone svc-jobs@feat/invoice

zone svc-jobs@feat/invoice (local)
├─ ● foreman.1  45%  implement invoice generation
└─ queue 2 tasks

# ask a question about auth in a different repo
$ khlone ask 'how does jwt validation work here' \
    --zone svc-auth@main \
    --who researcher++ \
    --await >> notes/auth-flow.md

# dispatch work to svc-jobs while you stay in current repo
$ khlone act 'add unit tests for invoices' \
    --zone svc-jobs@feat/invoice \
    --who mechanic.1

✓ task-xyz-789 → mechanic.1 (svc-jobs@feat/invoice)
```

### playtest: zone hop

**scenario:** you're on `@main`, but need to check on and dispatch to feature branches.

```sh
# see all zones in current site
$ khlone list zones

site ehmpathy/myrepo
├─ @main          ○ mechanic.1
├─ @feat/auth     ● mechanic.1 (67%), ○ researcher.1
├─ @feat/invoice  ● mechanic.1 (12%)
└─ @hotfix/typo   ✓ mechanic.1

# check status of auth feature
$ khlone status --zone @feat/auth

zone @feat/auth (local)
├─ ● mechanic.1    67%  implement jwt validation
├─ ○ researcher.1   —
└─ queue 1 task

# dispatch urgent fix to hotfix branch
$ khlone act 'fix the typo in README' \
    --zone @hotfix/typo \
    --who mechanic++ \
    --prioritize

✓ enrolled mechanic.2
✓ task-abc-123 → mechanic.2 (@hotfix/typo) [priority]

# watch progress from here
$ khlone watch --zone @hotfix/typo --who mechanic.2

lets watch...

             ┬
● mechanic.2 │ edit README.md
● mechanic.2 │ fix typo: "recieve" → "receive"
^C
```

### playtest: research delegation

**scenario:** you need answers from multiple codebases without context switch.

```sh
# ask three repos about their patterns, pipe to files
$ khlone ask 'how do you handle rate limits' \
    --zone svc-api-gateway@main \
    --who researcher++ \
    --await >> research/rate-limits-gateway.md

$ khlone ask 'how do you handle rate limits' \
    --zone svc-jobs@main \
    --who researcher++ \
    --await >> research/rate-limits-jobs.md

$ khlone ask 'how do you handle rate limits' \
    --zone svc-notifications@main \
    --who researcher++ \
    --await >> research/rate-limits-notifications.md

# check on all enrolled researchers (--zone implies site)
$ khlone list crews --zone svc-api-gateway@main
$ khlone list crews --zone svc-jobs@main
$ khlone list crews --zone svc-notifications@main
```

### playtest: orchestrator overview

**scenario:** start of day — see all repos at a glance.

```sh
# from anywhere (even outside a git repo)
$ khlone status

orchestrator ~/.khlone/
├─ ahbode/app-hometools     2 zones │ ●1 active │ $2.15 today
├─ ahbode/svc-jobs          3 zones │ ●2 active │ $4.82 today
├─ ahbode/svc-auth          1 zone  │ ○ idle
└─ ehmpathy/domain-objects  1 zone  │ ○ idle

# drill into a specific site
$ khlone status --site ahbode/svc-jobs

site ahbode/svc-jobs
├─ zones    3
├─ clones   ●4 active  ○1 idle
├─ tasks    ✓12 done  ●3 active  ◌5 queued
└─ tokens   89,421 today ($4.82)

# list all active tasks across a site
$ khlone list tasks --site ahbode/svc-jobs

├─ ● task-001  "implement invoices"  @feat/invoice  mechanic.1  45%
├─ ● task-002  "add api endpoint"    @feat/api      mechanic.1  23%
├─ ◌ task-003  "write tests"         @feat/invoice  mechanic.1  queued
└─ ◌ task-004  "update docs"         @feat/api      mechanic.1  queued
```

### why this works

the orchestrator (`~/.khlone/`) maintains a registry of all sites:

```
~/.khlone/
├── orchestrator.yml          # global config
├── sites/
│   ├── ahbode--svc-jobs/     # symlink or state ref
│   ├── ahbode--svc-auth/
│   └── ehmpathy--myrepo/
└── session/                  # cross-site session state
```

when you use `--site svc-jobs`, khlone:
1. looks up the full slug in the orchestrator registry
2. resolves to the site's gitroot path
3. dispatches the command there
4. returns output to your current shell

no need to `cd` anywhere. your shell stays yours.

---

## mental model

### how you'd describe khlone to a friend

> "khlone is a dispatcher for ai code assistants. i type `ask` or `act` — instant, no lag. the command queues and i'm back in my shell. claude runs headless in the background. i can watch output, talk directly, or just let it work. if it crashes, khlone restarts it. my shell stays mine."

### analogies

| analogy | fit |
|---------|-----|
| **print spooler** | queue tasks, execute in order, survive crashes |
| **tmux for ai** | session persists, talk/exit freely |
| **job control** | `&` and `fg` and `bg`, but with crash recovery |
| **email outbox** | write messages, they send when ready |

### orchestrator / site / zone / crew / task

```
orchestrator (~/.khlone/)              # global: all sites on machine
└── site (org/repo)                # repo: shared config, role definitions
    └── zone (@branch)                 # branch: isolated workspace
        ├── crew                       # clones in the zone
        │   └── clone                  # individual worker
        └── task                       # tasks in the zone
```

- **orchestrator** = global state, all sites you've touched
- **site** = repo-level config, role definitions
- **zone** = isolated workspace (per worktree)
- **crew** = clones in a zone
- **task** = unit of work (ask/act), assigned to a clone

---

## evaluation

### goals solved

| goal | solved? |
|------|---------|
| instant input | yes — 0ms keystrokes, local buffer |
| shell stays yours | yes — ask/act returns immediately |
| survive crashes | yes — queue persists, checkpoint resumes |
| work while busy | yes — queue stacks tasks |
| see progress | yes — watch streams filtered output |
| raw repl access | yes — talk gives direct access |
| zone awareness | yes — always shows which zone |
| token track | yes — transcript archived per clone |
| task visibility | yes — artifacts (summary, complete) per task |
| cross-zone dispatch | yes — `--zone` from any terminal |
| cross-site dispatch | yes — `--site` from anywhere |
| shell-native output | yes — `--await` pipes to files |

### pros

| benefit | details |
|---------|---------|
| instant input | 0ms keystroke latency |
| shell stays yours | ask/act and return |
| queue tasks | don't wait for completion |
| crash recovery | auto-restart, resume |
| headless efficiency | no ui overhead |
| multi-clone | parallel workers |
| multi-zone | parallel worktrees |
| multi-site | dispatch across repos from anywhere |
| transcript archive | review, token track |
| no infra required | works locally |

### edgecases

| edgecase | mitigation |
|----------|------------|
| checkpoint accuracy | conservative checkpoints, may redo some work |
| headless support | not all repls support it — fallback to hidden window |
| multi-clone resources | headless helps, still multiple processes |
| repl api changes | abstract via adapters |

### pit of success

| risk | mitigation |
|------|------------|
| forget zone | always shown in output, auto-resolved from cwd |
| lose session | `$KHLONE_SESSION` auto-set, resumes in shell |
| lose work on crash | queue persists, checkpoint resumes |
| repl hangs terminal | repl is headless, shell never blocked |
| orphan clones | `.bind/` shared across terminals |
| forgot to init | implicit init on first ask/act |
| enroll unknown role | role++ only works for defined aliases |

---

## what ships in v0.0

| capability | description |
|------------|-------------|
| `khlone init` | bind worktree to zone, enroll hero |
| implicit init | first ask/act triggers init |
| hero clone | default task target per `crew.hero` config |
| `khlone ask "..."` | queue question (creates task), return |
| `khlone act "..."` | queue action (creates task), return |
| `khlone list scope` | enumerate: `sites\|zones\|crews\|tasks` |
| `khlone status [scope]` | inspect state with smart defaults |
| `khlone watch` | stream clone output |
| `khlone talk` | interactive session |
| `khlone log` | transcript review |
| `--who clone` | target specific clone |
| `--who role++` | enroll new clone inline |
| `--skill NAME` | invoke skill, route to capable role |
| `--brain NAME` | use specific brain for task |
| `--when` | enqueue vs disrupt |
| `--watch` | stream output after dispatch |
| `--talk` | interactive mode after dispatch |
| `--zone` | cross-zone dispatch |
| `--site` | cross-site dispatch |
| `--await` | block + emit output |
| smart status defaults | pwd-aware scope selection |
| orchestrator state | `~/.khlone/` tracks all sites |
| task artifacts | summary, complete, tokens |
| onStop hooks | capture artifacts on task end |
| queue persistence | survives shell exit |
| crash recovery | auto-restart, resume |
| headless execution | low resource |
| transcript capture | full log per clone |

---

## summary

**khlone v0.0** = site orchestration for robot actors

- **orchestrator** → **site** → **zone** → **crew** + **task** hierarchy
- **hero clone** receives all tasks by default (delegator or direct doer)
- **ask/act** dispatch with instant return (each creates a task)
- **list/status** with scope argument and smart defaults
- **cross-scope dispatch** via universal `--site`, `--zone`, `--who` flags
- **watch/talk** observation modes
- **crash recovery** via checkpoints
- **headless execution** for efficiency
- **shell-native** output with `--await`

```sh
$ khlone act "implement auth"

✓ task-001 → foreman.1 (@feature-auth)
$ _                              # that's it. shell is yours.

$ khlone act "research patterns" --who researcher++

✓ task-002 → researcher.1 (@feature-auth)

$ khlone status                  # smart default: zone scope

zone @feature-auth
├─ ● foreman.1    67%
├─ ● researcher.1 12%
└─ queue 1 task
```
