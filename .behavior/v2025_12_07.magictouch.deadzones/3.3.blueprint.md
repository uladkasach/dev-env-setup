# Blueprint: evdev Filter for Dead Zones

## Overview

Create a daemon that intercepts Magic Trackpad touch events, rejects touches starting in dead zones, and forwards valid touches to a virtual device.

## Architecture

```
Magic Trackpad (/dev/input/event19)
        │
        ▼
   ┌─────────────┐
   │ evdev filter│  ← grabs device exclusively
   │   daemon    │  ← tracks touch slots
   └─────────────┘  ← filters by start coords
        │
        ▼
  uinput virtual device
        │
        ▼
    libinput / X / Wayland
```

## Dead Zone Geometry

Trackpad: 161mm × 115mm

```
├──32mm──┼─────────97mm─────────┼──32mm──┤
┌────────┬───────────────────────┬────────┐
│ DEAD   │                       │  DEAD  │ ┬
│ ZONE   │     (pass through)    │  ZONE  │ 57.5mm
│ (L)    │                       │  (R)   │ ┴
├────────┴───────────────────────┴────────┤
│                                         │
│           (pass through)                │ 57.5mm
│                                         │
└─────────────────────────────────────────┘
```

- Left dead zone: x < 20% width, y < 50% height
- Right dead zone: x > 80% width, y < 50% height

## Implementation

### Language

Python with `evdev` and `uinput` libraries (simplest for prototyping)

### Core Logic

```python
# Per-slot tracking
slots = {}  # slot_id -> { "blocked": bool, "x": int, "y": int }

for event in device.read_loop():
    if event.type == EV_ABS:
        if event.code == ABS_MT_SLOT:
            current_slot = event.value
        elif event.code == ABS_MT_TRACKING_ID:
            if event.value == -1:
                # Touch ended, clear slot
                slots.pop(current_slot, None)
            else:
                # New touch, will check position on first coords
                slots[current_slot] = {"blocked": False, "x": None, "y": None}
        elif event.code == ABS_MT_POSITION_X:
            update_slot_x(current_slot, event.value)
        elif event.code == ABS_MT_POSITION_Y:
            update_slot_y(current_slot, event.value)

    # Forward event only if slot is not blocked
    if not is_blocked(current_slot):
        virtual_device.write_event(event)
```

### Blocking Decision

Once both X and Y are known for a new touch:
```python
def should_block(x, y, max_x, max_y):
    in_left_fifth = x < (max_x * 0.20)
    in_right_fifth = x > (max_x * 0.80)
    in_top_half = y < (max_y * 0.50)
    return (in_left_fifth or in_right_fifth) and in_top_half
```

### Systemd Service

```ini
[Unit]
Description=Magic Trackpad Dead Zone Filter
After=systemd-udevd.service

[Service]
ExecStart=/usr/local/bin/magictouch-deadzone
Restart=always

[Install]
WantedBy=multi-user.target
```

## Dependencies

```bash
pip install evdev python-uinput
# or
sudo apt install python3-evdev
```

## Files to Create

1. `src/magictouch-deadzone.py` - the filter daemon
2. `src/magictouch-deadzone.service` - systemd unit
3. Update `install_env.sh` - install script

## Risks

- Device node may change on reconnect (need udev rule or dynamic detection)
- Grabbing device exclusively means filter crash = no trackpad
- May need root or input group membership
